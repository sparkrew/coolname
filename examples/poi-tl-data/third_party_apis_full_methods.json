{
  "fullMethodsPaths" : [ {
    "entryPoint" : "com.deepoove.poi.render.compute.ReadMapAccessor.generateCode",
    "thirdPartyMethod" : "org.springframework.asm.MethodVisitor.visitLdcInsn",
    "thirdPartyPackage" : "org.springframework.asm",
    "path" : [ "com.deepoove.poi.render.compute.ReadMapAccessor.generateCode" ],
    "fullMethods" : [ "@Override\npublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n    String descriptor = cf.lastDescriptor();\n    if ((descriptor == null) || (!descriptor.equals(\"Ljava/util/Map\"))) {\n        if (descriptor == null) {\n            cf.loadTarget(mv);\n        }\n        CodeFlow.insertCheckCast(mv, \"Ljava/util/Map\");\n    }\n    mv.visitLdcInsn(propertyName);\n    mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", true);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPBdr.addNewTop",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setUnderlineColor",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun" ],
    "fullMethods" : [ "/**\n * set run style by other run\n *\n * @param dest\n * @param src\n */\npublic static void styleRun(XWPFRun dest, XWPFRun src) {\n    if ((null == dest) || (null == src))\n        return;\n\n    if (StringUtils.isNotEmpty(src.getStyle()))\n        dest.setStyle(src.getStyle());\n\n    if (Boolean.TRUE.equals(src.isBold()))\n        dest.setBold(src.isBold());\n\n    if (StringUtils.isNotBlank(src.getColor()))\n        dest.setColor(src.getColor());\n\n    if (0 != src.getCharacterSpacing())\n        dest.setCharacterSpacing(src.getCharacterSpacing());\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.ascii)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.ascii);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.eastAsia)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.eastAsia);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.hAnsi)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.hAnsi);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.cs)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.cs);\n\n    Double fontSize = src.getFontSizeAsDouble();\n    if (null != fontSize) {\n        dest.setFontSize(fontSize);\n    }\n    if (Boolean.TRUE.equals(src.isItalic()))\n        dest.setItalic(src.isItalic());\n\n    if (Boolean.TRUE.equals(src.isStrikeThrough()))\n        dest.setStrikeThrough(src.isStrikeThrough());\n\n    if (UnderlinePatterns.NONE != src.getUnderline())\n        dest.setUnderline(src.getUnderline());\n\n    if (null != src.getUnderlineColor())\n        dest.setUnderlineColor(src.getUnderlineColor());\n\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setUnderlineColor",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun" ],
    "fullMethods" : [ "/**\n * set run style by style\n *\n * @param run\n * @param style\n */\npublic static void styleRun(XWPFRun run, Style style) {\n    if ((null == run) || (null == style))\n        return;\n\n    CTRPr pr = getRunProperties(run);\n    String color = style.getColor();\n    if (StringUtils.isNotBlank(color)) {\n        // run.setColor(color);\n        // issue 326\n        CTColor ctColor = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        ctColor.setVal(color);\n        if (ctColor.isSetThemeColor())\n            ctColor.unsetThemeColor();\n\n    }\n    double fontSize = style.getFontSize();\n    if ((0 != fontSize) && ((-1) != fontSize)) {\n        run.setFontSize(fontSize);\n    }\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        run.setFontFamily(fontFamily, FontCharRange.eastAsia);\n        run.setFontFamily(fontFamily, FontCharRange.ascii);\n        run.setFontFamily(fontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(fontFamily, FontCharRange.cs);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        run.setFontFamily(westernFontFamily, FontCharRange.ascii);\n        run.setFontFamily(westernFontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(westernFontFamily, FontCharRange.cs);\n    }\n    XWPFHighlightColor highlightColor = style.getHighlightColor();\n    if (null != highlightColor) {\n        CTHighlight highlight = (pr.sizeOfHighlightArray() > 0) ? pr.getHighlightArray(0) : pr.addNewHighlight();\n        highlight.setVal(STHighlightColor.Enum.forInt(highlightColor.getValue()));\n    }\n    Boolean bold = style.isBold();\n    if (null != bold)\n        run.setBold(bold);\n\n    Boolean italic = style.isItalic();\n    if (null != italic)\n        run.setItalic(italic);\n\n    Boolean strike = style.isStrike();\n    if (null != strike)\n        run.setStrikeThrough(strike);\n\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        run.setUnderline(underlinePatern);\n        if (null != style.getUnderlineColor()) {\n            run.setUnderlineColor(style.getUnderlineColor());\n        }\n    }\n    int point = style.getCharacterSpacing();\n    // in twentieths of a point\n    if ((0 != point) && ((-1) != point))\n        run.setCharacterSpacing(UnitUtils.point2Twips(point));\n\n    String vertAlign = style.getVertAlign();\n    if (StringUtils.isNotBlank(vertAlign)) {\n        run.setVerticalAlignment(vertAlign);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRPr.getHighlightArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun" ],
    "fullMethods" : [ "/**\n * set run style by style\n *\n * @param run\n * @param style\n */\npublic static void styleRun(XWPFRun run, Style style) {\n    if ((null == run) || (null == style))\n        return;\n\n    CTRPr pr = getRunProperties(run);\n    String color = style.getColor();\n    if (StringUtils.isNotBlank(color)) {\n        // run.setColor(color);\n        // issue 326\n        CTColor ctColor = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        ctColor.setVal(color);\n        if (ctColor.isSetThemeColor())\n            ctColor.unsetThemeColor();\n\n    }\n    double fontSize = style.getFontSize();\n    if ((0 != fontSize) && ((-1) != fontSize)) {\n        run.setFontSize(fontSize);\n    }\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        run.setFontFamily(fontFamily, FontCharRange.eastAsia);\n        run.setFontFamily(fontFamily, FontCharRange.ascii);\n        run.setFontFamily(fontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(fontFamily, FontCharRange.cs);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        run.setFontFamily(westernFontFamily, FontCharRange.ascii);\n        run.setFontFamily(westernFontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(westernFontFamily, FontCharRange.cs);\n    }\n    XWPFHighlightColor highlightColor = style.getHighlightColor();\n    if (null != highlightColor) {\n        CTHighlight highlight = (pr.sizeOfHighlightArray() > 0) ? pr.getHighlightArray(0) : pr.addNewHighlight();\n        highlight.setVal(STHighlightColor.Enum.forInt(highlightColor.getValue()));\n    }\n    Boolean bold = style.isBold();\n    if (null != bold)\n        run.setBold(bold);\n\n    Boolean italic = style.isItalic();\n    if (null != italic)\n        run.setItalic(italic);\n\n    Boolean strike = style.isStrike();\n    if (null != strike)\n        run.setStrikeThrough(strike);\n\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        run.setUnderline(underlinePatern);\n        if (null != style.getUnderlineColor()) {\n            run.setUnderlineColor(style.getUnderlineColor());\n        }\n    }\n    int point = style.getCharacterSpacing();\n    // in twentieths of a point\n    if ((0 != point) && ((-1) != point))\n        run.setCharacterSpacing(UnitUtils.point2Twips(point));\n\n    String vertAlign = style.getVertAlign();\n    if (StringUtils.isNotBlank(vertAlign)) {\n        run.setVerticalAlignment(vertAlign);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.setSpacingAfterLines",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toEndToken",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph" ],
    "fullMethods" : [ "@Override\npublic XWPFParagraph insertNewParagraph(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTP.type.getName().getNamespaceURI();\n        /* TODO DO not use a coded constant, find the constant in the OOXML\n        classes instead, as the child of type CT_Paragraph is defined in the\n        OOXML schema as 'p'\n         */\n        String localPart = \"p\";\n        // creates a new Paragraph, cursor is positioned inside the new\n        // element\n        cursor.beginElement(localPart, uri);\n        // move the cursor to the START token to the paragraph just created\n        cursor.toParent();\n        CTP p = ((CTP) (cursor.getObject()));\n        XWPFParagraph newP = new XWPFParagraph(p, this);\n        XmlObject o = null;\n        /* move the cursor to the previous element until a) the next\n        paragraph is found or b) all elements have been passed\n         */\n        while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        /* if the object that has been found is a) not a paragraph or b) is\n        the paragraph that has just been inserted, as the cursor in the\n        while loop above was not moved as there were no other siblings,\n        then the paragraph that was just inserted is the first paragraph\n        in the body. Otherwise, take the previous paragraph and calculate\n        the new index for the new paragraph.\n         */\n        if ((!(o instanceof CTP)) || (o == p)) {\n            paragraphs.add(0, newP);\n        } else {\n            int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n            paragraphs.add(pos, newP);\n        }\n        /* create a new cursor, that points to the START token of the just\n        inserted paragraph\n         */\n        XmlCursor newParaPos = p.newCursor();\n        try {\n            /* Calculate the paragraphs index in the list of all body\n            elements\n             */\n            int i = 0;\n            cursor.toCursor(newParaPos);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newP);\n            cursor.toCursor(newParaPos);\n            cursor.toEndToken();\n            return newP;\n        } finally {\n            newParaPos.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toEndToken",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph" ],
    "fullMethods" : [ "/**\n * add a new paragraph at position of the cursor\n *\n * @param cursor\n * \t\tThe XmlCursor structure created with XmlBeans\n * @return the inserted paragraph\n */\n@Override\npublic XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInTextBox(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    bodyElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toEndToken",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph" ],
    "fullMethods" : [ "public XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInBlockContent(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    sdtElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewTbl",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toEndToken",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewTbl" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTbl(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTTbl.type.getName().getNamespaceURI();\n        String localPart = \"tbl\";\n        cursor.beginElement(localPart, uri);\n        cursor.toParent();\n        CTTbl t = ((CTTbl) (cursor.getObject()));\n        XWPFTable newT = new XWPFTable(t, this);\n        XmlObject o = null;\n        while ((!(o instanceof CTTbl)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        if (!(o instanceof CTTbl)) {\n            tables.add(0, newT);\n        } else {\n            int pos = tables.indexOf(getTable(((CTTbl) (o)))) + 1;\n            tables.add(pos, newT);\n        }\n        int i = 0;\n        XmlCursor tableCursor = t.newCursor();\n        try {\n            cursor.toCursor(tableCursor);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newT);\n            cursor.toCursor(tableCursor);\n            cursor.toEndToken();\n            return newT;\n        } finally {\n            tableCursor.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFComment.setInitials",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment" ],
    "fullMethods" : [ "public static void renderComment(XWPFRun run, CommentRenderData data) throws Exception {\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper parentContext = new XWPFParagraphWrapper(paragraph);\n    BigInteger cId = BigInteger.ZERO;\n    CommentContent commentContent = data.getCommentContent();\n    if (null != commentContent) {\n        XWPFComments comments = ((NiceXWPFDocument) (paragraph.getDocument())).createComments();\n        XWPFComment newComment = comments.createComment(NextIDUtils.getCommentMaxId(comments).add(BigInteger.ONE));\n        newComment.setAuthor(commentContent.getAuthor());\n        newComment.setDate(commentContent.getDate());\n        newComment.setInitials(commentContent.getInitials());\n        renderDocument(newComment.createParagraph().createRun(), commentContent.getContent());\n        cId = newComment.getCtComment().getId();\n        parentContext.insertNewCommentRangeStart(run, cId);\n    }\n    renderParagraph(run, Paragraphs.of().addList(data.getContents()).create());\n    if (null != commentContent) {\n        parentContext.insertNewCommentRangeEnd(run, cId);\n        XWPFRun newRun = parentContext.insertNewRun(ParagraphUtils.getRunPos(run));\n        newRun.getCTR().addNewCommentReference().setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.SDTBodyContainer.setParagraph",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTSdtContentBlock.setPArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.SDTBodyContainer.setParagraph" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setParagraph(XWPFParagraph paragraph, int pos) {\n    List<XWPFParagraph> paragraphs = ((List<XWPFParagraph>) (ReflectionUtils.getValue(\"paragraphs\", sdtContent)));\n    paragraphs.set(pos, paragraph);\n    CTSdtContentBlock sdtContentBlock = sdtContent.getSdtContentBlock();\n    sdtContentBlock.setPArray(pos, paragraph.getCTP());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr.addNewWidowControl",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.EnhancedXWPFChart.setExternalId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTExternalData.addNewAutoUpdate",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.EnhancedXWPFChart.setExternalId" ],
    "fullMethods" : [ "@Override\npublic void setExternalId(String id) {\n    CTChartSpace ctChartSpace = getCTChartSpace();\n    CTExternalData externalData = (ctChartSpace.isSetExternalData()) ? ctChartSpace.getExternalData() : ctChartSpace.addNewExternalData();\n    externalData.setId(id);\n    if (!externalData.isSetAutoUpdate()) {\n        externalData.addNewAutoUpdate().setVal(true);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.addSeries",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTUnsignedInt.setVal",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.addSeries" ],
    "fullMethods" : [ "@Override\npublic XDDFChartData.Series addSeries(XDDFDataSource<?> category, XDDFNumericalDataSource<? extends Number> values) {\n    final long index = ++this.seriesNum;\n    final CTPieSer ctSer = this.chart.addNewSer();\n    ctSer.addNewCat();\n    ctSer.addNewVal();\n    ctSer.addNewIdx().setVal(index);\n    ctSer.addNewOrder().setVal(index);\n    final Series added = new Series(ctSer, category, values);\n    this.series.add(added);\n    return added;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setExplosion",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTUnsignedInt.setVal",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setExplosion" ],
    "fullMethods" : [ "public void setExplosion(Long explosion) {\n    if (explosion == null) {\n        if (series.isSetExplosion()) {\n            series.unsetExplosion();\n        }\n    } else if (series.isSetExplosion()) {\n        series.getExplosion().setVal(explosion);\n    } else {\n        series.addNewExplosion().setVal(explosion);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPBdr.addNewRight",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.widthTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblPr.getTblW",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.widthTable" ],
    "fullMethods" : [ "@Deprecated\npublic static void widthTable(XWPFTable table, float widthCM, int cols) {\n    int width = UnitUtils.cm2Twips(widthCM);\n    CTTblPr tblPr = getTblPr(table);\n    CTTblWidth tblW = (tblPr.isSetTblW()) ? tblPr.getTblW() : tblPr.addNewTblW();\n    tblW.setType(0 == width ? STTblWidth.AUTO : STTblWidth.DXA);\n    tblW.setW(BigInteger.valueOf(width));\n    if (0 != width) {\n        CTTblGrid tblGrid = getTblGrid(table);\n        for (int j = 0; j < cols; j++) {\n            CTTblGridCol addNewGridCol = tblGrid.addNewGridCol();\n            addNewGridCol.setW(BigInteger.valueOf(width / cols));\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.widthTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblPr.getTblW",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.widthTable" ],
    "fullMethods" : [ "@Deprecated\npublic static void widthTable(XWPFTable table, float[] colWidths) {\n    float widthCM = 0;\n    for (float w : colWidths) {\n        widthCM += w;\n    }\n    int width = UnitUtils.cm2Twips(widthCM);\n    CTTblPr tblPr = getTblPr(table);\n    CTTblWidth tblW = (tblPr.isSetTblW()) ? tblPr.getTblW() : tblPr.addNewTblW();\n    tblW.setType(0 == width ? STTblWidth.AUTO : STTblWidth.DXA);\n    tblW.setW(BigInteger.valueOf(width));\n    if (0 != width) {\n        CTTblGrid tblGrid = getTblGrid(table);\n        for (float w : colWidths) {\n            CTTblGridCol addNewGridCol = tblGrid.addNewGridCol();\n            addNewGridCol.setW(BigInteger.valueOf(UnitUtils.cm2Twips(w)));\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFSection.<init>",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTSectPr.isSetPgSz",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XWPFSection.<init>" ],
    "fullMethods" : [ "public XWPFSection(CTSectPr sectPr) {\n    this.sectPr = sectPr;\n    if (sectPr.isSetPgMar()) {\n        this.pageMargin = new XWPFPageMargin(sectPr.getPgMar());\n    }\n    if (sectPr.isSetPgSz()) {\n        this.pageSize = new XWPFPageSize(sectPr.getPgSz());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShowLeaderLines",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.isSetDLbls",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShowLeaderLines" ],
    "fullMethods" : [ "@Override\npublic void setShowLeaderLines(boolean showLeaderLines) {\n    if (!series.isSetDLbls()) {\n        series.addNewDLbls();\n    }\n    if (series.getDLbls().isSetShowLeaderLines()) {\n        series.getDLbls().getShowLeaderLines().setVal(showLeaderLines);\n    } else {\n        series.getDLbls().addNewShowLeaderLines().setVal(showLeaderLines);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblPr.isSetTblInd",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTable" ],
    "fullMethods" : [ "/**\n * set table style\n *\n * @param table\n * @param tableStyle\n */\npublic static void styleTable(XWPFTable table, TableStyle tableStyle) {\n    if ((null == table) || (null == tableStyle))\n        return;\n\n    TableTools.setWidth(table, tableStyle.getWidth(), tableStyle.getColWidths());\n    TableTools.setBorder(table::setLeftBorder, tableStyle.getLeftBorder());\n    TableTools.setBorder(table::setRightBorder, tableStyle.getRightBorder());\n    TableTools.setBorder(table::setTopBorder, tableStyle.getTopBorder());\n    TableTools.setBorder(table::setBottomBorder, tableStyle.getBottomBorder());\n    TableTools.setBorder(table::setInsideHBorder, tableStyle.getInsideHBorder());\n    TableTools.setBorder(table::setInsideVBorder, tableStyle.getInsideVBorder());\n    if (null != tableStyle.getAlign()) {\n        table.setTableAlignment(tableStyle.getAlign());\n    }\n    table.setCellMargins(tableStyle.getTopCellMargin(), tableStyle.getLeftCellMargin(), tableStyle.getBottomCellMargin(), tableStyle.getRightCellMargin());\n    if (null != tableStyle.getIndentation()) {\n        CTTbl ctTbl = table.getCTTbl();\n        CTTblPr tPr = (ctTbl.getTblPr() != null) ? ctTbl.getTblPr() : ctTbl.addNewTblPr();\n        CTTblWidth tw = (tPr.isSetTblInd()) ? tPr.getTblInd() : tPr.addNewTblInd();\n        tw.setType(STTblWidth.DXA);\n        tw.setW(BigInteger.valueOf(UnitUtils.cm2Twips(tableStyle.getIndentation())));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CTDrawingWrapper.getDesc",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.main.CTNonVisualDrawingProps.getDescr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.CTDrawingWrapper.getDesc" ],
    "fullMethods" : [ "public String getDesc() {\n    return null == docPr ? null : docPr.getDescr();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.NumberingRenderPolicy.Helper.renderNumbering",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.setNumILvl",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.NumberingRenderPolicy.Helper.renderNumbering" ],
    "fullMethods" : [ "public static void renderNumbering(XWPFRun run, NumberingRenderData data) throws Exception {\n    List<NumberingItemRenderData> items = data.getItems();\n    NumberingFormat[] array = data.getFormats().toArray(new NumberingFormat[]{  });\n    BigInteger numID = ((NiceXWPFDocument) (run.getParent().getDocument())).addNewMultiLevelNumberingId(array);\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    for (NumberingItemRenderData item : items) {\n        XWPFParagraph paragraph = bodyContainer.insertNewParagraph(run);\n        int level = item.getLevel();\n        if (NumberingItemRenderData.LEVEL_NORMAL != level) {\n            paragraph.setNumID(numID);\n            paragraph.setNumILvl(BigInteger.valueOf(level));\n        }\n        XWPFRun createRun = paragraph.createRun();\n        // StyleUtils.styleParaRpr(paragraph, StyleUtils.retriveStyle(run));\n        StyleUtils.styleRun(createRun, run);\n        ParagraphRenderPolicy.Helper.renderParagraph(createRun, item.getItem());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.setNumILvl",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getTableRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        for (int i = rowSize - 1; i >= 0; i--) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            String text = row.getCell(actualInsertPosition).getText();\n            if (\"_delete_\".equals(text)) {\n                table.removeRow(i);\n            } else {\n                removeCell(row, actualInsertPosition);\n            }\n        }\n    } catch (Exception e) {\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getTableRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.DynamicTableRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getTableRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.DynamicTableRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(RenderContext<Object> context) throws Exception {\n    RunTemplate runTemplate = ((RunTemplate) (context.getEleTemplate()));\n    XWPFRun run = runTemplate.getRun();\n    run.setText(\"\", 0);\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell cell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = cell.getTableRow().getTable();\n        render(table, context.getData());\n    } catch (Exception e) {\n        throw new RenderException(\"Dynamic render table error:\" + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getTableRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getTableRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        if ((null != data) && (data instanceof Iterable)) {\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            XWPFTableRow templateRow = table.getRow(templateRowIndex);\n            int insertPosition = templateRowIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            boolean firstFlag = true;\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateRowIndex++;\n                XWPFTableRow nextRow = table.insertNewTableRow(insertPosition);\n                setTableRow(table, templateRow, insertPosition);\n                // double set row\n                XmlCursor newCursor = templateRow.getCtRow().newCursor();\n                newCursor.toPrevSibling();\n                XmlObject object = newCursor.getObject();\n                nextRow = new XWPFTableRow(((CTRow) (object)), table);\n                if (!firstFlag) {\n                    // update VMerge cells for non-first row\n                    List<XWPFTableCell> tableCells = nextRow.getTableCells();\n                    for (XWPFTableCell cell : tableCells) {\n                        CTTcPr tcPr = TableTools.getTcPr(cell);\n                        CTVMerge vMerge = tcPr.getVMerge();\n                        if (null == vMerge)\n                            continue;\n\n                        if (STMerge.RESTART == vMerge.getVal()) {\n                            vMerge.setVal(STMerge.CONTINUE);\n                        }\n                    }\n                } else {\n                    firstFlag = false;\n                }\n                setTableRow(table, nextRow, insertPosition);\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                List<XWPFTableCell> cells = nextRow.getTableCells();\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        table.removeRow(templateRowIndex);\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \" error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getTableRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    try {\n        RunTemplate runTemplate = cast2runTemplate(eleTemplate);\n        XWPFRun run = runTemplate.getRun();\n        checkTargetIsTable(run, (\"Processing [\" + runTemplate.getTagName()) + \"] failed, the target content is not a table\");\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        final XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n        // \n        int position = getRowIndex(tagCell.getTableRow());\n        List<XWPFTableRow> tempRows = getAllTemplateRow(table, position);\n        if ((null != data) && (data instanceof Iterable)) {\n            // \n            final XWPFTableRow firstTempRow = tempRows.get(0);\n            Iterator<?> dataIt = ((Iterable<?>) (data)).iterator();\n            boolean hasNextData = dataIt.hasNext();\n            int index = 0;\n            while (hasNextData) {\n                Object dt = dataIt.next();\n                hasNextData = dataIt.hasNext();\n                Iterator<XWPFTableRow> rowTempIt = tempRows.iterator();\n                boolean hasNextTempRow = rowTempIt.hasNext();\n                while (hasNextTempRow) {\n                    XWPFTableRow tempRow = rowTempIt.next();\n                    hasNextTempRow = rowTempIt.hasNext();\n                    if (!table.addRow(tempRow, position)) {\n                        throw new RenderException(\"\");\n                    }\n                    // \n                    XmlCursor newCursor = firstTempRow.getCtRow().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    XWPFTableRow newRow = new XWPFTableRow(((CTRow) (object)), table);\n                    newRow.getCtRow().set(object);\n                    setTableRow(table, newRow, position);\n                    List<XWPFTableCell> cells = newRow.getTableCells();\n                    RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(dt, EnvIterator.makeEnv(index, hasNextData || hasNextTempRow)));\n                    cells.forEach(tableCell -> {\n                        List<MetaTemplate> metaTemplates = resolver.resolveBodyElements(tableCell.getBodyElements());\n                        new DocumentProcessor(template, resolver, dataCompute).process(metaTemplates);\n                    });\n                    ++position;\n                } \n                ++index;\n            } \n        }\n        removeTableRow(table, position, tempRows.size());\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-row template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getTableRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        int templateColIndex = getColIndex(tagCell);\n        if ((null == data) || ((data instanceof Boolean) && (!((Boolean) (data))))) {\n            // table.removeRow(templateRowIndex);\n            // tagCell.setText(\"_delete_\");\n            run.setText(\"_delete_\", 0);\n            CTTcPr tcPr = TableTools.getTcPr(tagCell);\n            CTVMerge vMerge = tcPr.getVMerge();\n            System.out.println(null == vMerge ? null : vMerge.getVal());\n            if ((null != vMerge) && vMerge.getVal().equals(STMerge.RESTART)) {\n                XWPFTableRow row = table.getRow(templateRowIndex + 1);\n                int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n                XWPFTableCell actualCell = row.getCell(actualInsertPosition);\n                System.out.println(actualCell.getCTTc());\n                actualCell.getParagraphArray(0).createRun().setText(\"_delete_\", 0);\n            }\n        } else {\n            run.setText(\"\", 0);\n        }\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPBdr.isSetRight",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPBdr.isSetRight",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyle(XWPFParagraph paragraph) {\n    if (null == paragraph)\n        return null;\n\n    Builder builder = ParagraphStyle.builder();\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    if (paragraph.isWordWrapped()) {\n        builder.withAllowWordBreak(true);\n    }\n    if (pr.isSetPBdr()) {\n        CTPBdr ct = pr.getPBdr();\n        if (ct.isSetLeft()) {\n            builder.withLeftBorder(retriveBorderStyle(ct.getLeft()));\n        }\n        if (ct.isSetTop()) {\n            builder.withTopBorder(retriveBorderStyle(ct.getTop()));\n        }\n        if (ct.isSetRight()) {\n            builder.withRightBorder(retriveBorderStyle(ct.getRight()));\n        }\n        if (ct.isSetBottom()) {\n            builder.withBottomBorder(retriveBorderStyle(ct.getBottom()));\n        }\n    }\n    if (pr.isSetShd()) {\n        CTShd shd = pr.getShd();\n        builder.withShadingPattern(XWPFShadingPattern.valueOf(shd.getVal().intValue()));\n        if (shd.isSetFill())\n            builder.withBackgroundColor(shd.xgetFill().getStringValue());\n\n    }\n    builder.withAlign(paragraph.getAlignment());\n    int spacingBeforeLines = paragraph.getSpacingBeforeLines();\n    if ((-1) != spacingBeforeLines) {\n        builder.withSpacingBeforeLines(spacingBeforeLines / 100.0F);\n    }\n    int spacingAfterLines = paragraph.getSpacingAfterLines();\n    if ((-1) != spacingAfterLines) {\n        builder.withSpacingAfterLines(spacingAfterLines / 100.0F);\n    }\n    int spacingBefore = paragraph.getSpacingBefore();\n    if ((-1) != spacingBefore) {\n        builder.withSpacingBefore(UnitUtils.twips2Point(spacingBefore));\n    }\n    int spacingAfter = paragraph.getSpacingAfter();\n    if ((-1) != spacingAfter) {\n        builder.withSpacingAfter(UnitUtils.twips2Point(spacingAfter));\n    }\n    double spacingBetween = paragraph.getSpacingBetween();\n    if ((-1) != spacingBetween) {\n        builder.withSpacing(spacingBetween);\n        builder.withSpacingRule(paragraph.getSpacingLineRule());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTAxDataSource.isSetNumLit",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.plot" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartMultiSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    List<XDDFChartData> chartSeries = chart.getChartSeries();\n    validate(chartSeries, data);\n    int totalSeriesCount = ensureSeriesCount(chart, chartSeries);\n    int valueCol = 1;\n    List<SeriesRenderData> usedSeriesDatas = new ArrayList<>();\n    for (XDDFChartData chartData : chartSeries) {\n        int orignSize = chartData.getSeriesCount();\n        List<SeriesRenderData> currentSeriesData = null;\n        if (chartSeries.size() <= 1) {\n            // ignore combo type\n            currentSeriesData = data.getSeriesDatas();\n        } else {\n            currentSeriesData = obtainSeriesData(chartData.getClass(), data.getSeriesDatas());\n        }\n        usedSeriesDatas.addAll(currentSeriesData);\n        int currentSeriesSize = currentSeriesData.size();\n        XDDFDataSource<?> categoriesData = null;\n        if (chartData instanceof XDDFScatterChartData) {\n            categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n        } else {\n            categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n        }\n        for (int i = 0; i < currentSeriesSize; i++) {\n            XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, currentSeriesData.get(i).getValues(), valueCol);\n            XDDFChartData.Series currentSeries = null;\n            if (i < orignSize) {\n                currentSeries = chartData.getSeries(i);\n                valuesData.setFormatCode(currentSeries.getValuesData().getFormatCode());\n                currentSeries.replaceData(categoriesData, valuesData);\n            } else {\n                // add series, should copy series with style\n                currentSeries = chartData.addSeries(categoriesData, valuesData);\n                processNewSeries(chartData, currentSeries);\n            }\n            String name = currentSeriesData.get(i).getName();\n            currentSeries.setTitle(name, chart.setSheetTitle(name, valueCol));\n            valueCol++;\n        }\n        // clear extra series\n        removeExtraSeries(chartData, orignSize, currentSeriesSize);\n    }\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    updateCTTable(sheet, usedSeriesDatas);\n    removeExtraSheetCell(sheet, data.getCategories().length, totalSeriesCount, usedSeriesDatas.size());\n    for (XDDFChartData chartData : chartSeries) {\n        plot(chart, chartData);\n    }\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "@SuppressWarnings(\"deprecation\")\nprotected void plot(XWPFChart chart, XDDFChartData data) throws Exception {\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    Method method = XDDFChart.class.getDeclaredMethod(\"fillSheet\", XSSFSheet.class, XDDFDataSource.class, XDDFNumericalDataSource.class);\n    method.setAccessible(true);\n    for (XDDFChartData.Series series : data.getSeries()) {\n        boolean numeric = series.getCategoryData().isNumeric();\n        if (!numeric) {\n            Method getAxDSMethod = series.getClass().getDeclaredMethod(\"getAxDS\");\n            getAxDSMethod.setAccessible(true);\n            CTAxDataSource axDataSource = ((CTAxDataSource) (getAxDSMethod.invoke(series)));\n            if (axDataSource.isSetNumRef()) {\n                axDataSource.unsetNumRef();\n            }\n            if (axDataSource.isSetNumLit()) {\n                axDataSource.unsetNumLit();\n            }\n        }\n        series.plot();\n        method.invoke(chart, sheet, series.getCategoryData(), series.getValuesData());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTAxDataSource.isSetNumLit",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.plot" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartSingleSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    XDDFChartData pie = ChartUtils.getChartSeries(chart).get(0);\n    SeriesRenderData seriesDatas = data.getSeriesData();\n    XDDFDataSource<?> categoriesData = null;\n    if (pie instanceof XDDFScatterChartData) {\n        categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n    } else {\n        categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n    }\n    XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, seriesDatas.getValues(), 1);\n    XDDFChartData.Series currentSeries = pie.getSeries(0);\n    currentSeries.replaceData(categoriesData, valuesData);\n    currentSeries.setTitle(seriesDatas.getName(), chart.setSheetTitle(seriesDatas.getName(), 1));\n    updateCTTable(chart.getWorkbook().getSheetAt(0), Arrays.asList(seriesDatas));\n    plot(chart, pie);\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "@SuppressWarnings(\"deprecation\")\nprotected void plot(XWPFChart chart, XDDFChartData data) throws Exception {\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    Method method = XDDFChart.class.getDeclaredMethod(\"fillSheet\", XSSFSheet.class, XDDFDataSource.class, XDDFNumericalDataSource.class);\n    method.setAccessible(true);\n    for (XDDFChartData.Series series : data.getSeries()) {\n        boolean numeric = series.getCategoryData().isNumeric();\n        if (!numeric) {\n            Method getAxDSMethod = series.getClass().getDeclaredMethod(\"getAxDS\");\n            getAxDSMethod.setAccessible(true);\n            CTAxDataSource axDataSource = ((CTAxDataSource) (getAxDSMethod.invoke(series)));\n            if (axDataSource.isSetNumRef()) {\n                axDataSource.unsetNumRef();\n            }\n            if (axDataSource.isSetNumLit()) {\n                axDataSource.unsetNumLit();\n            }\n        }\n        series.plot();\n        method.invoke(chart, sheet, series.getCategoryData(), series.getValuesData());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.apache.poi.openxml4j.opc.PackageRelationship.getTargetMode",
    "thirdPartyPackage" : "org.apache.poi.openxml4j.opc",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableString", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeExternalPicture" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "protected String createMergeableString(NiceXWPFDocument source, NiceXWPFDocument merged, Map<String, String> styleIdsMap) throws InvalidFormatException, IOException {\n    CTBody mergedBody = merged.getDocument().getBody();\n    // TODO For the same style, reduce the number of merges\n    // Map<String, String> styleIdsMap = mergeStyles(docMerge);\n    Map<String, String> numIdsMap = mergeNumbering(source, merged);\n    Map<String, String> blipIdsMap = mergePicture(source, merged);\n    Map<String, String> externalBlipIdsMap = mergeExternalPicture(source, merged);\n    Map<String, String> hyperlinkMap = mergeHyperlink(source, merged);\n    Map<String, String> chartIdsMap = mergeChart(source, merged);\n    Map<String, String> attachmentIdsMap = mergeAttachment(source, merged);\n    Map<String, String> footnoteIdsMap = mergeFootnote(source, merged);\n    Map<String, String> endnoteIdsMap = mergeEndnote(source, merged);\n    String appendString = mergedBody.xmlText(DefaultXmlOptions.OPTIONS_OUTER);\n    String addPart = ridSectPr(appendString);\n    // style\n    for (String styleId : styleIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:pStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:pStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:tblStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:tblStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:rStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:rStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\");\n    }\n    // picture id\n    Map<String, String> placeHolderblipIdsMap = new HashMap<String, String>();\n    for (String relaId : blipIdsMap.keySet()) {\n        placeHolderblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:embed=\\\"\" + relaId) + \"\\\"\", (\"r:embed=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n        // w:pict v:shape v:imagedata\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    Map<String, String> placeHolderExternalblipIdsMap = new HashMap<String, String>();\n    for (String relaId : externalBlipIdsMap.keySet()) {\n        placeHolderExternalblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderExternalblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:link=\\\"\" + relaId) + \"\\\"\", (\"r:link=\\\"\" + placeHolderExternalblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // hyperlink id\n    for (String relaId : hyperlinkMap.keySet()) {\n        hyperlinkMap.put(relaId, hyperlinkMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : hyperlinkMap.keySet()) {\n        // w:hyperlink r:id\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + hyperlinkMap.get(relaId)) + \"\\\"\");\n    }\n    // chart id\n    for (String relaId : chartIdsMap.keySet()) {\n        chartIdsMap.put(relaId, chartIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : chartIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + chartIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // attachment id\n    for (String relaId : attachmentIdsMap.keySet()) {\n        attachmentIdsMap.put(relaId, attachmentIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : attachmentIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + attachmentIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // footnote id\n    for (String relaId : footnoteIdsMap.keySet()) {\n        footnoteIdsMap.put(relaId, footnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : footnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"footnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"footnoteReference w:id=\\\"\" + footnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // endnote id\n    for (String relaId : endnoteIdsMap.keySet()) {\n        endnoteIdsMap.put(relaId, endnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : endnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"endnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"endnoteReference w:id=\\\"\" + endnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // numbering numId\n    for (String relaId : numIdsMap.keySet()) {\n        numIdsMap.put(relaId, numIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String numId : numIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:numId\\\\sw:val=\\\"\" + numId) + \"\\\"\", (\"<w:numId w:val=\\\"\" + numIdsMap.get(numId)) + \"\\\"\");\n    }\n    return addPart.replaceAll(CROSS_REPLACE_STRING, \"\");\n}", "protected Map<String, String> mergeExternalPicture(NiceXWPFDocument source, NiceXWPFDocument merged) throws InvalidFormatException {\n    Map<String, String> blipIdsMap = new HashMap<String, String>();\n    PackageRelationshipCollection imagePart = merged.getPackagePart().getRelationshipsByType(PackageRelationshipTypes.IMAGE_PART);\n    Iterator<PackageRelationship> iterator = imagePart.iterator();\n    while (iterator.hasNext()) {\n        PackageRelationship relationship = iterator.next();\n        if (relationship.getTargetMode() == TargetMode.EXTERNAL) {\n            PackageRelationship relationshipNew = source.getPackagePart().addExternalRelationship(relationship.getTargetURI().toString(), XWPFRelation.IMAGES.getRelation());\n            blipIdsMap.putIfAbsent(relationship.getId(), relationshipNew.getId());\n        }\n    } \n    return blipIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShapeProperties",
    "thirdPartyMethod" : "org.apache.poi.xddf.usermodel.XDDFShapeProperties.getXmlObject",
    "thirdPartyPackage" : "org.apache.poi.xddf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShapeProperties" ],
    "fullMethods" : [ "@Override\npublic void setShapeProperties(XDDFShapeProperties properties) {\n    if (properties == null) {\n        if (series.isSetSpPr()) {\n            series.unsetSpPr();\n        }\n    } else if (series.isSetSpPr()) {\n        series.setSpPr(properties.getXmlObject());\n    } else {\n        series.addNewSpPr().set(properties.getXmlObject());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.SchemaType.getName",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph" ],
    "fullMethods" : [ "@Override\npublic XWPFParagraph insertNewParagraph(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTP.type.getName().getNamespaceURI();\n        /* TODO DO not use a coded constant, find the constant in the OOXML\n        classes instead, as the child of type CT_Paragraph is defined in the\n        OOXML schema as 'p'\n         */\n        String localPart = \"p\";\n        // creates a new Paragraph, cursor is positioned inside the new\n        // element\n        cursor.beginElement(localPart, uri);\n        // move the cursor to the START token to the paragraph just created\n        cursor.toParent();\n        CTP p = ((CTP) (cursor.getObject()));\n        XWPFParagraph newP = new XWPFParagraph(p, this);\n        XmlObject o = null;\n        /* move the cursor to the previous element until a) the next\n        paragraph is found or b) all elements have been passed\n         */\n        while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        /* if the object that has been found is a) not a paragraph or b) is\n        the paragraph that has just been inserted, as the cursor in the\n        while loop above was not moved as there were no other siblings,\n        then the paragraph that was just inserted is the first paragraph\n        in the body. Otherwise, take the previous paragraph and calculate\n        the new index for the new paragraph.\n         */\n        if ((!(o instanceof CTP)) || (o == p)) {\n            paragraphs.add(0, newP);\n        } else {\n            int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n            paragraphs.add(pos, newP);\n        }\n        /* create a new cursor, that points to the START token of the just\n        inserted paragraph\n         */\n        XmlCursor newParaPos = p.newCursor();\n        try {\n            /* Calculate the paragraphs index in the list of all body\n            elements\n             */\n            int i = 0;\n            cursor.toCursor(newParaPos);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newP);\n            cursor.toCursor(newParaPos);\n            cursor.toEndToken();\n            return newP;\n        } finally {\n            newParaPos.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.SchemaType.getName",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph" ],
    "fullMethods" : [ "/**\n * add a new paragraph at position of the cursor\n *\n * @param cursor\n * \t\tThe XmlCursor structure created with XmlBeans\n * @return the inserted paragraph\n */\n@Override\npublic XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInTextBox(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    bodyElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.SchemaType.getName",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph" ],
    "fullMethods" : [ "public XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInBlockContent(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    sdtElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewRunAfter",
    "thirdPartyMethod" : "org.apache.xmlbeans.SchemaType.getName",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewRunAfter" ],
    "fullMethods" : [ "public XWPFRun insertNewRunAfter(int pos) {\n    if (pos == runs.size()) {\n        return createRun();\n    }\n    if ((pos >= 0) && (pos < runs.size())) {\n        XWPFRun run = runs.get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInRunContent(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInRunContent(newCursor)) {\n            boolean nextSibling = newCursor.toNextSibling();\n            if (!nextSibling) {\n                return createRun();\n            }\n            // provide a new run\n            String uri = CTR.type.getName().getNamespaceURI();\n            String localPart = \"r\";\n            // creates a new run, cursor is positioned inside the new\n            // element\n            newCursor.beginElement(localPart, uri);\n            // move the cursor to the START token to the run just created\n            newCursor.toParent();\n            CTR r = ((CTR) (newCursor.getObject()));\n            XWPFRun newRun = new XWPFRun(r, ((IRunBody) (this)));\n            // To update the iruns, find where we're going\n            // in the normal runs, and go in there\n            int iPos = sdtElements.size();\n            int oldAt = sdtElements.indexOf(run);\n            if (oldAt != (-1)) {\n                iPos = oldAt;\n            }\n            if ((iPos + 1) >= sdtElements.size()) {\n                sdtElements.add(newRun);\n            } else {\n                sdtElements.add(iPos, newRun);\n            }\n            // Runs itself is easy to update\n            if ((pos + 1) >= runs.size()) {\n                runs.add(newRun);\n            } else {\n                runs.add(pos + 1, newRun);\n            }\n            newCursor.dispose();\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter",
    "thirdPartyMethod" : "org.apache.xmlbeans.SchemaType.getName",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter" ],
    "fullMethods" : [ "public XWPFRun insertNewRunAfter(int pos) {\n    if (pos == paragraph.getRuns().size()) {\n        return paragraph.createRun();\n    }\n    if ((pos >= 0) && (pos < paragraph.getRuns().size())) {\n        XWPFRun run = paragraph.getRuns().get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInParagraph(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInParagraph(newCursor)) {\n            boolean nextSibling = newCursor.toNextSibling();\n            if (!nextSibling) {\n                return paragraph.createRun();\n            }\n            String uri = CTR.type.getName().getNamespaceURI();\n            String localPart = \"r\";\n            newCursor.beginElement(localPart, uri);\n            newCursor.toParent();\n            CTR r = ((CTR) (newCursor.getObject()));\n            XWPFRun newRun = new XWPFRun(r, ((IRunBody) (this.paragraph)));\n            List<IRunElement> iruns = getIRuns();\n            List<XWPFRun> runs = getRuns();\n            int iPos = iruns.size();\n            if (pos < runs.size()) {\n                XWPFRun oldAtPos = runs.get(pos);\n                int oldAt = iruns.indexOf(oldAtPos);\n                if (oldAt != (-1)) {\n                    iPos = oldAt;\n                }\n            }\n            if ((iPos + 1) >= iruns.size()) {\n                iruns.add(newRun);\n            } else {\n                iruns.add(iPos + 1, newRun);\n            }\n            // Runs itself is easy to update\n            if ((pos + 1) >= runs.size()) {\n                runs.add(newRun);\n            } else {\n                runs.add(pos + 1, newRun);\n            }\n            newCursor.dispose();\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewTbl",
    "thirdPartyMethod" : "org.apache.xmlbeans.SchemaType.getName",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewTbl" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTbl(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTTbl.type.getName().getNamespaceURI();\n        String localPart = \"tbl\";\n        cursor.beginElement(localPart, uri);\n        cursor.toParent();\n        CTTbl t = ((CTTbl) (cursor.getObject()));\n        XWPFTable newT = new XWPFTable(t, this);\n        XmlObject o = null;\n        while ((!(o instanceof CTTbl)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        if (!(o instanceof CTTbl)) {\n            tables.add(0, newT);\n        } else {\n            int pos = tables.indexOf(getTable(((CTTbl) (o)))) + 1;\n            tables.add(pos, newT);\n        }\n        int i = 0;\n        XmlCursor tableCursor = t.newCursor();\n        try {\n            cursor.toCursor(tableCursor);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newT);\n            cursor.toCursor(tableCursor);\n            cursor.toEndToken();\n            return newT;\n        } finally {\n            tableCursor.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFSection.<init>",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTSectPr.isSetPgMar",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XWPFSection.<init>" ],
    "fullMethods" : [ "public XWPFSection(CTSectPr sectPr) {\n    this.sectPr = sectPr;\n    if (sectPr.isSetPgMar()) {\n        this.pageMargin = new XWPFPageMargin(sectPr.getPgMar());\n    }\n    if (sectPr.isSetPgSz()) {\n        this.pageSize = new XWPFPageSize(sectPr.getPgSz());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.sizeOfSzArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        for (int i = rowSize - 1; i >= 0; i--) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            String text = row.getCell(actualInsertPosition).getText();\n            if (\"_delete_\".equals(text)) {\n                table.removeRow(i);\n            } else {\n                removeCell(row, actualInsertPosition);\n            }\n        }\n    } catch (Exception e) {\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.toc.TOCRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.toc.TOCRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    XWPFRun run = ((RunTemplate) (eleTemplate)).getRun();\n    run.setText(\"\", 0);\n    XWPFParagraph tocPara = ((XWPFParagraph) (run.getParent()));\n    XWPFFieldRun fieldRun = tocPara.insertNewFieldRun(0);\n    CTSimpleField toc = fieldRun.getCTField();\n    toc.setInstr(\"TOC \\\\o\");\n    toc.setDirty(XWPFOnOff.ON);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.DynamicTableRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.DynamicTableRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(RenderContext<Object> context) throws Exception {\n    RunTemplate runTemplate = ((RunTemplate) (context.getEleTemplate()));\n    XWPFRun run = runTemplate.getRun();\n    run.setText(\"\", 0);\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell cell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = cell.getTableRow().getTable();\n        render(table, context.getData());\n    } catch (Exception e) {\n        throw new RenderException(\"Dynamic render table error:\" + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.field.SimpleFieldRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.field.SimpleFieldRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(RenderContext<String> context) throws Exception {\n    RunTemplate runTemplate = ((RunTemplate) (context.getEleTemplate()));\n    XWPFRun run = context.getRun();\n    run.setText(\"\", 0);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    XWPFRun startRun = paragraphWrapper.insertNewRun(runTemplate.getRunPos());\n    StyleUtils.styleRun(startRun, run);\n    CTR ctr = startRun.getCTR();\n    CTFldChar addNewFldChar = ctr.addNewFldChar();\n    addNewFldChar.setFldCharType(STFldCharType.BEGIN);\n    XWPFRun instrRun = paragraphWrapper.insertNewRun(runTemplate.getRunPos());\n    StyleUtils.styleRun(instrRun, run);\n    ctr = instrRun.getCTR();\n    CTText addNewInstrText = ctr.addNewInstrText();\n    // \"EQ \\\\o\\\\ac(, 1)\"\n    addNewInstrText.setStringValue(context.getData());\n    XWPFRun sepRun = paragraphWrapper.insertNewRun(runTemplate.getRunPos());\n    StyleUtils.styleRun(sepRun, run);\n    ctr = sepRun.getCTR();\n    addNewFldChar = ctr.addNewFldChar();\n    addNewFldChar.setFldCharType(STFldCharType.SEPARATE);\n    XWPFRun endRun = paragraphWrapper.insertNewRun(runTemplate.getRunPos());\n    StyleUtils.styleRun(endRun, run);\n    ctr = endRun.getCTR();\n    addNewFldChar = ctr.addNewFldChar();\n    addNewFldChar.setFldCharType(STFldCharType.END);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.BodyContainer.clearPlaceholder",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.BodyContainer.clearPlaceholder" ],
    "fullMethods" : [ "/**\n * clear run\n *\n * @param run\n * @param remove\n */\ndefault void clearPlaceholder(XWPFRun run, boolean remove) {\n    IRunBody parent = run.getParent();\n    run.setText(\"\", 0);\n    if (parent instanceof XWPFParagraph) {\n        if (remove)\n            new XWPFParagraphWrapper(((XWPFParagraph) (parent))).removeRun(ParagraphUtils.getRunPos(run));\n\n        String paragraphText = ParagraphUtils.trimLine(((XWPFParagraph) (parent)));\n        boolean havePictures = ParagraphUtils.havePictures(((XWPFParagraph) (parent)));\n        boolean havePageBreak = ParagraphUtils.havePageBreak(((XWPFParagraph) (parent)));\n        boolean haveObject = ParagraphUtils.haveObject(((XWPFParagraph) (parent)));\n        if (((\"\".equals(paragraphText) && (!havePictures)) && (!havePageBreak)) && (!haveObject)) {\n            int pos = getPosOfParagraph(((XWPFParagraph) (parent)));\n            removeBodyElement(pos);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    try {\n        RunTemplate runTemplate = cast2runTemplate(eleTemplate);\n        XWPFRun run = runTemplate.getRun();\n        checkTargetIsTable(run, (\"Processing [\" + runTemplate.getTagName()) + \"] failed, the target content is not a table\");\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        final XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n        // \n        int position = getRowIndex(tagCell.getTableRow());\n        List<XWPFTableRow> tempRows = getAllTemplateRow(table, position);\n        if ((null != data) && (data instanceof Iterable)) {\n            // \n            final XWPFTableRow firstTempRow = tempRows.get(0);\n            Iterator<?> dataIt = ((Iterable<?>) (data)).iterator();\n            boolean hasNextData = dataIt.hasNext();\n            int index = 0;\n            while (hasNextData) {\n                Object dt = dataIt.next();\n                hasNextData = dataIt.hasNext();\n                Iterator<XWPFTableRow> rowTempIt = tempRows.iterator();\n                boolean hasNextTempRow = rowTempIt.hasNext();\n                while (hasNextTempRow) {\n                    XWPFTableRow tempRow = rowTempIt.next();\n                    hasNextTempRow = rowTempIt.hasNext();\n                    if (!table.addRow(tempRow, position)) {\n                        throw new RenderException(\"\");\n                    }\n                    // \n                    XmlCursor newCursor = firstTempRow.getCtRow().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    XWPFTableRow newRow = new XWPFTableRow(((CTRow) (object)), table);\n                    newRow.getCtRow().set(object);\n                    setTableRow(table, newRow, position);\n                    List<XWPFTableCell> cells = newRow.getTableCells();\n                    RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(dt, EnvIterator.makeEnv(index, hasNextData || hasNextTempRow)));\n                    cells.forEach(tableCell -> {\n                        List<MetaTemplate> metaTemplates = resolver.resolveBodyElements(tableCell.getBodyElements());\n                        new DocumentProcessor(template, resolver, dataCompute).process(metaTemplates);\n                    });\n                    ++position;\n                } \n                ++index;\n            } \n        }\n        removeTableRow(table, position, tempRows.size());\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-row template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TextRenderPolicy.Helper.renderTextRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TextRenderPolicy.Helper.renderTextRun" ],
    "fullMethods" : [ "public static void renderTextRun(XWPFRun run, TextRenderData data) {\n    XWPFRun textRun = run;\n    if (data instanceof HyperlinkTextRenderData) {\n        textRun = createHyperlink(run, ((HyperlinkTextRenderData) (data)).getUrl());\n    }\n    StyleUtils.styleRun(textRun, data.getStyle());\n    String text = Optional.ofNullable(data.getText()).orElse(\"\");\n    String[] fragment = text.split(REGEX_LINE_CHARACTOR, -1);\n    if (fragment.length > 0) {\n        textRun.setText(fragment[0], 0);\n        boolean lineAtTable = ((fragment.length > 1) && (!(data instanceof HyperlinkTextRenderData))) && TableTools.isInsideTable(run);\n        for (int i = 1; i < fragment.length; i++) {\n            if (lineAtTable) {\n                textRun.addBreak(BreakType.TEXT_WRAPPING);\n            } else {\n                textRun.addCarriageReturn();\n            }\n            textRun.setText(fragment[i]);\n        }\n    }\n    if (data instanceof BookmarkTextRenderData) {\n        createBookmark(textRun, ((BookmarkTextRenderData) (data)).getBookmark());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.AbstractRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.AbstractRenderPolicy.render", "com.deepoove.poi.policy.PictureRenderPolicy.reThrowException" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    T model = null;\n    try {\n        model = cast(data);\n    } catch (Exception e) {\n        throw new RenderException(\"Error Render Data format for template: \" + eleTemplate.getSource(), e);\n    }\n    RenderContext<T> context = new RenderContext<T>(eleTemplate, model, template);\n    try {\n        // validate\n        if (!validate(model)) {\n            postValidError(context);\n            return;\n        }\n        // do render\n        beforeRender(context);\n        doRender(context);\n        afterRender(context);\n    } catch (Exception e) {\n        reThrowException(context, e);\n    }\n}", "@Override\nprotected void reThrowException(RenderContext<PictureRenderData> context, Exception e) {\n    logger.info((\"Render picture \" + context.getEleTemplate()) + \" error: {}\", e.getMessage());\n    String alt = context.getData().getAltMeta();\n    context.getRun().setText(alt, 0);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.clearPlaceholder",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.clearPlaceholder" ],
    "fullMethods" : [ "@Override\npublic void clearPlaceholder(XWPFRun run) {\n    IRunBody parent = run.getParent();\n    run.setText(\"\", 0);\n    // <p>elements must be located before </tc> elements\n    if (parent instanceof XWPFParagraph) {\n        String paragraphText = ParagraphUtils.trimLine(((XWPFParagraph) (parent)));\n        boolean havePictures = ParagraphUtils.havePictures(((XWPFParagraph) (parent)));\n        if (\"\".equals(paragraphText) && (!havePictures)) {\n            int pos = getPosOfParagraph(((XWPFParagraph) (parent)));\n            int lastPos = cell.getBodyElements().size() - 1;\n            if (canRemoveParagraph(pos, lastPos)) {\n                removeBodyElement(pos);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        if ((null != data) && (data instanceof Iterable)) {\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            XWPFTableRow templateRow = table.getRow(templateRowIndex);\n            int insertPosition = templateRowIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            boolean firstFlag = true;\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateRowIndex++;\n                XWPFTableRow nextRow = table.insertNewTableRow(insertPosition);\n                setTableRow(table, templateRow, insertPosition);\n                // double set row\n                XmlCursor newCursor = templateRow.getCtRow().newCursor();\n                newCursor.toPrevSibling();\n                XmlObject object = newCursor.getObject();\n                nextRow = new XWPFTableRow(((CTRow) (object)), table);\n                if (!firstFlag) {\n                    // update VMerge cells for non-first row\n                    List<XWPFTableCell> tableCells = nextRow.getTableCells();\n                    for (XWPFTableCell cell : tableCells) {\n                        CTTcPr tcPr = TableTools.getTcPr(cell);\n                        CTVMerge vMerge = tcPr.getVMerge();\n                        if (null == vMerge)\n                            continue;\n\n                        if (STMerge.RESTART == vMerge.getVal()) {\n                            vMerge.setVal(STMerge.CONTINUE);\n                        }\n                    }\n                } else {\n                    firstFlag = false;\n                }\n                setTableRow(table, nextRow, insertPosition);\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                List<XWPFTableCell> cells = nextRow.getTableCells();\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        table.removeRow(templateRowIndex);\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \" error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.refactorRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.refactorRun" ],
    "fullMethods" : [ "public List<XWPFRun> refactorRun() {\n    if (pairs.isEmpty())\n        return null;\n\n    List<XWPFRun> templateRuns = new ArrayList<XWPFRun>();\n    int size = pairs.size();\n    Pair<RunEdge, RunEdge> runEdgePair;\n    for (int n = size - 1; n >= 0; n--) {\n        runEdgePair = pairs.get(n);\n        RunEdge startEdge = runEdgePair.getLeft();\n        RunEdge endEdge = runEdgePair.getRight();\n        int startRunPos = startEdge.getRunPos();\n        int endRunPos = endEdge.getRunPos();\n        int startOffset = startEdge.getRunEdge();\n        int endOffset = endEdge.getRunEdge();\n        String startText = runs.get(startRunPos).text();\n        String endText = runs.get(endRunPos).text();\n        if ((endOffset + 1) >= endText.length()) {\n            // delete the redundant end Run directly\n            if (startRunPos != endRunPos)\n                runBodyContext.removeRun(endRunPos);\n\n        } else {\n            // split end run, set extra in a run\n            String extra = endText.substring(endOffset + 1, endText.length());\n            if (startRunPos == endRunPos) {\n                // create run and set extra content\n                XWPFRun extraRun = runBodyContext.insertNewRunAfter(endRunPos);\n                StyleUtils.styleRun(extraRun, runs.get(endRunPos));\n                buildExtra(extra, extraRun);\n            } else {\n                // Set the extra content to the redundant end run\n                XWPFRun extraRun = runs.get(endRunPos);\n                buildExtra(extra, extraRun);\n            }\n        }\n        // remove extra run\n        for (int m = endRunPos - 1; m > startRunPos; m--) {\n            runBodyContext.removeRun(m);\n        }\n        if (startOffset <= 0) {\n            // set the start Run directly\n            XWPFRun templateRun = runs.get(startRunPos);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos));\n        } else {\n            // split start run, set extra in a run\n            String extra = startText.substring(0, startOffset);\n            XWPFRun extraRun = runs.get(startRunPos);\n            buildExtra(extra, extraRun);\n            XWPFRun templateRun = runBodyContext.insertNewRunAfter(startRunPos);\n            StyleUtils.styleRun(templateRun, extraRun);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos + 1));\n        }\n    }\n    return templateRuns;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        int templateColIndex = getColIndex(tagCell);\n        if ((null == data) || ((data instanceof Boolean) && (!((Boolean) (data))))) {\n            // table.removeRow(templateRowIndex);\n            // tagCell.setText(\"_delete_\");\n            run.setText(\"_delete_\", 0);\n            CTTcPr tcPr = TableTools.getTcPr(tagCell);\n            CTVMerge vMerge = tcPr.getVMerge();\n            System.out.println(null == vMerge ? null : vMerge.getVal());\n            if ((null != vMerge) && vMerge.getVal().equals(STMerge.RESTART)) {\n                XWPFTableRow row = table.getRow(templateRowIndex + 1);\n                int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n                XWPFTableCell actualCell = row.getCell(actualInsertPosition);\n                System.out.println(actualCell.getCTTc());\n                actualCell.getParagraphArray(0).createRun().setText(\"_delete_\", 0);\n            }\n        } else {\n            run.setText(\"\", 0);\n        }\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.addEmbeddData",
    "thirdPartyMethod" : "org.apache.poi.ooxml.POIXMLException.<init>",
    "thirdPartyPackage" : "org.apache.poi.ooxml",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.addEmbeddData" ],
    "fullMethods" : [ "public String addEmbeddData(byte[] embeddData, String contentType, String part) throws InvalidFormatException, IOException {\n    PackagePartName partName = PackagingURIHelper.createPartName(part);\n    PackagePart packagePart = getPackage().createPart(partName, contentType);\n    try (OutputStream out = packagePart.getOutputStream()) {\n        out.write(embeddData);\n    } catch (IOException e) {\n        throw new POIXMLException(e);\n    }\n    PackageRelationship ole = getPackagePart().addRelationship(partName, TargetMode.INTERNAL, POIXMLDocument.PACK_OBJECT_REL_TYPE);\n    return ole.getId();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.addEmbeddData",
    "thirdPartyMethod" : "org.apache.poi.ooxml.POIXMLException.<init>",
    "thirdPartyPackage" : "org.apache.poi.ooxml",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.addEmbeddData" ],
    "fullMethods" : [ "public String addEmbeddData(byte[] embeddData, int format) throws InvalidFormatException {\n    XWPFRelation relation = (0 == format) ? DOCUMENT : XWPFRelation.WORKBOOK;\n    int idx = 256 + getRelationIndex(relation);\n    POIXMLDocumentPart embeddPart = createRelationship(relation, XWPFFactory.getInstance(), idx);\n    embedds.add(embeddPart);\n    /* write bytes to new part */\n    PackagePart picDataPart = embeddPart.getPackagePart();\n    try (OutputStream out = picDataPart.getOutputStream()) {\n        out.write(embeddData);\n    } catch (IOException e) {\n        throw new POIXMLException(e);\n    }\n    return getRelationId(embeddPart);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.apache.poi.ooxml.POIXMLException.<init>",
    "thirdPartyPackage" : "org.apache.poi.ooxml",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableString", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeAttachment" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "protected String createMergeableString(NiceXWPFDocument source, NiceXWPFDocument merged, Map<String, String> styleIdsMap) throws InvalidFormatException, IOException {\n    CTBody mergedBody = merged.getDocument().getBody();\n    // TODO For the same style, reduce the number of merges\n    // Map<String, String> styleIdsMap = mergeStyles(docMerge);\n    Map<String, String> numIdsMap = mergeNumbering(source, merged);\n    Map<String, String> blipIdsMap = mergePicture(source, merged);\n    Map<String, String> externalBlipIdsMap = mergeExternalPicture(source, merged);\n    Map<String, String> hyperlinkMap = mergeHyperlink(source, merged);\n    Map<String, String> chartIdsMap = mergeChart(source, merged);\n    Map<String, String> attachmentIdsMap = mergeAttachment(source, merged);\n    Map<String, String> footnoteIdsMap = mergeFootnote(source, merged);\n    Map<String, String> endnoteIdsMap = mergeEndnote(source, merged);\n    String appendString = mergedBody.xmlText(DefaultXmlOptions.OPTIONS_OUTER);\n    String addPart = ridSectPr(appendString);\n    // style\n    for (String styleId : styleIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:pStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:pStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:tblStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:tblStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:rStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:rStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\");\n    }\n    // picture id\n    Map<String, String> placeHolderblipIdsMap = new HashMap<String, String>();\n    for (String relaId : blipIdsMap.keySet()) {\n        placeHolderblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:embed=\\\"\" + relaId) + \"\\\"\", (\"r:embed=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n        // w:pict v:shape v:imagedata\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    Map<String, String> placeHolderExternalblipIdsMap = new HashMap<String, String>();\n    for (String relaId : externalBlipIdsMap.keySet()) {\n        placeHolderExternalblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderExternalblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:link=\\\"\" + relaId) + \"\\\"\", (\"r:link=\\\"\" + placeHolderExternalblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // hyperlink id\n    for (String relaId : hyperlinkMap.keySet()) {\n        hyperlinkMap.put(relaId, hyperlinkMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : hyperlinkMap.keySet()) {\n        // w:hyperlink r:id\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + hyperlinkMap.get(relaId)) + \"\\\"\");\n    }\n    // chart id\n    for (String relaId : chartIdsMap.keySet()) {\n        chartIdsMap.put(relaId, chartIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : chartIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + chartIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // attachment id\n    for (String relaId : attachmentIdsMap.keySet()) {\n        attachmentIdsMap.put(relaId, attachmentIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : attachmentIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + attachmentIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // footnote id\n    for (String relaId : footnoteIdsMap.keySet()) {\n        footnoteIdsMap.put(relaId, footnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : footnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"footnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"footnoteReference w:id=\\\"\" + footnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // endnote id\n    for (String relaId : endnoteIdsMap.keySet()) {\n        endnoteIdsMap.put(relaId, endnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : endnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"endnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"endnoteReference w:id=\\\"\" + endnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // numbering numId\n    for (String relaId : numIdsMap.keySet()) {\n        numIdsMap.put(relaId, numIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String numId : numIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:numId\\\\sw:val=\\\"\" + numId) + \"\\\"\", (\"<w:numId w:val=\\\"\" + numIdsMap.get(numId)) + \"\\\"\");\n    }\n    return addPart.replaceAll(CROSS_REPLACE_STRING, \"\");\n}", "protected Map<String, String> mergeAttachment(NiceXWPFDocument source, NiceXWPFDocument merged) throws InvalidFormatException, IOException {\n    Map<String, String> attachmentIdsMap = new HashMap<String, String>();\n    PackageRelationshipCollection part = merged.getPackagePart().getRelationshipsByType(POIXMLDocument.PACK_OBJECT_REL_TYPE);\n    Iterator<PackageRelationship> iterator = part.iterator();\n    while (iterator.hasNext()) {\n        PackageRelationship relationship = iterator.next();\n        PackagePart embeddPart = merged.getPackagePart().getRelatedPart(relationship);\n        String path = relationship.getTargetURI().getPath();\n        if ((null == path) || ((!path.endsWith(\".docx\")) && (!path.endsWith(\".xlsx\"))))\n            continue;\n\n        try {\n            byte[] byteData = IOUtils.toByteArray(embeddPart.getInputStream());\n            String newId = source.addEmbeddData(byteData, path.endsWith(\"docx\") ? 0 : 1);\n            attachmentIdsMap.putIfAbsent(relationship.getId(), newId);\n        } catch (IOException e) {\n            throw new POIXMLException(e);\n        }\n    } \n    return attachmentIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setExplosion",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.unsetExplosion",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setExplosion" ],
    "fullMethods" : [ "public void setExplosion(Long explosion) {\n    if (explosion == null) {\n        if (series.isSetExplosion()) {\n            series.unsetExplosion();\n        }\n    } else if (series.isSetExplosion()) {\n        series.getExplosion().setVal(explosion);\n    } else {\n        series.addNewExplosion().setVal(explosion);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ChartUtils.getValueAxes",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTUnsignedInt.getVal",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.util.ChartUtils.getValueAxes" ],
    "fullMethods" : [ "public static Map<Long, XDDFValueAxis> getValueAxes(XWPFChart chart) {\n    CTPlotArea plotArea = chart.getCTChart().getPlotArea();\n    int sizeOfArray = plotArea.sizeOfValAxArray();\n    Map<Long, XDDFValueAxis> axes = new HashMap<>(sizeOfArray);\n    for (int i = 0; i < sizeOfArray; i++) {\n        CTValAx values = plotArea.getValAxArray(i);\n        axes.put(values.getAxId().getVal(), new XDDFValueAxis(values));\n    }\n    return axes;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.getExplosion",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTUnsignedInt.getVal",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.getExplosion" ],
    "fullMethods" : [ "public Long getExplosion() {\n    if (series.isSetExplosion()) {\n        return series.getExplosion().getVal();\n    } else {\n        return null;\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.createRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFTableCell\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CommentBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.createRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CommentBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFHeaderFooter\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.DocumentBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.createRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.DocumentBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.createRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFHeaderFooter\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getText",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getTextRecursively",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getText", "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.appendTable" ],
    "fullMethods" : [ "@Override\npublic String getText() {\n    StringBuilder text = new StringBuilder();\n    boolean addNewLine = false;\n    for (int i = 0; i < sdtElements.size(); i++) {\n        Object o = sdtElements.get(i);\n        if (o instanceof XWPFParagraph) {\n            appendParagraph(((XWPFParagraph) (o)), text);\n            addNewLine = true;\n        } else if (o instanceof XWPFTable) {\n            appendTable(((XWPFTable) (o)), text);\n            addNewLine = true;\n        } else if (o instanceof XWPFSDT) {\n            text.append(((XWPFSDT) (o)).getContent().getText());\n            addNewLine = true;\n        } else if (o instanceof XWPFRun) {\n            text.append(o);\n            addNewLine = false;\n        }\n        if (addNewLine && (i < (sdtElements.size() - 1))) {\n            text.append(\"\\n\");\n        }\n    }\n    return text.toString();\n}", "private void appendTable(XWPFTable table, StringBuilder text) {\n    // this works recursively to pull embedded tables from within cells\n    for (XWPFTableRow row : table.getRows()) {\n        List<ICell> cells = row.getTableICells();\n        for (int i = 0; i < cells.size(); i++) {\n            ICell cell = cells.get(i);\n            if (cell instanceof XWPFTableCell) {\n                text.append(((XWPFTableCell) (cell)).getTextRecursively());\n            } else if (cell instanceof XWPFSDTCell) {\n                text.append(((XWPFSDTCell) (cell)).getContent().getText());\n            }\n            if (i < (cells.size() - 1)) {\n                text.append(\"\\t\");\n            }\n        }\n        text.append('\\n');\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.removeParagraph",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTxbxContent.removeP",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.removeParagraph" ],
    "fullMethods" : [ "/**\n * removes a paragraph of this textbox\n *\n * @param pos\n * \t\tThe position in the list of paragraphs, 0-based\n */\npublic void removeParagraph(int pos) {\n    XWPFParagraph removedParagraph = paragraphs.get(pos);\n    paragraphs.remove(pos);\n    ctTxbxContent.removeP(pos);\n    bodyElements.remove(removedParagraph);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblBorders.isSetTop",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRow.removeTc",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render", "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.removeCell" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        for (int i = rowSize - 1; i >= 0; i--) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            String text = row.getCell(actualInsertPosition).getText();\n            if (\"_delete_\".equals(text)) {\n                table.removeRow(i);\n            } else {\n                removeCell(row, actualInsertPosition);\n            }\n        }\n    } catch (Exception e) {\n    }\n}", "@SuppressWarnings(\"unchecked\")\nprivate void removeCell(XWPFTableRow row, int actualInsertPosition) {\n    List<XWPFTableCell> cells = ((List<XWPFTableCell>) (ReflectionUtils.getValue(\"tableCells\", row)));\n    cells.remove(actualInsertPosition);\n    row.getCtRow().removeTc(actualInsertPosition);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRow.removeTc",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render", "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.removeCell" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}", "@SuppressWarnings(\"unchecked\")\nprivate void removeCell(XWPFTableRow row, int actualInsertPosition) {\n    List<XWPFTableCell> cells = ((List<XWPFTableCell>) (ReflectionUtils.getValue(\"tableCells\", row)));\n    cells.remove(actualInsertPosition);\n    row.getCtRow().removeTc(actualInsertPosition);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.mergeCellsHorizonal",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRow.removeTc",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.mergeCellsHorizonal" ],
    "fullMethods" : [ "/**\n * merge several columns of cells in the same row\n *\n * @param table\n * \t\ttable\n * @param row\n * \t\tindex of the row\n * @param fromCol\n * \t\tfrom column to be merged\n * @param toCol\n * \t\tto column to be merged\n */\npublic static void mergeCellsHorizonal(XWPFTable table, int row, int fromCol, int toCol) {\n    Preconditions.requireGreaterThan(toCol, fromCol, \"To column to be merged must greater than from column.\");\n    mergeCellsHorizontalWithoutRemove(table, row, fromCol, toCol);\n    XWPFTableRow rowTable = table.getRow(row);\n    for (int colIndex = fromCol + 1; colIndex <= toCol; colIndex++) {\n        rowTable.removeCell(fromCol + 1);\n        if (rowTable.getTableCells().size() != rowTable.getCtRow().sizeOfTcArray()) {\n            rowTable.getCtRow().removeTc(fromCol + 1);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRow.removeTc",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderTable", "com.deepoove.poi.policy.TableRenderPolicy.Helper.applyMergeRule" ],
    "fullMethods" : [ "public static XWPFTable renderTable(XWPFRun run, TableRenderData data) throws Exception {\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    XWPFTable table = bodyContainer.insertNewTable(run, data.obtainRowSize(), data.obtainColSize());\n    StyleUtils.styleTable(table, data.getTableStyle());\n    int size = table.getRows().size();\n    for (int i = 0; i < size; i++) {\n        RowRenderData rowRenderData = data.getRows().get(i);\n        renderRow(table.getRows().get(i), rowRenderData, StyleUtils.retriveStyle(run));\n    }\n    applyMergeRule(table, data.getMergeRule());\n    return table;\n}", "private static void applyMergeRule(XWPFTable table, MergeCellRule mergeRule) {\n    if (null == mergeRule)\n        return;\n\n    byte[][] markRemovedCell = new byte[TableTools.obtainRowSize(table)][TableTools.obtainColumnSize(table)];\n    Iterator<Entry<Grid, Grid>> iterator = mergeRule.mappingIterator();\n    while (iterator.hasNext()) {\n        Entry<Grid, Grid> next = iterator.next();\n        Grid key = next.getKey();\n        Grid value = next.getValue();\n        int startI = (key.getI() > value.getI()) ? value.getI() : key.getI();\n        int startJ = (key.getJ() > value.getJ()) ? value.getJ() : key.getJ();\n        int endI = (key.getI() > value.getI()) ? key.getI() : value.getI();\n        int endJ = (key.getJ() > value.getJ()) ? key.getJ() : value.getJ();\n        // merge(VMerge mark) vertical\n        if (startI != endI) {\n            for (int j = startJ; j <= endJ; j++) {\n                TableTools.mergeCellsVertically(table, j, startI, endI);\n            }\n        }\n        // merge horizontal cells without remove cells\n        if (startJ != endJ) {\n            for (int i = startI; i <= endI; i++) {\n                TableTools.mergeCellsHorizontalWithoutRemove(table, i, startJ, endJ);\n                for (int removedCol = startJ + 1; removedCol <= endJ; removedCol++) {\n                    markRemovedCell[i][removedCol] = 1;\n                }\n            }\n        }\n    } \n    // remove marked cell safely\n    for (int i = 0; i < markRemovedCell.length; i++) {\n        for (int j = markRemovedCell[i].length - 1; j >= 0; j--) {\n            if (markRemovedCell[i][j] >= 1) {\n                table.getRow(i).removeCell(j);\n                if (table.getRow(i).getTableCells().size() != table.getRow(i).getCtRow().sizeOfTcArray()) {\n                    table.getRow(i).getCtRow().removeTc(j);\n                }\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRow.removeTc",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render", "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.removeCell" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}", "@SuppressWarnings(\"unchecked\")\nprivate void removeCell(XWPFTableRow row, int actualInsertPosition) {\n    List<XWPFTableCell> cells = ((List<XWPFTableCell>) (ReflectionUtils.getValue(\"tableCells\", row)));\n    cells.remove(actualInsertPosition);\n    row.getCtRow().removeTc(actualInsertPosition);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTInd.unsetHanging",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr.isSetShd",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr.isSetShd",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyle(XWPFParagraph paragraph) {\n    if (null == paragraph)\n        return null;\n\n    Builder builder = ParagraphStyle.builder();\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    if (paragraph.isWordWrapped()) {\n        builder.withAllowWordBreak(true);\n    }\n    if (pr.isSetPBdr()) {\n        CTPBdr ct = pr.getPBdr();\n        if (ct.isSetLeft()) {\n            builder.withLeftBorder(retriveBorderStyle(ct.getLeft()));\n        }\n        if (ct.isSetTop()) {\n            builder.withTopBorder(retriveBorderStyle(ct.getTop()));\n        }\n        if (ct.isSetRight()) {\n            builder.withRightBorder(retriveBorderStyle(ct.getRight()));\n        }\n        if (ct.isSetBottom()) {\n            builder.withBottomBorder(retriveBorderStyle(ct.getBottom()));\n        }\n    }\n    if (pr.isSetShd()) {\n        CTShd shd = pr.getShd();\n        builder.withShadingPattern(XWPFShadingPattern.valueOf(shd.getVal().intValue()));\n        if (shd.isSetFill())\n            builder.withBackgroundColor(shd.xgetFill().getStringValue());\n\n    }\n    builder.withAlign(paragraph.getAlignment());\n    int spacingBeforeLines = paragraph.getSpacingBeforeLines();\n    if ((-1) != spacingBeforeLines) {\n        builder.withSpacingBeforeLines(spacingBeforeLines / 100.0F);\n    }\n    int spacingAfterLines = paragraph.getSpacingAfterLines();\n    if ((-1) != spacingAfterLines) {\n        builder.withSpacingAfterLines(spacingAfterLines / 100.0F);\n    }\n    int spacingBefore = paragraph.getSpacingBefore();\n    if ((-1) != spacingBefore) {\n        builder.withSpacingBefore(UnitUtils.twips2Point(spacingBefore));\n    }\n    int spacingAfter = paragraph.getSpacingAfter();\n    if ((-1) != spacingAfter) {\n        builder.withSpacingAfter(UnitUtils.twips2Point(spacingAfter));\n    }\n    double spacingBetween = paragraph.getSpacingBetween();\n    if ((-1) != spacingBetween) {\n        builder.withSpacing(spacingBetween);\n        builder.withSpacingRule(paragraph.getSpacingLineRule());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isBlank",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements", "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveBodyElements(List<IBodyElement> bodyElements) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (null == bodyElements)\n        return metaTemplates;\n\n    // current iterable templates state\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    for (IBodyElement element : bodyElements) {\n        if (element == null)\n            continue;\n\n        if (element.getElementType() == BodyElementType.PARAGRAPH) {\n            resolveParagraph(((XWPFParagraph) (element)), metaTemplates, stack);\n        } else if (element.getElementType() == BodyElementType.TABLE) {\n            XWPFTable table = ((XWPFTable) (element));\n            List<XWPFTableRow> rows = table.getRows();\n            if (null == rows)\n                continue;\n\n            for (XWPFTableRow row : rows) {\n                resolveTableRow(row, metaTemplates, stack);\n            }\n        } else if ((element.getElementType() == BodyElementType.CONTENTCONTROL) && (element instanceof XWPFStructuredDocumentTag)) {\n            XWPFStructuredDocumentTag sdt = ((XWPFStructuredDocumentTag) (element));\n            addNewMeta(metaTemplates, stack, resolveSDTElements(sdt.getContent()));\n        }\n    }\n    checkStack(stack);\n    return metaTemplates;\n}", "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isBlank",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveXWPFRuns(List<XWPFRun> runs) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (runs == null)\n        return metaTemplates;\n\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    resolveXWPFRuns(runs, metaTemplates, stack);\n    checkStack(stack);\n    return metaTemplates;\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isBlank",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns" ],
    "fullMethods" : [ "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewHyperLinkRun",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isBlank",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewHyperLinkRun" ],
    "fullMethods" : [ "public XWPFRun insertNewHyperLinkRun(XWPFRun run, String link) {\n    if (StringUtils.isBlank(link))\n        throw new IllegalArgumentException(\"Hyperlink must not be Empty!\");\n\n    if (link.startsWith(\"anchor:\")) {\n        return insertNewAnchor(getPosOfRun(run), link.substring(\"anchor:\".length()));\n    }\n    return insertNewHyperLinkRun(getPosOfRun(run), link);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isBlank",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeStyles" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "@SuppressWarnings(\"unchecked\")\nprotected Map<String, String> mergeStyles(NiceXWPFDocument source, NiceXWPFDocument merged) {\n    Map<String, String> styleIdsMap = new HashMap<String, String>();\n    XWPFStyles styles = source.getStyles();\n    if (null == styles)\n        styles = source.createStyles();\n\n    XWPFStyles stylesMerge = merged.getStyles();\n    if (null == stylesMerge)\n        return styleIdsMap;\n\n    try {\n        Field listStyleField = XWPFStyles.class.getDeclaredField(\"listStyle\");\n        listStyleField.setAccessible(true);\n        List<XWPFStyle> lists = ((List<XWPFStyle>) (listStyleField.get(stylesMerge)));\n        String defaultParaStyleId = null;\n        for (XWPFStyle xwpfStyle : lists) {\n            if (styles.styleExist(xwpfStyle.getStyleId())) {\n                if (!getRenameAndMergeExistsStyle()) {\n                    continue;\n                }\n                String id = xwpfStyle.getStyleId();\n                xwpfStyle.setStyleId(UUID.randomUUID().toString().substring(0, 8));\n                styleIdsMap.put(id, xwpfStyle.getStyleId());\n            }\n            // fix github issue 499\n            CTStyle ctStyle = xwpfStyle.getCTStyle();\n            if ((ctStyle.isSetDefault() && POIXMLUnits.parseOnOff(ctStyle.xgetDefault())) && (ctStyle.getType() == STStyleType.PARAGRAPH)) {\n                defaultParaStyleId = ctStyle.getStyleId();\n            }\n            if (ctStyle.isSetDefault()) {\n                ctStyle.unsetDefault();\n            }\n            if (ctStyle.isSetName() && StringUtils.isBlank(ctStyle.getName().getVal())) {\n                ctStyle.getName().setVal(ctStyle.getName().getVal() + xwpfStyle.getStyleId());\n            }\n            if (ctStyle.isSetBasedOn()) {\n                String newId = styleIdsMap.get(ctStyle.getBasedOn().getVal());\n                if (null != newId)\n                    ctStyle.getBasedOn().setVal(newId);\n\n            }\n            styles.addStyle(xwpfStyle);\n        }\n        if (null != defaultParaStyleId) {\n            final String dpid = defaultParaStyleId;\n            merged.getParagraphs().stream().filter(p -> null == p.getStyle()).forEach(p -> p.setStyle(dpid));\n        }\n    } catch (Exception e) {\n        // throw exception?\n        logger.error(\"merge style error\", e);\n    }\n    return styleIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CTDrawingWrapper.getChartId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTDrawing.sizeOfInlineArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.CTDrawingWrapper.getChartId" ],
    "fullMethods" : [ "public String getChartId() {\n    CTGraphicalObjectData graphicData = null;\n    if (ctDrawing.sizeOfAnchorArray() > 0) {\n        CTAnchor anchorArray = ctDrawing.getAnchorArray(0);\n        graphicData = anchorArray.getGraphic().getGraphicData();\n    } else if (ctDrawing.sizeOfInlineArray() > 0) {\n        CTInline inline = ctDrawing.getInlineArray(0);\n        graphicData = inline.getGraphic().getGraphicData();\n    }\n    XmlCursor newCursor = graphicData.newCursor();\n    try {\n        boolean child = newCursor.toChild(0);\n        if (!child)\n            return null;\n\n        XmlObject xmlObject = newCursor.getObject();\n        if ((null == xmlObject) || (!(xmlObject instanceof CTRelId)))\n            return null;\n\n        CTRelId cchart = ((CTRelId) (xmlObject));\n        return cchart.getId();\n    } finally {\n        newCursor.dispose();\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CTDrawingWrapper.<init>",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTDrawing.sizeOfInlineArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.CTDrawingWrapper.<init>" ],
    "fullMethods" : [ "public CTDrawingWrapper(CTDrawing ctDrawing) {\n    this.ctDrawing = ctDrawing;\n    if (ctDrawing.sizeOfAnchorArray() > 0) {\n        CTAnchor anchorArray = ctDrawing.getAnchorArray(0);\n        this.docPr = anchorArray.getDocPr();\n    } else if (ctDrawing.sizeOfInlineArray() > 0) {\n        CTInline inline = ctDrawing.getInlineArray(0);\n        this.docPr = inline.getDocPr();\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.isWordWrapped",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyle(XWPFParagraph paragraph) {\n    if (null == paragraph)\n        return null;\n\n    Builder builder = ParagraphStyle.builder();\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    if (paragraph.isWordWrapped()) {\n        builder.withAllowWordBreak(true);\n    }\n    if (pr.isSetPBdr()) {\n        CTPBdr ct = pr.getPBdr();\n        if (ct.isSetLeft()) {\n            builder.withLeftBorder(retriveBorderStyle(ct.getLeft()));\n        }\n        if (ct.isSetTop()) {\n            builder.withTopBorder(retriveBorderStyle(ct.getTop()));\n        }\n        if (ct.isSetRight()) {\n            builder.withRightBorder(retriveBorderStyle(ct.getRight()));\n        }\n        if (ct.isSetBottom()) {\n            builder.withBottomBorder(retriveBorderStyle(ct.getBottom()));\n        }\n    }\n    if (pr.isSetShd()) {\n        CTShd shd = pr.getShd();\n        builder.withShadingPattern(XWPFShadingPattern.valueOf(shd.getVal().intValue()));\n        if (shd.isSetFill())\n            builder.withBackgroundColor(shd.xgetFill().getStringValue());\n\n    }\n    builder.withAlign(paragraph.getAlignment());\n    int spacingBeforeLines = paragraph.getSpacingBeforeLines();\n    if ((-1) != spacingBeforeLines) {\n        builder.withSpacingBeforeLines(spacingBeforeLines / 100.0F);\n    }\n    int spacingAfterLines = paragraph.getSpacingAfterLines();\n    if ((-1) != spacingAfterLines) {\n        builder.withSpacingAfterLines(spacingAfterLines / 100.0F);\n    }\n    int spacingBefore = paragraph.getSpacingBefore();\n    if ((-1) != spacingBefore) {\n        builder.withSpacingBefore(UnitUtils.twips2Point(spacingBefore));\n    }\n    int spacingAfter = paragraph.getSpacingAfter();\n    if ((-1) != spacingAfter) {\n        builder.withSpacingAfter(UnitUtils.twips2Point(spacingAfter));\n    }\n    double spacingBetween = paragraph.getSpacingBetween();\n    if ((-1) != spacingBetween) {\n        builder.withSpacing(spacingBetween);\n        builder.withSpacingRule(paragraph.getSpacingLineRule());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableCell",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTcPr.isSetShd",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableCell" ],
    "fullMethods" : [ "/**\n * set cell style\n *\n * @param cell\n * @param cellStyle\n */\npublic static void styleTableCell(XWPFTableCell cell, CellStyle cellStyle) {\n    if ((null == cell) || (null == cellStyle))\n        return;\n\n    if (null != cellStyle.getVertAlign()) {\n        cell.setVerticalAlignment(cellStyle.getVertAlign());\n    }\n    if (null != cellStyle.getBackgroundColor()) {\n        CTTc ctTc = cell.getCTTc();\n        CTTcPr pr = (ctTc.isSetTcPr()) ? ctTc.getTcPr() : ctTc.addNewTcPr();\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = cellStyle.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(cellStyle.getBackgroundColor());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPrBase.addNewInd",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId" ],
    "fullMethods" : [ "public BigInteger addNewMultiLevelNumberingId(NumberingFormat... numFmts) {\n    XWPFNumbering numbering = this.getNumbering();\n    if (null == numbering) {\n        numbering = this.createNumbering();\n    }\n    XWPFNumberingWrapper numberingWrapper = new XWPFNumberingWrapper(numbering);\n    CTAbstractNum cTAbstractNum = CTAbstractNum.Factory.newInstance();\n    // if we have an existing document, we must determine the next\n    // free number first.\n    cTAbstractNum.setAbstractNumId(numberingWrapper.getNextAbstractNumID());\n    // CTMultiLevelType addNewMultiLevelType = cTAbstractNum.addNewMultiLevelType();\n    // addNewMultiLevelType.setVal(STMultiLevelType.HYBRID_MULTILEVEL);\n    for (int i = 0; i < numFmts.length; i++) {\n        NumberingFormat numFmt = numFmts[i];\n        CTLvl cTLvl = cTAbstractNum.addNewLvl();\n        CTPPrBase ppr = (cTLvl.isSetPPr()) ? cTLvl.getPPr() : cTLvl.addNewPPr();\n        CTInd ind = (ppr.isSetInd()) ? ppr.getInd() : ppr.addNewInd();\n        ind.setLeft(BigInteger.valueOf(UnitUtils.cm2Twips(0.74F) * i));\n        Enum fmt = STNumberFormat.Enum.forInt(numFmt.getNumFmt());\n        String val = numFmt.getLvlText();\n        cTLvl.addNewNumFmt().setVal(fmt);\n        cTLvl.addNewLvlText().setVal(val);\n        cTLvl.addNewStart().setVal(BigInteger.valueOf(1));\n        cTLvl.setIlvl(BigInteger.valueOf(i));\n        if (fmt == STNumberFormat.BULLET) {\n            cTLvl.addNewLvlJc().setVal(STJc.LEFT);\n            CTRPr addNewRPr = cTLvl.addNewRPr();\n            CTFonts ctFonts = addNewRPr.addNewRFonts();\n            ctFonts.setAscii(\"Wingdings\");\n            ctFonts.setHAnsi(\"Wingdings\");\n            ctFonts.setHint(STHint.DEFAULT);\n        }\n    }\n    XWPFAbstractNum abstractNum = new XWPFAbstractNum(cTAbstractNum);\n    BigInteger abstractNumID = numbering.addAbstractNum(abstractNum);\n    return numbering.addNum(abstractNumID);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.setVaryColors",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTOfPieChart.getVaryColors",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.setVaryColors" ],
    "fullMethods" : [ "@Override\npublic void setVaryColors(Boolean varyColors) {\n    if (varyColors == null) {\n        if (chart.isSetVaryColors()) {\n            chart.unsetVaryColors();\n        }\n    } else if (chart.isSetVaryColors()) {\n        chart.getVaryColors().setVal(varyColors);\n    } else {\n        chart.addNewVaryColors().setVal(varyColors);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr.getKeepLines",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.EnhancedXWPFChart.setExternalId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTChartSpace.addNewExternalData",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.EnhancedXWPFChart.setExternalId" ],
    "fullMethods" : [ "@Override\npublic void setExternalId(String id) {\n    CTChartSpace ctChartSpace = getCTChartSpace();\n    CTExternalData externalData = (ctChartSpace.isSetExternalData()) ? ctChartSpace.getExternalData() : ctChartSpace.addNewExternalData();\n    externalData.setId(id);\n    if (!externalData.isSetAutoUpdate()) {\n        externalData.addNewAutoUpdate().setVal(true);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableRow",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTrPr.addNewCantSplit",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableRow" ],
    "fullMethods" : [ "/**\n * set row style\n *\n * @param row\n * @param rowStyle\n */\npublic static void styleTableRow(XWPFTableRow row, RowStyle rowStyle) {\n    if ((null == row) || (null == rowStyle))\n        return;\n\n    int height = rowStyle.getHeight();\n    CTRow ctRow = row.getCtRow();\n    CTTrPr properties = (ctRow.isSetTrPr()) ? ctRow.getTrPr() : ctRow.addNewTrPr();\n    if (0 != height) {\n        row.setHeight(height);\n        CTHeight h = (properties.sizeOfTrHeightArray() == 0) ? properties.addNewTrHeight() : properties.getTrHeightArray(0);\n        String heightRule = rowStyle.getHeightRule();\n        if (\"exact\".equals(heightRule))\n            h.setHRule(STHeightRule.EXACT);\n        else if (\"atleast\".equals(heightRule))\n            h.setHRule(STHeightRule.AT_LEAST);\n        else\n            h.setHRule(STHeightRule.AUTO);\n\n    }\n    boolean repeated = rowStyle.isRepeated();\n    if (repeated) {\n        CTOnOff tblHeader = (properties.sizeOfTblHeaderArray() == 0) ? properties.addNewTblHeader() : properties.getTblHeaderArray(0);\n        tblHeader.setVal(XWPFOnOff.ON);\n    }\n    boolean breakAcrossPage = rowStyle.isBreakAcrossPage();\n    if (!breakAcrossPage) {\n        if (properties.sizeOfCantSplitArray() == 0) {\n            properties.addNewCantSplit();\n        } else {\n            properties.getCantSplitArray(0).setVal(XWPFOnOff.ON);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        for (int i = rowSize - 1; i >= 0; i--) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            String text = row.getCell(actualInsertPosition).getText();\n            if (\"_delete_\".equals(text)) {\n                table.removeRow(i);\n            } else {\n                removeCell(row, actualInsertPosition);\n            }\n        }\n    } catch (Exception e) {\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CommentBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CommentBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFHeaderFooter\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderTable", "com.deepoove.poi.policy.TableRenderPolicy.Helper.applyMergeRule" ],
    "fullMethods" : [ "public static XWPFTable renderTable(XWPFRun run, TableRenderData data) throws Exception {\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    XWPFTable table = bodyContainer.insertNewTable(run, data.obtainRowSize(), data.obtainColSize());\n    StyleUtils.styleTable(table, data.getTableStyle());\n    int size = table.getRows().size();\n    for (int i = 0; i < size; i++) {\n        RowRenderData rowRenderData = data.getRows().get(i);\n        renderRow(table.getRows().get(i), rowRenderData, StyleUtils.retriveStyle(run));\n    }\n    applyMergeRule(table, data.getMergeRule());\n    return table;\n}", "private static void applyMergeRule(XWPFTable table, MergeCellRule mergeRule) {\n    if (null == mergeRule)\n        return;\n\n    byte[][] markRemovedCell = new byte[TableTools.obtainRowSize(table)][TableTools.obtainColumnSize(table)];\n    Iterator<Entry<Grid, Grid>> iterator = mergeRule.mappingIterator();\n    while (iterator.hasNext()) {\n        Entry<Grid, Grid> next = iterator.next();\n        Grid key = next.getKey();\n        Grid value = next.getValue();\n        int startI = (key.getI() > value.getI()) ? value.getI() : key.getI();\n        int startJ = (key.getJ() > value.getJ()) ? value.getJ() : key.getJ();\n        int endI = (key.getI() > value.getI()) ? key.getI() : value.getI();\n        int endJ = (key.getJ() > value.getJ()) ? key.getJ() : value.getJ();\n        // merge(VMerge mark) vertical\n        if (startI != endI) {\n            for (int j = startJ; j <= endJ; j++) {\n                TableTools.mergeCellsVertically(table, j, startI, endI);\n            }\n        }\n        // merge horizontal cells without remove cells\n        if (startJ != endJ) {\n            for (int i = startI; i <= endI; i++) {\n                TableTools.mergeCellsHorizontalWithoutRemove(table, i, startJ, endJ);\n                for (int removedCol = startJ + 1; removedCol <= endJ; removedCol++) {\n                    markRemovedCell[i][removedCol] = 1;\n                }\n            }\n        }\n    } \n    // remove marked cell safely\n    for (int i = 0; i < markRemovedCell.length; i++) {\n        for (int j = markRemovedCell[i].length - 1; j >= 0; j--) {\n            if (markRemovedCell[i][j] >= 1) {\n                table.getRow(i).removeCell(j);\n                if (table.getRow(i).getTableCells().size() != table.getRow(i).getCtRow().sizeOfTcArray()) {\n                    table.getRow(i).getCtRow().removeTc(j);\n                }\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFHeaderFooter\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.mergeCellsVertically",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.mergeCellsVertically" ],
    "fullMethods" : [ "/**\n * merge several rows of cells in the same column\n *\n * @param table\n * \t\ttable\n * @param col\n * \t\tindex of the column\n * @param fromRow\n * \t\tfrom row to be merged\n * @param toRow\n * \t\tend row to be merged\n */\npublic static void mergeCellsVertically(XWPFTable table, int col, int fromRow, int toRow) {\n    Preconditions.requireGreaterThan(toRow, fromRow, \"To row to be merged must greater than from row.\");\n    for (int rowIndex = fromRow; rowIndex <= toRow; rowIndex++) {\n        XWPFTableCell cell = table.getRow(rowIndex).getCell(col);\n        CTTcPr tcPr = getTcPr(cell);\n        CTVMerge vMerge = tcPr.addNewVMerge();\n        if (rowIndex == fromRow) {\n            // The first merged cell is set with RESTART merge value\n            vMerge.setVal(STMerge.RESTART);\n        } else {\n            // Cells which join (merge) the first one, are set with CONTINUE\n            vMerge.setVal(STMerge.CONTINUE);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFTableCell\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.DocumentBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.DocumentBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.mergeCellsHorizontalWithoutRemove",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.mergeCellsHorizontalWithoutRemove" ],
    "fullMethods" : [ "/**\n * merge several columns of cells in the same row, but do'not remove extra cells\n *\n * @param table\n * \t\ttable\n * @param row\n * \t\tindex of the row\n * @param fromCol\n * \t\tfrom column to be merged\n * @param toCol\n * \t\tto column to be merged\n */\npublic static void mergeCellsHorizontalWithoutRemove(XWPFTable table, int row, int fromCol, int toCol) {\n    Preconditions.requireGreaterThan(toCol, fromCol, \"To column to be merged must greater than from column.\");\n    XWPFTableCell cell = table.getRow(row).getCell(fromCol);\n    CTTcPr tcPr = getTcPr(cell);\n    tcPr.addNewGridSpan();\n    tcPr.getGridSpan().setVal(BigInteger.valueOf(((long) ((toCol - fromCol) + 1))));\n    int tcw = 0;\n    for (int colIndex = fromCol; colIndex <= toCol; colIndex++) {\n        XWPFTableCell tableCell = table.getRow(row).getCell(colIndex);\n        // TODO pct, auto\n        if (TableWidthType.DXA == tableCell.getWidthType()) {\n            if ((-1) == tableCell.getWidth())\n                return;\n\n            tcw += tableCell.getWidth();\n        } else {\n            return;\n        }\n    }\n    if (0 != tcw)\n        cell.setWidth(tcw + \"\");\n\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.mergeCellsHorizonal",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.mergeCellsHorizonal" ],
    "fullMethods" : [ "/**\n * merge several columns of cells in the same row\n *\n * @param table\n * \t\ttable\n * @param row\n * \t\tindex of the row\n * @param fromCol\n * \t\tfrom column to be merged\n * @param toCol\n * \t\tto column to be merged\n */\npublic static void mergeCellsHorizonal(XWPFTable table, int row, int fromCol, int toCol) {\n    Preconditions.requireGreaterThan(toCol, fromCol, \"To column to be merged must greater than from column.\");\n    mergeCellsHorizontalWithoutRemove(table, row, fromCol, toCol);\n    XWPFTableRow rowTable = table.getRow(row);\n    for (int colIndex = fromCol + 1; colIndex <= toCol; colIndex++) {\n        rowTable.removeCell(fromCol + 1);\n        if (rowTable.getTableCells().size() != rowTable.getCtRow().sizeOfTcArray()) {\n            rowTable.getCtRow().removeTc(fromCol + 1);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        if ((null != data) && (data instanceof Iterable)) {\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            XWPFTableRow templateRow = table.getRow(templateRowIndex);\n            int insertPosition = templateRowIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            boolean firstFlag = true;\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateRowIndex++;\n                XWPFTableRow nextRow = table.insertNewTableRow(insertPosition);\n                setTableRow(table, templateRow, insertPosition);\n                // double set row\n                XmlCursor newCursor = templateRow.getCtRow().newCursor();\n                newCursor.toPrevSibling();\n                XmlObject object = newCursor.getObject();\n                nextRow = new XWPFTableRow(((CTRow) (object)), table);\n                if (!firstFlag) {\n                    // update VMerge cells for non-first row\n                    List<XWPFTableCell> tableCells = nextRow.getTableCells();\n                    for (XWPFTableCell cell : tableCells) {\n                        CTTcPr tcPr = TableTools.getTcPr(cell);\n                        CTVMerge vMerge = tcPr.getVMerge();\n                        if (null == vMerge)\n                            continue;\n\n                        if (STMerge.RESTART == vMerge.getVal()) {\n                            vMerge.setVal(STMerge.CONTINUE);\n                        }\n                    }\n                } else {\n                    firstFlag = false;\n                }\n                setTableRow(table, nextRow, insertPosition);\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                List<XWPFTableCell> cells = nextRow.getTableCells();\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        table.removeRow(templateRowIndex);\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \" error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        int templateColIndex = getColIndex(tagCell);\n        if ((null == data) || ((data instanceof Boolean) && (!((Boolean) (data))))) {\n            // table.removeRow(templateRowIndex);\n            // tagCell.setText(\"_delete_\");\n            run.setText(\"_delete_\", 0);\n            CTTcPr tcPr = TableTools.getTcPr(tagCell);\n            CTVMerge vMerge = tcPr.getVMerge();\n            System.out.println(null == vMerge ? null : vMerge.getVal());\n            if ((null != vMerge) && vMerge.getVal().equals(STMerge.RESTART)) {\n                XWPFTableRow row = table.getRow(templateRowIndex + 1);\n                int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n                XWPFTableCell actualCell = row.getCell(actualInsertPosition);\n                System.out.println(actualCell.getCTTc());\n                actualCell.getParagraphArray(0).createRun().setText(\"_delete_\", 0);\n            }\n        } else {\n            run.setText(\"\", 0);\n        }\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>",
    "thirdPartyMethod" : "org.apache.poi.xddf.usermodel.chart.XDDFChartData.<init>",
    "thirdPartyPackage" : "org.apache.poi.xddf.usermodel.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>" ],
    "fullMethods" : [ "public XDDFOfPieChartData(XDDFChart parent, CTOfPieChart chart) {\n    super(parent);\n    this.chart = chart;\n    this.seriesNum = parent.getChartSeries().size();\n    for (CTPieSer series : chart.getSerList()) {\n        this.series.add(new Series(series, series.getCat(), series.getVal()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.spreadsheetml.x2006.main.CTTable.addNewTableColumns",
    "thirdPartyPackage" : "org.openxmlformats.schemas.spreadsheetml.x2006.main",
    "path" : [ "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.updateCTTable", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.getSheetTable" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartMultiSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    List<XDDFChartData> chartSeries = chart.getChartSeries();\n    validate(chartSeries, data);\n    int totalSeriesCount = ensureSeriesCount(chart, chartSeries);\n    int valueCol = 1;\n    List<SeriesRenderData> usedSeriesDatas = new ArrayList<>();\n    for (XDDFChartData chartData : chartSeries) {\n        int orignSize = chartData.getSeriesCount();\n        List<SeriesRenderData> currentSeriesData = null;\n        if (chartSeries.size() <= 1) {\n            // ignore combo type\n            currentSeriesData = data.getSeriesDatas();\n        } else {\n            currentSeriesData = obtainSeriesData(chartData.getClass(), data.getSeriesDatas());\n        }\n        usedSeriesDatas.addAll(currentSeriesData);\n        int currentSeriesSize = currentSeriesData.size();\n        XDDFDataSource<?> categoriesData = null;\n        if (chartData instanceof XDDFScatterChartData) {\n            categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n        } else {\n            categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n        }\n        for (int i = 0; i < currentSeriesSize; i++) {\n            XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, currentSeriesData.get(i).getValues(), valueCol);\n            XDDFChartData.Series currentSeries = null;\n            if (i < orignSize) {\n                currentSeries = chartData.getSeries(i);\n                valuesData.setFormatCode(currentSeries.getValuesData().getFormatCode());\n                currentSeries.replaceData(categoriesData, valuesData);\n            } else {\n                // add series, should copy series with style\n                currentSeries = chartData.addSeries(categoriesData, valuesData);\n                processNewSeries(chartData, currentSeries);\n            }\n            String name = currentSeriesData.get(i).getName();\n            currentSeries.setTitle(name, chart.setSheetTitle(name, valueCol));\n            valueCol++;\n        }\n        // clear extra series\n        removeExtraSeries(chartData, orignSize, currentSeriesSize);\n    }\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    updateCTTable(sheet, usedSeriesDatas);\n    removeExtraSheetCell(sheet, data.getCategories().length, totalSeriesCount, usedSeriesDatas.size());\n    for (XDDFChartData chartData : chartSeries) {\n        plot(chart, chartData);\n    }\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "protected void updateCTTable(XSSFSheet sheet, List<SeriesRenderData> seriesDatas) {\n    final int seriesSize = seriesDatas.size();\n    final int numOfPoints = seriesDatas.get(0).getValues().length;\n    CTTable ctTable = getSheetTable(sheet);\n    String prefix = (seriesSize >= 26) ? String.valueOf(((char) ('A' + ((seriesSize / 26) - 1)))) : \"\";\n    char c = ((char) ('A' + (seriesSize % 26)));\n    String ref = ((\"A1:\" + prefix) + c) + (numOfPoints + 1);\n    ctTable.setRef(ref);\n    CTTableColumns tableColumns = ctTable.getTableColumns();\n    tableColumns.setCount(seriesSize + 1);\n    int size = tableColumns.sizeOfTableColumnArray();\n    for (int i = size - 1; i >= 0; i--) {\n        tableColumns.removeTableColumn(i);\n    }\n    CTTableColumn column = tableColumns.addNewTableColumn();\n    // category\n    column.setId(1);\n    column.setName(sheet.getRow(0).getCell(0).getStringCellValue());\n    // series\n    for (int i = 0; i < seriesSize; i++) {\n        column = tableColumns.addNewTableColumn();\n        column.setId((1 + i) + 1);\n        column.setName(seriesDatas.get(i).getName());\n    }\n}", "protected CTTable getSheetTable(XSSFSheet sheet) {\n    if (sheet.getTables().size() == 0) {\n        XSSFTable newTable = sheet.createTable(null);\n        newTable.getCTTable().addNewTableColumns();\n        sheet.getTables().add(newTable);\n    }\n    return sheet.getTables().get(0).getCTTable();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.spreadsheetml.x2006.main.CTTable.addNewTableColumns",
    "thirdPartyPackage" : "org.openxmlformats.schemas.spreadsheetml.x2006.main",
    "path" : [ "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.updateCTTable", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.getSheetTable" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartSingleSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    XDDFChartData pie = ChartUtils.getChartSeries(chart).get(0);\n    SeriesRenderData seriesDatas = data.getSeriesData();\n    XDDFDataSource<?> categoriesData = null;\n    if (pie instanceof XDDFScatterChartData) {\n        categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n    } else {\n        categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n    }\n    XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, seriesDatas.getValues(), 1);\n    XDDFChartData.Series currentSeries = pie.getSeries(0);\n    currentSeries.replaceData(categoriesData, valuesData);\n    currentSeries.setTitle(seriesDatas.getName(), chart.setSheetTitle(seriesDatas.getName(), 1));\n    updateCTTable(chart.getWorkbook().getSheetAt(0), Arrays.asList(seriesDatas));\n    plot(chart, pie);\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "protected void updateCTTable(XSSFSheet sheet, List<SeriesRenderData> seriesDatas) {\n    final int seriesSize = seriesDatas.size();\n    final int numOfPoints = seriesDatas.get(0).getValues().length;\n    CTTable ctTable = getSheetTable(sheet);\n    String prefix = (seriesSize >= 26) ? String.valueOf(((char) ('A' + ((seriesSize / 26) - 1)))) : \"\";\n    char c = ((char) ('A' + (seriesSize % 26)));\n    String ref = ((\"A1:\" + prefix) + c) + (numOfPoints + 1);\n    ctTable.setRef(ref);\n    CTTableColumns tableColumns = ctTable.getTableColumns();\n    tableColumns.setCount(seriesSize + 1);\n    int size = tableColumns.sizeOfTableColumnArray();\n    for (int i = size - 1; i >= 0; i--) {\n        tableColumns.removeTableColumn(i);\n    }\n    CTTableColumn column = tableColumns.addNewTableColumn();\n    // category\n    column.setId(1);\n    column.setName(sheet.getRow(0).getCell(0).getStringCellValue());\n    // series\n    for (int i = 0; i < seriesSize; i++) {\n        column = tableColumns.addNewTableColumn();\n        column.setId((1 + i) + 1);\n        column.setName(seriesDatas.get(i).getName());\n    }\n}", "protected CTTable getSheetTable(XSSFSheet sheet) {\n    if (sheet.getTables().size() == 0) {\n        XSSFTable newTable = sheet.createTable(null);\n        newTable.getCTTable().addNewTableColumns();\n        sheet.getTables().add(newTable);\n    }\n    return sheet.getTables().get(0).getCTTable();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTMarkup.setId",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment" ],
    "fullMethods" : [ "public static void renderComment(XWPFRun run, CommentRenderData data) throws Exception {\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper parentContext = new XWPFParagraphWrapper(paragraph);\n    BigInteger cId = BigInteger.ZERO;\n    CommentContent commentContent = data.getCommentContent();\n    if (null != commentContent) {\n        XWPFComments comments = ((NiceXWPFDocument) (paragraph.getDocument())).createComments();\n        XWPFComment newComment = comments.createComment(NextIDUtils.getCommentMaxId(comments).add(BigInteger.ONE));\n        newComment.setAuthor(commentContent.getAuthor());\n        newComment.setDate(commentContent.getDate());\n        newComment.setInitials(commentContent.getInitials());\n        renderDocument(newComment.createParagraph().createRun(), commentContent.getContent());\n        cId = newComment.getCtComment().getId();\n        parentContext.insertNewCommentRangeStart(run, cId);\n    }\n    renderParagraph(run, Paragraphs.of().addList(data.getContents()).create());\n    if (null != commentContent) {\n        parentContext.insertNewCommentRangeEnd(run, cId);\n        XWPFRun newRun = parentContext.insertNewRun(ParagraphUtils.getRunPos(run));\n        newRun.getCTR().addNewCommentReference().setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.EnhancedXWPFChart.setExternalId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTExternalData.isSetAutoUpdate",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.EnhancedXWPFChart.setExternalId" ],
    "fullMethods" : [ "@Override\npublic void setExternalId(String id) {\n    CTChartSpace ctChartSpace = getCTChartSpace();\n    CTExternalData externalData = (ctChartSpace.isSetExternalData()) ? ctChartSpace.getExternalData() : ctChartSpace.addNewExternalData();\n    externalData.setId(id);\n    if (!externalData.isSetAutoUpdate()) {\n        externalData.addNewAutoUpdate().setVal(true);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTAxDataSource.unsetNumRef",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.plot" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartMultiSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    List<XDDFChartData> chartSeries = chart.getChartSeries();\n    validate(chartSeries, data);\n    int totalSeriesCount = ensureSeriesCount(chart, chartSeries);\n    int valueCol = 1;\n    List<SeriesRenderData> usedSeriesDatas = new ArrayList<>();\n    for (XDDFChartData chartData : chartSeries) {\n        int orignSize = chartData.getSeriesCount();\n        List<SeriesRenderData> currentSeriesData = null;\n        if (chartSeries.size() <= 1) {\n            // ignore combo type\n            currentSeriesData = data.getSeriesDatas();\n        } else {\n            currentSeriesData = obtainSeriesData(chartData.getClass(), data.getSeriesDatas());\n        }\n        usedSeriesDatas.addAll(currentSeriesData);\n        int currentSeriesSize = currentSeriesData.size();\n        XDDFDataSource<?> categoriesData = null;\n        if (chartData instanceof XDDFScatterChartData) {\n            categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n        } else {\n            categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n        }\n        for (int i = 0; i < currentSeriesSize; i++) {\n            XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, currentSeriesData.get(i).getValues(), valueCol);\n            XDDFChartData.Series currentSeries = null;\n            if (i < orignSize) {\n                currentSeries = chartData.getSeries(i);\n                valuesData.setFormatCode(currentSeries.getValuesData().getFormatCode());\n                currentSeries.replaceData(categoriesData, valuesData);\n            } else {\n                // add series, should copy series with style\n                currentSeries = chartData.addSeries(categoriesData, valuesData);\n                processNewSeries(chartData, currentSeries);\n            }\n            String name = currentSeriesData.get(i).getName();\n            currentSeries.setTitle(name, chart.setSheetTitle(name, valueCol));\n            valueCol++;\n        }\n        // clear extra series\n        removeExtraSeries(chartData, orignSize, currentSeriesSize);\n    }\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    updateCTTable(sheet, usedSeriesDatas);\n    removeExtraSheetCell(sheet, data.getCategories().length, totalSeriesCount, usedSeriesDatas.size());\n    for (XDDFChartData chartData : chartSeries) {\n        plot(chart, chartData);\n    }\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "@SuppressWarnings(\"deprecation\")\nprotected void plot(XWPFChart chart, XDDFChartData data) throws Exception {\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    Method method = XDDFChart.class.getDeclaredMethod(\"fillSheet\", XSSFSheet.class, XDDFDataSource.class, XDDFNumericalDataSource.class);\n    method.setAccessible(true);\n    for (XDDFChartData.Series series : data.getSeries()) {\n        boolean numeric = series.getCategoryData().isNumeric();\n        if (!numeric) {\n            Method getAxDSMethod = series.getClass().getDeclaredMethod(\"getAxDS\");\n            getAxDSMethod.setAccessible(true);\n            CTAxDataSource axDataSource = ((CTAxDataSource) (getAxDSMethod.invoke(series)));\n            if (axDataSource.isSetNumRef()) {\n                axDataSource.unsetNumRef();\n            }\n            if (axDataSource.isSetNumLit()) {\n                axDataSource.unsetNumLit();\n            }\n        }\n        series.plot();\n        method.invoke(chart, sheet, series.getCategoryData(), series.getValuesData());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTAxDataSource.unsetNumRef",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.plot" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartSingleSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    XDDFChartData pie = ChartUtils.getChartSeries(chart).get(0);\n    SeriesRenderData seriesDatas = data.getSeriesData();\n    XDDFDataSource<?> categoriesData = null;\n    if (pie instanceof XDDFScatterChartData) {\n        categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n    } else {\n        categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n    }\n    XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, seriesDatas.getValues(), 1);\n    XDDFChartData.Series currentSeries = pie.getSeries(0);\n    currentSeries.replaceData(categoriesData, valuesData);\n    currentSeries.setTitle(seriesDatas.getName(), chart.setSheetTitle(seriesDatas.getName(), 1));\n    updateCTTable(chart.getWorkbook().getSheetAt(0), Arrays.asList(seriesDatas));\n    plot(chart, pie);\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "@SuppressWarnings(\"deprecation\")\nprotected void plot(XWPFChart chart, XDDFChartData data) throws Exception {\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    Method method = XDDFChart.class.getDeclaredMethod(\"fillSheet\", XSSFSheet.class, XDDFDataSource.class, XDDFNumericalDataSource.class);\n    method.setAccessible(true);\n    for (XDDFChartData.Series series : data.getSeries()) {\n        boolean numeric = series.getCategoryData().isNumeric();\n        if (!numeric) {\n            Method getAxDSMethod = series.getClass().getDeclaredMethod(\"getAxDS\");\n            getAxDSMethod.setAccessible(true);\n            CTAxDataSource axDataSource = ((CTAxDataSource) (getAxDSMethod.invoke(series)));\n            if (axDataSource.isSetNumRef()) {\n                axDataSource.unsetNumRef();\n            }\n            if (axDataSource.isSetNumLit()) {\n                axDataSource.unsetNumLit();\n            }\n        }\n        series.plot();\n        method.invoke(chart, sheet, series.getCategoryData(), series.getValuesData());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.addNewSz",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.addCarriageReturn",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.<init>", "com.deepoove.poi.resolver.RunningRunBody.refactorBody" ],
    "fullMethods" : [ "public RunningRunBody(RunBodyContext context, Pattern pattern) {\n    this.runBodyContext = context;\n    this.runs = context.getRuns();\n    if ((null == runs) || runs.isEmpty())\n        return;\n\n    Matcher matcher = pattern.matcher(getText(context));\n    if (matcher.find()) {\n        refactorBody();\n    }\n    buildRunEdge(pattern);\n}", "private void refactorBody() {\n    for (int i = runs.size() - 1; i >= 0; i--) {\n        XWPFRun xwpfRun = runs.get(i);\n        CTR ctr = xwpfRun.getCTR();\n        CTRImpl ctrimpl = ((CTRImpl) (ctr));\n        int sizeOfBrArray = ctr.sizeOfBrArray();\n        int sizeOfCrArray = ctr.sizeOfCrArray();\n        int sizeOfTabArray = ctr.sizeOfTabArray();\n        if (((sizeOfBrArray + sizeOfCrArray) + sizeOfTabArray) > 0) {\n            synchronized(ctrimpl.monitor()) {\n                // ctrimpl.check_orphaned();\n                List<? extends XmlObject> localArrayList = new ArrayList<XmlObject>();\n                ctrimpl.get_store().find_all_element_users(qname, localArrayList);\n                int size = localArrayList.size();\n                for (int j = size - 1; j >= 0; j--) {\n                    Object obj = localArrayList.get(j);\n                    if (obj instanceof CTEmpty) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        String tagName = ((CTEmpty) (obj)).getDomNode().getNodeName();\n                        if (\"w:br\".equals(tagName) || \"br\".equals(tagName)) {\n                            insertNewRun.addBreak();\n                        }\n                        if (\"w:cr\".equals(tagName) || \"cr\".equals(tagName)) {\n                            insertNewRun.addCarriageReturn();\n                        }\n                        if (\"w:tab\".equals(tagName) || \"tab\".equals(tagName)) {\n                            insertNewRun.addTab();\n                        }\n                    } else if (obj instanceof CTBr) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        CTBr addNewBr = insertNewRun.getCTR().addNewBr();\n                        if (null != ((CTBr) (obj)).getType())\n                            addNewBr.setType(((CTBr) (obj)).getType());\n\n                        if (null != ((CTBr) (obj)).getClear())\n                            addNewBr.setClear(((CTBr) (obj)).getClear());\n\n                    } else if (obj instanceof CTText) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        StyleUtils.styleRun(insertNewRun, xwpfRun);\n                        insertNewRun.setText(((CTText) (obj)).getStringValue());\n                    }\n                }\n                runBodyContext.removeRun(i);\n            }\n        }\n    }\n    this.runs = runBodyContext.getRuns();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TextRenderPolicy.Helper.renderTextRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.addCarriageReturn",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TextRenderPolicy.Helper.renderTextRun" ],
    "fullMethods" : [ "public static void renderTextRun(XWPFRun run, TextRenderData data) {\n    XWPFRun textRun = run;\n    if (data instanceof HyperlinkTextRenderData) {\n        textRun = createHyperlink(run, ((HyperlinkTextRenderData) (data)).getUrl());\n    }\n    StyleUtils.styleRun(textRun, data.getStyle());\n    String text = Optional.ofNullable(data.getText()).orElse(\"\");\n    String[] fragment = text.split(REGEX_LINE_CHARACTOR, -1);\n    if (fragment.length > 0) {\n        textRun.setText(fragment[0], 0);\n        boolean lineAtTable = ((fragment.length > 1) && (!(data instanceof HyperlinkTextRenderData))) && TableTools.isInsideTable(run);\n        for (int i = 1; i < fragment.length; i++) {\n            if (lineAtTable) {\n                textRun.addBreak(BreakType.TEXT_WRAPPING);\n            } else {\n                textRun.addCarriageReturn();\n            }\n            textRun.setText(fragment[i]);\n        }\n    }\n    if (data instanceof BookmarkTextRenderData) {\n        createBookmark(textRun, ((BookmarkTextRenderData) (data)).getBookmark());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph",
    "thirdPartyMethod" : "javax.xml.namespace.QName.getNamespaceURI",
    "thirdPartyPackage" : "javax.xml.namespace",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph" ],
    "fullMethods" : [ "@Override\npublic XWPFParagraph insertNewParagraph(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTP.type.getName().getNamespaceURI();\n        /* TODO DO not use a coded constant, find the constant in the OOXML\n        classes instead, as the child of type CT_Paragraph is defined in the\n        OOXML schema as 'p'\n         */\n        String localPart = \"p\";\n        // creates a new Paragraph, cursor is positioned inside the new\n        // element\n        cursor.beginElement(localPart, uri);\n        // move the cursor to the START token to the paragraph just created\n        cursor.toParent();\n        CTP p = ((CTP) (cursor.getObject()));\n        XWPFParagraph newP = new XWPFParagraph(p, this);\n        XmlObject o = null;\n        /* move the cursor to the previous element until a) the next\n        paragraph is found or b) all elements have been passed\n         */\n        while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        /* if the object that has been found is a) not a paragraph or b) is\n        the paragraph that has just been inserted, as the cursor in the\n        while loop above was not moved as there were no other siblings,\n        then the paragraph that was just inserted is the first paragraph\n        in the body. Otherwise, take the previous paragraph and calculate\n        the new index for the new paragraph.\n         */\n        if ((!(o instanceof CTP)) || (o == p)) {\n            paragraphs.add(0, newP);\n        } else {\n            int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n            paragraphs.add(pos, newP);\n        }\n        /* create a new cursor, that points to the START token of the just\n        inserted paragraph\n         */\n        XmlCursor newParaPos = p.newCursor();\n        try {\n            /* Calculate the paragraphs index in the list of all body\n            elements\n             */\n            int i = 0;\n            cursor.toCursor(newParaPos);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newP);\n            cursor.toCursor(newParaPos);\n            cursor.toEndToken();\n            return newP;\n        } finally {\n            newParaPos.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph",
    "thirdPartyMethod" : "javax.xml.namespace.QName.getNamespaceURI",
    "thirdPartyPackage" : "javax.xml.namespace",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph" ],
    "fullMethods" : [ "/**\n * add a new paragraph at position of the cursor\n *\n * @param cursor\n * \t\tThe XmlCursor structure created with XmlBeans\n * @return the inserted paragraph\n */\n@Override\npublic XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInTextBox(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    bodyElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph",
    "thirdPartyMethod" : "javax.xml.namespace.QName.getNamespaceURI",
    "thirdPartyPackage" : "javax.xml.namespace",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph" ],
    "fullMethods" : [ "public XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInBlockContent(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    sdtElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewRunAfter",
    "thirdPartyMethod" : "javax.xml.namespace.QName.getNamespaceURI",
    "thirdPartyPackage" : "javax.xml.namespace",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewRunAfter" ],
    "fullMethods" : [ "public XWPFRun insertNewRunAfter(int pos) {\n    if (pos == runs.size()) {\n        return createRun();\n    }\n    if ((pos >= 0) && (pos < runs.size())) {\n        XWPFRun run = runs.get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInRunContent(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInRunContent(newCursor)) {\n            boolean nextSibling = newCursor.toNextSibling();\n            if (!nextSibling) {\n                return createRun();\n            }\n            // provide a new run\n            String uri = CTR.type.getName().getNamespaceURI();\n            String localPart = \"r\";\n            // creates a new run, cursor is positioned inside the new\n            // element\n            newCursor.beginElement(localPart, uri);\n            // move the cursor to the START token to the run just created\n            newCursor.toParent();\n            CTR r = ((CTR) (newCursor.getObject()));\n            XWPFRun newRun = new XWPFRun(r, ((IRunBody) (this)));\n            // To update the iruns, find where we're going\n            // in the normal runs, and go in there\n            int iPos = sdtElements.size();\n            int oldAt = sdtElements.indexOf(run);\n            if (oldAt != (-1)) {\n                iPos = oldAt;\n            }\n            if ((iPos + 1) >= sdtElements.size()) {\n                sdtElements.add(newRun);\n            } else {\n                sdtElements.add(iPos, newRun);\n            }\n            // Runs itself is easy to update\n            if ((pos + 1) >= runs.size()) {\n                runs.add(newRun);\n            } else {\n                runs.add(pos + 1, newRun);\n            }\n            newCursor.dispose();\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter",
    "thirdPartyMethod" : "javax.xml.namespace.QName.getNamespaceURI",
    "thirdPartyPackage" : "javax.xml.namespace",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter" ],
    "fullMethods" : [ "public XWPFRun insertNewRunAfter(int pos) {\n    if (pos == paragraph.getRuns().size()) {\n        return paragraph.createRun();\n    }\n    if ((pos >= 0) && (pos < paragraph.getRuns().size())) {\n        XWPFRun run = paragraph.getRuns().get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInParagraph(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInParagraph(newCursor)) {\n            boolean nextSibling = newCursor.toNextSibling();\n            if (!nextSibling) {\n                return paragraph.createRun();\n            }\n            String uri = CTR.type.getName().getNamespaceURI();\n            String localPart = \"r\";\n            newCursor.beginElement(localPart, uri);\n            newCursor.toParent();\n            CTR r = ((CTR) (newCursor.getObject()));\n            XWPFRun newRun = new XWPFRun(r, ((IRunBody) (this.paragraph)));\n            List<IRunElement> iruns = getIRuns();\n            List<XWPFRun> runs = getRuns();\n            int iPos = iruns.size();\n            if (pos < runs.size()) {\n                XWPFRun oldAtPos = runs.get(pos);\n                int oldAt = iruns.indexOf(oldAtPos);\n                if (oldAt != (-1)) {\n                    iPos = oldAt;\n                }\n            }\n            if ((iPos + 1) >= iruns.size()) {\n                iruns.add(newRun);\n            } else {\n                iruns.add(iPos + 1, newRun);\n            }\n            // Runs itself is easy to update\n            if ((pos + 1) >= runs.size()) {\n                runs.add(newRun);\n            } else {\n                runs.add(pos + 1, newRun);\n            }\n            newCursor.dispose();\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewTbl",
    "thirdPartyMethod" : "javax.xml.namespace.QName.getNamespaceURI",
    "thirdPartyPackage" : "javax.xml.namespace",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewTbl" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTbl(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTTbl.type.getName().getNamespaceURI();\n        String localPart = \"tbl\";\n        cursor.beginElement(localPart, uri);\n        cursor.toParent();\n        CTTbl t = ((CTTbl) (cursor.getObject()));\n        XWPFTable newT = new XWPFTable(t, this);\n        XmlObject o = null;\n        while ((!(o instanceof CTTbl)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        if (!(o instanceof CTTbl)) {\n            tables.add(0, newT);\n        } else {\n            int pos = tables.indexOf(getTable(((CTTbl) (o)))) + 1;\n            tables.add(pos, newT);\n        }\n        int i = 0;\n        XmlCursor tableCursor = t.newCursor();\n        try {\n            cursor.toCursor(tableCursor);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newT);\n            cursor.toCursor(tableCursor);\n            cursor.toEndToken();\n            return newT;\n        } finally {\n            tableCursor.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>",
    "thirdPartyMethod" : "org.apache.poi.xddf.usermodel.chart.XDDFChart.getChartSeries",
    "thirdPartyPackage" : "org.apache.poi.xddf.usermodel.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>" ],
    "fullMethods" : [ "public XDDFOfPieChartData(XDDFChart parent, CTOfPieChart chart) {\n    super(parent);\n    this.chart = chart;\n    this.seriesNum = parent.getChartSeries().size();\n    for (CTPieSer series : chart.getSerList()) {\n        this.series.add(new Series(series, series.getCat(), series.getVal()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.setWidth",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTbl.addNewTblPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.setWidth", "com.deepoove.poi.util.TableTools.ensureTblW" ],
    "fullMethods" : [ "/**\n * set table width\n *\n * @param table\n * @param width\n * @param colWidths\n */\npublic static void setWidth(XWPFTable table, String width, int[] colWidths) {\n    ensureTblW(table);\n    table.setWidth(width);\n    if (null == colWidths) {\n        int columnSize = TableTools.obtainColumnSize(table);\n        if (table.getWidthType() == TableWidthType.DXA) {\n            colWidths = UnitUtils.average(Integer.valueOf(width), columnSize);\n        } else if (table.getWidthType() == TableWidthType.PCT) {\n            int sum = 0;\n            colWidths = new int[columnSize];\n            for (int i = 0; i < (columnSize - 1); i++) {\n                colWidths[i] = 100 / columnSize;\n                sum += colWidths[i];\n            }\n            colWidths[columnSize - 1] = 100 - sum;\n        }\n    }\n    if (null != colWidths) {\n        BigInteger[] gridCol = null;\n        String[] cellWidth = null;\n        if (table.getWidthType() == TableWidthType.DXA) {\n            cellWidth = Arrays.stream(colWidths).mapToObj(String::valueOf).toArray(String[]::new);\n            gridCol = Arrays.stream(colWidths).mapToObj(BigInteger::valueOf).toArray(BigInteger[]::new);\n        } else if (table.getWidthType() == TableWidthType.PCT) {\n            cellWidth = Arrays.stream(colWidths).mapToObj(w -> w + \"%\").toArray(String[]::new);\n            BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(table.getBody());\n            int pageWidth = bodyContainer.elementPageWidth(table);\n            int tableWidth = (pageWidth * Integer.valueOf(width.substring(0, width.length() - 1))) / 100;\n            gridCol = Arrays.stream(colWidths).mapToObj(w -> BigInteger.valueOf((w * tableWidth) / 100)).toArray(BigInteger[]::new);\n        }\n        CTTblGrid tblGrid = TableTools.getTblGrid(table);\n        CTTblLayoutType tblLayout = TableTools.getTblLayout(table);\n        tblLayout.setType(STTblLayoutType.FIXED);\n        for (int index = 0; index < colWidths.length; index++) {\n            if (null != gridCol) {\n                CTTblGridCol addNewGridCol = tblGrid.addNewGridCol();\n                addNewGridCol.setW(gridCol[index]);\n            }\n            List<XWPFTableRow> rows = table.getRows();\n            for (XWPFTableRow row : rows) {\n                row.getCell(index).setWidth(cellWidth[index]);\n            }\n        }\n    }\n}", "private static void ensureTblW(XWPFTable table) {\n    CTTbl ctTbl = table.getCTTbl();\n    CTTblPr tblPr = (ctTbl.getTblPr() != null) ? ctTbl.getTblPr() : ctTbl.addNewTblPr();\n    if (!tblPr.isSetTblW())\n        tblPr.addNewTblW();\n\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.getTblLayout",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTbl.addNewTblPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.getTblLayout", "com.deepoove.poi.util.TableTools.getTblPr" ],
    "fullMethods" : [ "public static CTTblLayoutType getTblLayout(XWPFTable table) {\n    CTTblPr tblPr = getTblPr(table);\n    return tblPr.isSetTblLayout() ? tblPr.getTblLayout() : tblPr.addNewTblLayout();\n}", "private static CTTblPr getTblPr(XWPFTable table) {\n    CTTblPr tblPr = table.getCTTbl().getTblPr();\n    if (null == tblPr) {\n        tblPr = table.getCTTbl().addNewTblPr();\n    }\n    return tblPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.widthTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTbl.addNewTblPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.widthTable", "com.deepoove.poi.util.TableTools.getTblPr" ],
    "fullMethods" : [ "@Deprecated\npublic static void widthTable(XWPFTable table, float widthCM, int cols) {\n    int width = UnitUtils.cm2Twips(widthCM);\n    CTTblPr tblPr = getTblPr(table);\n    CTTblWidth tblW = (tblPr.isSetTblW()) ? tblPr.getTblW() : tblPr.addNewTblW();\n    tblW.setType(0 == width ? STTblWidth.AUTO : STTblWidth.DXA);\n    tblW.setW(BigInteger.valueOf(width));\n    if (0 != width) {\n        CTTblGrid tblGrid = getTblGrid(table);\n        for (int j = 0; j < cols; j++) {\n            CTTblGridCol addNewGridCol = tblGrid.addNewGridCol();\n            addNewGridCol.setW(BigInteger.valueOf(width / cols));\n        }\n    }\n}", "private static CTTblPr getTblPr(XWPFTable table) {\n    CTTblPr tblPr = table.getCTTbl().getTblPr();\n    if (null == tblPr) {\n        tblPr = table.getCTTbl().addNewTblPr();\n    }\n    return tblPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.widthTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTbl.addNewTblPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.widthTable", "com.deepoove.poi.util.TableTools.getTblPr" ],
    "fullMethods" : [ "@Deprecated\npublic static void widthTable(XWPFTable table, float[] colWidths) {\n    float widthCM = 0;\n    for (float w : colWidths) {\n        widthCM += w;\n    }\n    int width = UnitUtils.cm2Twips(widthCM);\n    CTTblPr tblPr = getTblPr(table);\n    CTTblWidth tblW = (tblPr.isSetTblW()) ? tblPr.getTblW() : tblPr.addNewTblW();\n    tblW.setType(0 == width ? STTblWidth.AUTO : STTblWidth.DXA);\n    tblW.setW(BigInteger.valueOf(width));\n    if (0 != width) {\n        CTTblGrid tblGrid = getTblGrid(table);\n        for (float w : colWidths) {\n            CTTblGridCol addNewGridCol = tblGrid.addNewGridCol();\n            addNewGridCol.setW(BigInteger.valueOf(UnitUtils.cm2Twips(w)));\n        }\n    }\n}", "private static CTTblPr getTblPr(XWPFTable table) {\n    CTTblPr tblPr = table.getCTTbl().getTblPr();\n    if (null == tblPr) {\n        tblPr = table.getCTTbl().addNewTblPr();\n    }\n    return tblPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTbl.addNewTblPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable", "com.deepoove.poi.util.TableTools.getTblPr" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}", "private static CTTblPr getTblPr(XWPFTable table) {\n    CTTblPr tblPr = table.getCTTbl().getTblPr();\n    if (null == tblPr) {\n        tblPr = table.getCTTbl().addNewTblPr();\n    }\n    return tblPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTbl.addNewTblPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTable" ],
    "fullMethods" : [ "/**\n * set table style\n *\n * @param table\n * @param tableStyle\n */\npublic static void styleTable(XWPFTable table, TableStyle tableStyle) {\n    if ((null == table) || (null == tableStyle))\n        return;\n\n    TableTools.setWidth(table, tableStyle.getWidth(), tableStyle.getColWidths());\n    TableTools.setBorder(table::setLeftBorder, tableStyle.getLeftBorder());\n    TableTools.setBorder(table::setRightBorder, tableStyle.getRightBorder());\n    TableTools.setBorder(table::setTopBorder, tableStyle.getTopBorder());\n    TableTools.setBorder(table::setBottomBorder, tableStyle.getBottomBorder());\n    TableTools.setBorder(table::setInsideHBorder, tableStyle.getInsideHBorder());\n    TableTools.setBorder(table::setInsideVBorder, tableStyle.getInsideVBorder());\n    if (null != tableStyle.getAlign()) {\n        table.setTableAlignment(tableStyle.getAlign());\n    }\n    table.setCellMargins(tableStyle.getTopCellMargin(), tableStyle.getLeftCellMargin(), tableStyle.getBottomCellMargin(), tableStyle.getRightCellMargin());\n    if (null != tableStyle.getIndentation()) {\n        CTTbl ctTbl = table.getCTTbl();\n        CTTblPr tPr = (ctTbl.getTblPr() != null) ? ctTbl.getTblPr() : ctTbl.addNewTblPr();\n        CTTblWidth tw = (tPr.isSetTblInd()) ? tPr.getTblInd() : tPr.addNewTblInd();\n        tw.setType(STTblWidth.DXA);\n        tw.setW(BigInteger.valueOf(UnitUtils.cm2Twips(tableStyle.getIndentation())));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.<init>",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTBr.getClear",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.<init>", "com.deepoove.poi.resolver.RunningRunBody.refactorBody" ],
    "fullMethods" : [ "public RunningRunBody(RunBodyContext context, Pattern pattern) {\n    this.runBodyContext = context;\n    this.runs = context.getRuns();\n    if ((null == runs) || runs.isEmpty())\n        return;\n\n    Matcher matcher = pattern.matcher(getText(context));\n    if (matcher.find()) {\n        refactorBody();\n    }\n    buildRunEdge(pattern);\n}", "private void refactorBody() {\n    for (int i = runs.size() - 1; i >= 0; i--) {\n        XWPFRun xwpfRun = runs.get(i);\n        CTR ctr = xwpfRun.getCTR();\n        CTRImpl ctrimpl = ((CTRImpl) (ctr));\n        int sizeOfBrArray = ctr.sizeOfBrArray();\n        int sizeOfCrArray = ctr.sizeOfCrArray();\n        int sizeOfTabArray = ctr.sizeOfTabArray();\n        if (((sizeOfBrArray + sizeOfCrArray) + sizeOfTabArray) > 0) {\n            synchronized(ctrimpl.monitor()) {\n                // ctrimpl.check_orphaned();\n                List<? extends XmlObject> localArrayList = new ArrayList<XmlObject>();\n                ctrimpl.get_store().find_all_element_users(qname, localArrayList);\n                int size = localArrayList.size();\n                for (int j = size - 1; j >= 0; j--) {\n                    Object obj = localArrayList.get(j);\n                    if (obj instanceof CTEmpty) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        String tagName = ((CTEmpty) (obj)).getDomNode().getNodeName();\n                        if (\"w:br\".equals(tagName) || \"br\".equals(tagName)) {\n                            insertNewRun.addBreak();\n                        }\n                        if (\"w:cr\".equals(tagName) || \"cr\".equals(tagName)) {\n                            insertNewRun.addCarriageReturn();\n                        }\n                        if (\"w:tab\".equals(tagName) || \"tab\".equals(tagName)) {\n                            insertNewRun.addTab();\n                        }\n                    } else if (obj instanceof CTBr) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        CTBr addNewBr = insertNewRun.getCTR().addNewBr();\n                        if (null != ((CTBr) (obj)).getType())\n                            addNewBr.setType(((CTBr) (obj)).getType());\n\n                        if (null != ((CTBr) (obj)).getClear())\n                            addNewBr.setClear(((CTBr) (obj)).getClear());\n\n                    } else if (obj instanceof CTText) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        StyleUtils.styleRun(insertNewRun, xwpfRun);\n                        insertNewRun.setText(((CTText) (obj)).getStringValue());\n                    }\n                }\n                runBodyContext.removeRun(i);\n            }\n        }\n    }\n    this.runs = runBodyContext.getRuns();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.removeBodyElement",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getCTTc",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.removeBodyElement" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void removeBodyElement(int pos) {\n    // TODO remove Nest Table\n    List<IBodyElement> bodyElements = getBodyElements();\n    if ((pos >= 0) && (pos < bodyElements.size())) {\n        BodyElementType type = bodyElements.get(pos).getElementType();\n        if (type == BodyElementType.TABLE) {\n            int indexOf = cell.getTables().indexOf(bodyElements.get(pos));\n            // remove cell's table\n            List<XWPFTable> tables = ((List<XWPFTable>) (ReflectionUtils.getValue(\"tables\", cell)));\n            tables.remove(indexOf);\n            cell.getCTTc().removeTbl(indexOf);\n        }\n        if (type == BodyElementType.PARAGRAPH) {\n            int indexOf = cell.getParagraphs().indexOf(bodyElements.get(pos));\n            // cell.removeParagraph may has bug\n            // cell.removeParagraph(indexOf);\n            List<XWPFParagraph> paragraphs = ((List<XWPFParagraph>) (ReflectionUtils.getValue(\"paragraphs\", cell)));\n            paragraphs.remove(indexOf);\n            cell.getCTTc().removeP(indexOf);\n        }\n        bodyElements.remove(pos);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getCTTc",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render", "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.getColIndex" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        for (int i = rowSize - 1; i >= 0; i--) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            String text = row.getCell(actualInsertPosition).getText();\n            if (\"_delete_\".equals(text)) {\n                table.removeRow(i);\n            } else {\n                removeCell(row, actualInsertPosition);\n            }\n        }\n    } catch (Exception e) {\n    }\n}", "private int getColIndex(XWPFTableCell cell) {\n    XWPFTableRow tableRow = cell.getTableRow();\n    int orginalCol = 0;\n    for (int i = 0; i < tableRow.getTableCells().size(); i++) {\n        XWPFTableCell current = tableRow.getCell(i);\n        int intValue = 1;\n        CTTcPr tcPr = current.getCTTc().getTcPr();\n        if (null != tcPr) {\n            CTDecimalNumber gridSpan = tcPr.getGridSpan();\n            if (null != gridSpan)\n                intValue = gridSpan.getVal().intValue();\n\n        }\n        orginalCol += intValue;\n        if (current.getCTTc() == cell.getCTTc()) {\n            return orginalCol - intValue;\n        }\n    }\n    return -1;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getCTTc",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.setTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getCTTc",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.setTable" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setTable(int pos, XWPFTable table) {\n    // cell.getTables().set(pos, table);\n    List<XWPFTable> tables = ((List<XWPFTable>) (ReflectionUtils.getValue(\"tables\", cell)));\n    tables.set(pos, table);\n    cell.getCTTc().setTblArray(pos, table.getCTTbl());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableCell",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getCTTc",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableCell" ],
    "fullMethods" : [ "/**\n * set cell style\n *\n * @param cell\n * @param cellStyle\n */\npublic static void styleTableCell(XWPFTableCell cell, CellStyle cellStyle) {\n    if ((null == cell) || (null == cellStyle))\n        return;\n\n    if (null != cellStyle.getVertAlign()) {\n        cell.setVerticalAlignment(cellStyle.getVertAlign());\n    }\n    if (null != cellStyle.getBackgroundColor()) {\n        CTTc ctTc = cell.getCTTc();\n        CTTcPr pr = (ctTc.isSetTcPr()) ? ctTc.getTcPr() : ctTc.addNewTcPr();\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = cellStyle.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(cellStyle.getBackgroundColor());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.setParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getCTTc",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.setParagraph" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setParagraph(XWPFParagraph p, int pos) {\n    List<XWPFParagraph> paragraphs = ((List<XWPFParagraph>) (ReflectionUtils.getValue(\"paragraphs\", cell)));\n    paragraphs.set(pos, p);\n    CTTc ctTc = cell.getCTTc();\n    ctTc.setPArray(pos, p.getCTP());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getCTTc",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.getTcPr",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getCTTc",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.getTcPr" ],
    "fullMethods" : [ "public static CTTcPr getTcPr(XWPFTableCell cell) {\n    CTTcPr tcPr = (cell.getCTTc().isSetTcPr()) ? cell.getCTTc().getTcPr() : cell.getCTTc().addNewTcPr();\n    return tcPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getCTTc",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        int templateColIndex = getColIndex(tagCell);\n        if ((null == data) || ((data instanceof Boolean) && (!((Boolean) (data))))) {\n            // table.removeRow(templateRowIndex);\n            // tagCell.setText(\"_delete_\");\n            run.setText(\"_delete_\", 0);\n            CTTcPr tcPr = TableTools.getTcPr(tagCell);\n            CTVMerge vMerge = tcPr.getVMerge();\n            System.out.println(null == vMerge ? null : vMerge.getVal());\n            if ((null != vMerge) && vMerge.getVal().equals(STMerge.RESTART)) {\n                XWPFTableRow row = table.getRow(templateRowIndex + 1);\n                int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n                XWPFTableCell actualCell = row.getCell(actualInsertPosition);\n                System.out.println(actualCell.getCTTc());\n                actualCell.getParagraphArray(0).createRun().setText(\"_delete_\", 0);\n            }\n        } else {\n            run.setText(\"\", 0);\n        }\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableRow",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTrPr.getCantSplitArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableRow" ],
    "fullMethods" : [ "/**\n * set row style\n *\n * @param row\n * @param rowStyle\n */\npublic static void styleTableRow(XWPFTableRow row, RowStyle rowStyle) {\n    if ((null == row) || (null == rowStyle))\n        return;\n\n    int height = rowStyle.getHeight();\n    CTRow ctRow = row.getCtRow();\n    CTTrPr properties = (ctRow.isSetTrPr()) ? ctRow.getTrPr() : ctRow.addNewTrPr();\n    if (0 != height) {\n        row.setHeight(height);\n        CTHeight h = (properties.sizeOfTrHeightArray() == 0) ? properties.addNewTrHeight() : properties.getTrHeightArray(0);\n        String heightRule = rowStyle.getHeightRule();\n        if (\"exact\".equals(heightRule))\n            h.setHRule(STHeightRule.EXACT);\n        else if (\"atleast\".equals(heightRule))\n            h.setHRule(STHeightRule.AT_LEAST);\n        else\n            h.setHRule(STHeightRule.AUTO);\n\n    }\n    boolean repeated = rowStyle.isRepeated();\n    if (repeated) {\n        CTOnOff tblHeader = (properties.sizeOfTblHeaderArray() == 0) ? properties.addNewTblHeader() : properties.getTblHeaderArray(0);\n        tblHeader.setVal(XWPFOnOff.ON);\n    }\n    boolean breakAcrossPage = rowStyle.isBreakAcrossPage();\n    if (!breakAcrossPage) {\n        if (properties.sizeOfCantSplitArray() == 0) {\n            properties.addNewCantSplit();\n        } else {\n            properties.getCantSplitArray(0).setVal(XWPFOnOff.ON);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.SDTContentContext.createRun",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTHyperlink.getRArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.SDTContentContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XmlObject object, IRunBody p) {\n    if (object instanceof CTHyperlink) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (object)), ((CTHyperlink) (object)).getRArray(0), p);\n    } else if (object instanceof CTSimpleField) {\n        return new XWPFFieldRun(((CTSimpleField) (object)), ((CTSimpleField) (object)).getRArray(0), p);\n    } else {\n        return new XWPFRun(((CTR) (object)), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.ParagraphContext.createRun",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTHyperlink.getRArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.ParagraphContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XmlObject object, IRunBody p) {\n    if (object instanceof CTHyperlink) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (object)), ((CTHyperlink) (object)).getRArray(0), p);\n    } else if (object instanceof CTSimpleField) {\n        return new XWPFFieldRun(((CTSimpleField) (object)), ((CTSimpleField) (object)).getRArray(0), p);\n    } else {\n        return new XWPFRun(((CTR) (object)), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTInd.isSetLeft",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableCell",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTc.addNewTcPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableCell" ],
    "fullMethods" : [ "/**\n * set cell style\n *\n * @param cell\n * @param cellStyle\n */\npublic static void styleTableCell(XWPFTableCell cell, CellStyle cellStyle) {\n    if ((null == cell) || (null == cellStyle))\n        return;\n\n    if (null != cellStyle.getVertAlign()) {\n        cell.setVerticalAlignment(cellStyle.getVertAlign());\n    }\n    if (null != cellStyle.getBackgroundColor()) {\n        CTTc ctTc = cell.getCTTc();\n        CTTcPr pr = (ctTc.isSetTcPr()) ? ctTc.getTcPr() : ctTc.addNewTcPr();\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = cellStyle.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(cellStyle.getBackgroundColor());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.getTcPr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTc.addNewTcPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.getTcPr" ],
    "fullMethods" : [ "public static CTTcPr getTcPr(XWPFTableCell cell) {\n    CTTcPr tcPr = (cell.getCTTc().isSetTcPr()) ? cell.getCTTc().getTcPr() : cell.getCTTc().addNewTcPr();\n    return tcPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toParent",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph" ],
    "fullMethods" : [ "@Override\npublic XWPFParagraph insertNewParagraph(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTP.type.getName().getNamespaceURI();\n        /* TODO DO not use a coded constant, find the constant in the OOXML\n        classes instead, as the child of type CT_Paragraph is defined in the\n        OOXML schema as 'p'\n         */\n        String localPart = \"p\";\n        // creates a new Paragraph, cursor is positioned inside the new\n        // element\n        cursor.beginElement(localPart, uri);\n        // move the cursor to the START token to the paragraph just created\n        cursor.toParent();\n        CTP p = ((CTP) (cursor.getObject()));\n        XWPFParagraph newP = new XWPFParagraph(p, this);\n        XmlObject o = null;\n        /* move the cursor to the previous element until a) the next\n        paragraph is found or b) all elements have been passed\n         */\n        while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        /* if the object that has been found is a) not a paragraph or b) is\n        the paragraph that has just been inserted, as the cursor in the\n        while loop above was not moved as there were no other siblings,\n        then the paragraph that was just inserted is the first paragraph\n        in the body. Otherwise, take the previous paragraph and calculate\n        the new index for the new paragraph.\n         */\n        if ((!(o instanceof CTP)) || (o == p)) {\n            paragraphs.add(0, newP);\n        } else {\n            int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n            paragraphs.add(pos, newP);\n        }\n        /* create a new cursor, that points to the START token of the just\n        inserted paragraph\n         */\n        XmlCursor newParaPos = p.newCursor();\n        try {\n            /* Calculate the paragraphs index in the list of all body\n            elements\n             */\n            int i = 0;\n            cursor.toCursor(newParaPos);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newP);\n            cursor.toCursor(newParaPos);\n            cursor.toEndToken();\n            return newP;\n        } finally {\n            newParaPos.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toParent",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph" ],
    "fullMethods" : [ "/**\n * add a new paragraph at position of the cursor\n *\n * @param cursor\n * \t\tThe XmlCursor structure created with XmlBeans\n * @return the inserted paragraph\n */\n@Override\npublic XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInTextBox(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    bodyElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toParent",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph" ],
    "fullMethods" : [ "public XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInBlockContent(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    sdtElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewRunAfter",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toParent",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewRunAfter" ],
    "fullMethods" : [ "public XWPFRun insertNewRunAfter(int pos) {\n    if (pos == runs.size()) {\n        return createRun();\n    }\n    if ((pos >= 0) && (pos < runs.size())) {\n        XWPFRun run = runs.get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInRunContent(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInRunContent(newCursor)) {\n            boolean nextSibling = newCursor.toNextSibling();\n            if (!nextSibling) {\n                return createRun();\n            }\n            // provide a new run\n            String uri = CTR.type.getName().getNamespaceURI();\n            String localPart = \"r\";\n            // creates a new run, cursor is positioned inside the new\n            // element\n            newCursor.beginElement(localPart, uri);\n            // move the cursor to the START token to the run just created\n            newCursor.toParent();\n            CTR r = ((CTR) (newCursor.getObject()));\n            XWPFRun newRun = new XWPFRun(r, ((IRunBody) (this)));\n            // To update the iruns, find where we're going\n            // in the normal runs, and go in there\n            int iPos = sdtElements.size();\n            int oldAt = sdtElements.indexOf(run);\n            if (oldAt != (-1)) {\n                iPos = oldAt;\n            }\n            if ((iPos + 1) >= sdtElements.size()) {\n                sdtElements.add(newRun);\n            } else {\n                sdtElements.add(iPos, newRun);\n            }\n            // Runs itself is easy to update\n            if ((pos + 1) >= runs.size()) {\n                runs.add(newRun);\n            } else {\n                runs.add(pos + 1, newRun);\n            }\n            newCursor.dispose();\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toParent",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter" ],
    "fullMethods" : [ "public XWPFRun insertNewRunAfter(int pos) {\n    if (pos == paragraph.getRuns().size()) {\n        return paragraph.createRun();\n    }\n    if ((pos >= 0) && (pos < paragraph.getRuns().size())) {\n        XWPFRun run = paragraph.getRuns().get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInParagraph(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInParagraph(newCursor)) {\n            boolean nextSibling = newCursor.toNextSibling();\n            if (!nextSibling) {\n                return paragraph.createRun();\n            }\n            String uri = CTR.type.getName().getNamespaceURI();\n            String localPart = \"r\";\n            newCursor.beginElement(localPart, uri);\n            newCursor.toParent();\n            CTR r = ((CTR) (newCursor.getObject()));\n            XWPFRun newRun = new XWPFRun(r, ((IRunBody) (this.paragraph)));\n            List<IRunElement> iruns = getIRuns();\n            List<XWPFRun> runs = getRuns();\n            int iPos = iruns.size();\n            if (pos < runs.size()) {\n                XWPFRun oldAtPos = runs.get(pos);\n                int oldAt = iruns.indexOf(oldAtPos);\n                if (oldAt != (-1)) {\n                    iPos = oldAt;\n                }\n            }\n            if ((iPos + 1) >= iruns.size()) {\n                iruns.add(newRun);\n            } else {\n                iruns.add(iPos + 1, newRun);\n            }\n            // Runs itself is easy to update\n            if ((pos + 1) >= runs.size()) {\n                runs.add(newRun);\n            } else {\n                runs.add(pos + 1, newRun);\n            }\n            newCursor.dispose();\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewTbl",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toParent",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewTbl" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTbl(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTTbl.type.getName().getNamespaceURI();\n        String localPart = \"tbl\";\n        cursor.beginElement(localPart, uri);\n        cursor.toParent();\n        CTTbl t = ((CTTbl) (cursor.getObject()));\n        XWPFTable newT = new XWPFTable(t, this);\n        XmlObject o = null;\n        while ((!(o instanceof CTTbl)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        if (!(o instanceof CTTbl)) {\n            tables.add(0, newT);\n        } else {\n            int pos = tables.indexOf(getTable(((CTTbl) (o)))) + 1;\n            tables.add(pos, newT);\n        }\n        int i = 0;\n        XmlCursor tableCursor = t.newCursor();\n        try {\n            cursor.toCursor(tableCursor);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newT);\n            cursor.toCursor(tableCursor);\n            cursor.toEndToken();\n            return newT;\n        } finally {\n            tableCursor.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewRun",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toParent",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewRun", "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewProvidedRun" ],
    "fullMethods" : [ "public XWPFRun insertNewRun(int pos) {\n    if (pos == runs.size()) {\n        return createRun();\n    }\n    return insertNewProvidedRun(pos, newCursor -> {\n        String uri = CTR.type.getName().getNamespaceURI();\n        String localPart = \"r\";\n        // creates a new run, cursor is positioned inside the new\n        // element\n        newCursor.beginElement(localPart, uri);\n        // move the cursor to the START token to the run just created\n        newCursor.toParent();\n        CTR r = ((CTR) (newCursor.getObject()));\n        return new XWPFRun(r, ((IRunBody) (this)));\n    });\n}", "/**\n * insert a new run provided by in all runs\n *\n * @param <T>\n * \t\tXWPFRun or XWPFHyperlinkRun or XWPFFieldRun\n * @param pos\n * \t\tThe position at which the new run should be added.\n * @param provider\n * \t\tprovide a new run at position of the given cursor.\n * @return the inserted run or null if the given pos is out of bounds.\n */\nprivate <T extends XWPFRun> T insertNewProvidedRun(int pos, Function<XmlCursor, T> provider) {\n    if ((pos >= 0) && (pos < runs.size())) {\n        XWPFRun run = runs.get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInRunContent(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInRunContent(newCursor)) {\n            // provide a new run\n            T newRun = provider.apply(newCursor);\n            // To update the iruns, find where we're going\n            // in the normal runs, and go in there\n            int iPos = sdtElements.size();\n            int oldAt = sdtElements.indexOf(run);\n            if (oldAt != (-1)) {\n                iPos = oldAt;\n            }\n            sdtElements.add(iPos, newRun);\n            // Runs itself is easy to update\n            runs.add(pos, newRun);\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblPr.addNewTblInd",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTable" ],
    "fullMethods" : [ "/**\n * set table style\n *\n * @param table\n * @param tableStyle\n */\npublic static void styleTable(XWPFTable table, TableStyle tableStyle) {\n    if ((null == table) || (null == tableStyle))\n        return;\n\n    TableTools.setWidth(table, tableStyle.getWidth(), tableStyle.getColWidths());\n    TableTools.setBorder(table::setLeftBorder, tableStyle.getLeftBorder());\n    TableTools.setBorder(table::setRightBorder, tableStyle.getRightBorder());\n    TableTools.setBorder(table::setTopBorder, tableStyle.getTopBorder());\n    TableTools.setBorder(table::setBottomBorder, tableStyle.getBottomBorder());\n    TableTools.setBorder(table::setInsideHBorder, tableStyle.getInsideHBorder());\n    TableTools.setBorder(table::setInsideVBorder, tableStyle.getInsideVBorder());\n    if (null != tableStyle.getAlign()) {\n        table.setTableAlignment(tableStyle.getAlign());\n    }\n    table.setCellMargins(tableStyle.getTopCellMargin(), tableStyle.getLeftCellMargin(), tableStyle.getBottomCellMargin(), tableStyle.getRightCellMargin());\n    if (null != tableStyle.getIndentation()) {\n        CTTbl ctTbl = table.getCTTbl();\n        CTTblPr tPr = (ctTbl.getTblPr() != null) ? ctTbl.getTblPr() : ctTbl.addNewTblPr();\n        CTTblWidth tw = (tPr.isSetTblInd()) ? tPr.getTblInd() : tPr.addNewTblInd();\n        tw.setType(STTblWidth.DXA);\n        tw.setW(BigInteger.valueOf(UnitUtils.cm2Twips(tableStyle.getIndentation())));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.addSeries",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.addNewVal",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.addSeries" ],
    "fullMethods" : [ "@Override\npublic XDDFChartData.Series addSeries(XDDFDataSource<?> category, XDDFNumericalDataSource<? extends Number> values) {\n    final long index = ++this.seriesNum;\n    final CTPieSer ctSer = this.chart.addNewSer();\n    ctSer.addNewCat();\n    ctSer.addNewVal();\n    ctSer.addNewIdx().setVal(index);\n    ctSer.addNewOrder().setVal(index);\n    final Series added = new Series(ctSer, category, values);\n    this.series.add(added);\n    return added;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.setParagraph",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTxbxContent.sizeOfPArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.setParagraph" ],
    "fullMethods" : [ "public void setParagraph(XWPFParagraph p) {\n    if (ctTxbxContent.sizeOfPArray() == 0) {\n        ctTxbxContent.addNewP();\n    }\n    ctTxbxContent.setPArray(0, p.getCTP());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getText",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFSDTCell.getContent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getText", "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.appendTable" ],
    "fullMethods" : [ "@Override\npublic String getText() {\n    StringBuilder text = new StringBuilder();\n    boolean addNewLine = false;\n    for (int i = 0; i < sdtElements.size(); i++) {\n        Object o = sdtElements.get(i);\n        if (o instanceof XWPFParagraph) {\n            appendParagraph(((XWPFParagraph) (o)), text);\n            addNewLine = true;\n        } else if (o instanceof XWPFTable) {\n            appendTable(((XWPFTable) (o)), text);\n            addNewLine = true;\n        } else if (o instanceof XWPFSDT) {\n            text.append(((XWPFSDT) (o)).getContent().getText());\n            addNewLine = true;\n        } else if (o instanceof XWPFRun) {\n            text.append(o);\n            addNewLine = false;\n        }\n        if (addNewLine && (i < (sdtElements.size() - 1))) {\n            text.append(\"\\n\");\n        }\n    }\n    return text.toString();\n}", "private void appendTable(XWPFTable table, StringBuilder text) {\n    // this works recursively to pull embedded tables from within cells\n    for (XWPFTableRow row : table.getRows()) {\n        List<ICell> cells = row.getTableICells();\n        for (int i = 0; i < cells.size(); i++) {\n            ICell cell = cells.get(i);\n            if (cell instanceof XWPFTableCell) {\n                text.append(((XWPFTableCell) (cell)).getTextRecursively());\n            } else if (cell instanceof XWPFSDTCell) {\n                text.append(((XWPFSDTCell) (cell)).getContent().getText());\n            }\n            if (i < (cells.size() - 1)) {\n                text.append(\"\\t\");\n            }\n        }\n        text.append('\\n');\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTInd.setFirstLineChars",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setCharacterSpacing",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun" ],
    "fullMethods" : [ "/**\n * set run style by other run\n *\n * @param dest\n * @param src\n */\npublic static void styleRun(XWPFRun dest, XWPFRun src) {\n    if ((null == dest) || (null == src))\n        return;\n\n    if (StringUtils.isNotEmpty(src.getStyle()))\n        dest.setStyle(src.getStyle());\n\n    if (Boolean.TRUE.equals(src.isBold()))\n        dest.setBold(src.isBold());\n\n    if (StringUtils.isNotBlank(src.getColor()))\n        dest.setColor(src.getColor());\n\n    if (0 != src.getCharacterSpacing())\n        dest.setCharacterSpacing(src.getCharacterSpacing());\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.ascii)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.ascii);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.eastAsia)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.eastAsia);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.hAnsi)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.hAnsi);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.cs)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.cs);\n\n    Double fontSize = src.getFontSizeAsDouble();\n    if (null != fontSize) {\n        dest.setFontSize(fontSize);\n    }\n    if (Boolean.TRUE.equals(src.isItalic()))\n        dest.setItalic(src.isItalic());\n\n    if (Boolean.TRUE.equals(src.isStrikeThrough()))\n        dest.setStrikeThrough(src.isStrikeThrough());\n\n    if (UnderlinePatterns.NONE != src.getUnderline())\n        dest.setUnderline(src.getUnderline());\n\n    if (null != src.getUnderlineColor())\n        dest.setUnderlineColor(src.getUnderlineColor());\n\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setCharacterSpacing",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun" ],
    "fullMethods" : [ "/**\n * set run style by style\n *\n * @param run\n * @param style\n */\npublic static void styleRun(XWPFRun run, Style style) {\n    if ((null == run) || (null == style))\n        return;\n\n    CTRPr pr = getRunProperties(run);\n    String color = style.getColor();\n    if (StringUtils.isNotBlank(color)) {\n        // run.setColor(color);\n        // issue 326\n        CTColor ctColor = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        ctColor.setVal(color);\n        if (ctColor.isSetThemeColor())\n            ctColor.unsetThemeColor();\n\n    }\n    double fontSize = style.getFontSize();\n    if ((0 != fontSize) && ((-1) != fontSize)) {\n        run.setFontSize(fontSize);\n    }\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        run.setFontFamily(fontFamily, FontCharRange.eastAsia);\n        run.setFontFamily(fontFamily, FontCharRange.ascii);\n        run.setFontFamily(fontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(fontFamily, FontCharRange.cs);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        run.setFontFamily(westernFontFamily, FontCharRange.ascii);\n        run.setFontFamily(westernFontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(westernFontFamily, FontCharRange.cs);\n    }\n    XWPFHighlightColor highlightColor = style.getHighlightColor();\n    if (null != highlightColor) {\n        CTHighlight highlight = (pr.sizeOfHighlightArray() > 0) ? pr.getHighlightArray(0) : pr.addNewHighlight();\n        highlight.setVal(STHighlightColor.Enum.forInt(highlightColor.getValue()));\n    }\n    Boolean bold = style.isBold();\n    if (null != bold)\n        run.setBold(bold);\n\n    Boolean italic = style.isItalic();\n    if (null != italic)\n        run.setItalic(italic);\n\n    Boolean strike = style.isStrike();\n    if (null != strike)\n        run.setStrikeThrough(strike);\n\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        run.setUnderline(underlinePatern);\n        if (null != style.getUnderlineColor()) {\n            run.setUnderlineColor(style.getUnderlineColor());\n        }\n    }\n    int point = style.getCharacterSpacing();\n    // in twentieths of a point\n    if ((0 != point) && ((-1) != point))\n        run.setCharacterSpacing(UnitUtils.point2Twips(point));\n\n    String vertAlign = style.getVertAlign();\n    if (StringUtils.isNotBlank(vertAlign)) {\n        run.setVerticalAlignment(vertAlign);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.<init>",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTBr.getType",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.<init>", "com.deepoove.poi.resolver.RunningRunBody.refactorBody" ],
    "fullMethods" : [ "public RunningRunBody(RunBodyContext context, Pattern pattern) {\n    this.runBodyContext = context;\n    this.runs = context.getRuns();\n    if ((null == runs) || runs.isEmpty())\n        return;\n\n    Matcher matcher = pattern.matcher(getText(context));\n    if (matcher.find()) {\n        refactorBody();\n    }\n    buildRunEdge(pattern);\n}", "private void refactorBody() {\n    for (int i = runs.size() - 1; i >= 0; i--) {\n        XWPFRun xwpfRun = runs.get(i);\n        CTR ctr = xwpfRun.getCTR();\n        CTRImpl ctrimpl = ((CTRImpl) (ctr));\n        int sizeOfBrArray = ctr.sizeOfBrArray();\n        int sizeOfCrArray = ctr.sizeOfCrArray();\n        int sizeOfTabArray = ctr.sizeOfTabArray();\n        if (((sizeOfBrArray + sizeOfCrArray) + sizeOfTabArray) > 0) {\n            synchronized(ctrimpl.monitor()) {\n                // ctrimpl.check_orphaned();\n                List<? extends XmlObject> localArrayList = new ArrayList<XmlObject>();\n                ctrimpl.get_store().find_all_element_users(qname, localArrayList);\n                int size = localArrayList.size();\n                for (int j = size - 1; j >= 0; j--) {\n                    Object obj = localArrayList.get(j);\n                    if (obj instanceof CTEmpty) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        String tagName = ((CTEmpty) (obj)).getDomNode().getNodeName();\n                        if (\"w:br\".equals(tagName) || \"br\".equals(tagName)) {\n                            insertNewRun.addBreak();\n                        }\n                        if (\"w:cr\".equals(tagName) || \"cr\".equals(tagName)) {\n                            insertNewRun.addCarriageReturn();\n                        }\n                        if (\"w:tab\".equals(tagName) || \"tab\".equals(tagName)) {\n                            insertNewRun.addTab();\n                        }\n                    } else if (obj instanceof CTBr) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        CTBr addNewBr = insertNewRun.getCTR().addNewBr();\n                        if (null != ((CTBr) (obj)).getType())\n                            addNewBr.setType(((CTBr) (obj)).getType());\n\n                        if (null != ((CTBr) (obj)).getClear())\n                            addNewBr.setClear(((CTBr) (obj)).getClear());\n\n                    } else if (obj instanceof CTText) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        StyleUtils.styleRun(insertNewRun, xwpfRun);\n                        insertNewRun.setText(((CTText) (obj)).getStringValue());\n                    }\n                }\n                runBodyContext.removeRun(i);\n            }\n        }\n    }\n    this.runs = runBodyContext.getRuns();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.mergeCellsHorizonal",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRow.sizeOfTcArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.mergeCellsHorizonal" ],
    "fullMethods" : [ "/**\n * merge several columns of cells in the same row\n *\n * @param table\n * \t\ttable\n * @param row\n * \t\tindex of the row\n * @param fromCol\n * \t\tfrom column to be merged\n * @param toCol\n * \t\tto column to be merged\n */\npublic static void mergeCellsHorizonal(XWPFTable table, int row, int fromCol, int toCol) {\n    Preconditions.requireGreaterThan(toCol, fromCol, \"To column to be merged must greater than from column.\");\n    mergeCellsHorizontalWithoutRemove(table, row, fromCol, toCol);\n    XWPFTableRow rowTable = table.getRow(row);\n    for (int colIndex = fromCol + 1; colIndex <= toCol; colIndex++) {\n        rowTable.removeCell(fromCol + 1);\n        if (rowTable.getTableCells().size() != rowTable.getCtRow().sizeOfTcArray()) {\n            rowTable.getCtRow().removeTc(fromCol + 1);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRow.sizeOfTcArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderTable", "com.deepoove.poi.policy.TableRenderPolicy.Helper.applyMergeRule" ],
    "fullMethods" : [ "public static XWPFTable renderTable(XWPFRun run, TableRenderData data) throws Exception {\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    XWPFTable table = bodyContainer.insertNewTable(run, data.obtainRowSize(), data.obtainColSize());\n    StyleUtils.styleTable(table, data.getTableStyle());\n    int size = table.getRows().size();\n    for (int i = 0; i < size; i++) {\n        RowRenderData rowRenderData = data.getRows().get(i);\n        renderRow(table.getRows().get(i), rowRenderData, StyleUtils.retriveStyle(run));\n    }\n    applyMergeRule(table, data.getMergeRule());\n    return table;\n}", "private static void applyMergeRule(XWPFTable table, MergeCellRule mergeRule) {\n    if (null == mergeRule)\n        return;\n\n    byte[][] markRemovedCell = new byte[TableTools.obtainRowSize(table)][TableTools.obtainColumnSize(table)];\n    Iterator<Entry<Grid, Grid>> iterator = mergeRule.mappingIterator();\n    while (iterator.hasNext()) {\n        Entry<Grid, Grid> next = iterator.next();\n        Grid key = next.getKey();\n        Grid value = next.getValue();\n        int startI = (key.getI() > value.getI()) ? value.getI() : key.getI();\n        int startJ = (key.getJ() > value.getJ()) ? value.getJ() : key.getJ();\n        int endI = (key.getI() > value.getI()) ? key.getI() : value.getI();\n        int endJ = (key.getJ() > value.getJ()) ? key.getJ() : value.getJ();\n        // merge(VMerge mark) vertical\n        if (startI != endI) {\n            for (int j = startJ; j <= endJ; j++) {\n                TableTools.mergeCellsVertically(table, j, startI, endI);\n            }\n        }\n        // merge horizontal cells without remove cells\n        if (startJ != endJ) {\n            for (int i = startI; i <= endI; i++) {\n                TableTools.mergeCellsHorizontalWithoutRemove(table, i, startJ, endJ);\n                for (int removedCol = startJ + 1; removedCol <= endJ; removedCol++) {\n                    markRemovedCell[i][removedCol] = 1;\n                }\n            }\n        }\n    } \n    // remove marked cell safely\n    for (int i = 0; i < markRemovedCell.length; i++) {\n        for (int j = markRemovedCell[i].length - 1; j >= 0; j--) {\n            if (markRemovedCell[i][j] >= 1) {\n                table.getRow(i).removeCell(j);\n                if (table.getRow(i).getTableCells().size() != table.getRow(i).getCtRow().sizeOfTcArray()) {\n                    table.getRow(i).getCtRow().removeTc(j);\n                }\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShapeProperties",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.unsetSpPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShapeProperties" ],
    "fullMethods" : [ "@Override\npublic void setShapeProperties(XDDFShapeProperties properties) {\n    if (properties == null) {\n        if (series.isSetSpPr()) {\n            series.unsetSpPr();\n        }\n    } else if (series.isSetSpPr()) {\n        series.setSpPr(properties.getXmlObject());\n    } else {\n        series.addNewSpPr().set(properties.getXmlObject());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShowLeaderLines",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.getDLbls",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShowLeaderLines" ],
    "fullMethods" : [ "@Override\npublic void setShowLeaderLines(boolean showLeaderLines) {\n    if (!series.isSetDLbls()) {\n        series.addNewDLbls();\n    }\n    if (series.getDLbls().isSetShowLeaderLines()) {\n        series.getDLbls().getShowLeaderLines().setVal(showLeaderLines);\n    } else {\n        series.getDLbls().addNewShowLeaderLines().setVal(showLeaderLines);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableRow",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTrPr.addNewTblHeader",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableRow" ],
    "fullMethods" : [ "/**\n * set row style\n *\n * @param row\n * @param rowStyle\n */\npublic static void styleTableRow(XWPFTableRow row, RowStyle rowStyle) {\n    if ((null == row) || (null == rowStyle))\n        return;\n\n    int height = rowStyle.getHeight();\n    CTRow ctRow = row.getCtRow();\n    CTTrPr properties = (ctRow.isSetTrPr()) ? ctRow.getTrPr() : ctRow.addNewTrPr();\n    if (0 != height) {\n        row.setHeight(height);\n        CTHeight h = (properties.sizeOfTrHeightArray() == 0) ? properties.addNewTrHeight() : properties.getTrHeightArray(0);\n        String heightRule = rowStyle.getHeightRule();\n        if (\"exact\".equals(heightRule))\n            h.setHRule(STHeightRule.EXACT);\n        else if (\"atleast\".equals(heightRule))\n            h.setHRule(STHeightRule.AT_LEAST);\n        else\n            h.setHRule(STHeightRule.AUTO);\n\n    }\n    boolean repeated = rowStyle.isRepeated();\n    if (repeated) {\n        CTOnOff tblHeader = (properties.sizeOfTblHeaderArray() == 0) ? properties.addNewTblHeader() : properties.getTblHeaderArray(0);\n        tblHeader.setVal(XWPFOnOff.ON);\n    }\n    boolean breakAcrossPage = rowStyle.isBreakAcrossPage();\n    if (!breakAcrossPage) {\n        if (properties.sizeOfCantSplitArray() == 0) {\n            properties.addNewCantSplit();\n        } else {\n            properties.getCantSplitArray(0).setVal(XWPFOnOff.ON);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFChartFactory.<init>",
    "thirdPartyMethod" : "org.apache.poi.ooxml.POIXMLFactory.<init>",
    "thirdPartyPackage" : "org.apache.poi.ooxml",
    "path" : [ "com.deepoove.poi.xwpf.XWPFChartFactory.<init>" ],
    "fullMethods" : [ "public XWPFChartFactory(PackagePart xwpfChart) {\n    this.part = xwpfChart;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableRow",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRow.getTrPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableRow" ],
    "fullMethods" : [ "/**\n * set row style\n *\n * @param row\n * @param rowStyle\n */\npublic static void styleTableRow(XWPFTableRow row, RowStyle rowStyle) {\n    if ((null == row) || (null == rowStyle))\n        return;\n\n    int height = rowStyle.getHeight();\n    CTRow ctRow = row.getCtRow();\n    CTTrPr properties = (ctRow.isSetTrPr()) ? ctRow.getTrPr() : ctRow.addNewTrPr();\n    if (0 != height) {\n        row.setHeight(height);\n        CTHeight h = (properties.sizeOfTrHeightArray() == 0) ? properties.addNewTrHeight() : properties.getTrHeightArray(0);\n        String heightRule = rowStyle.getHeightRule();\n        if (\"exact\".equals(heightRule))\n            h.setHRule(STHeightRule.EXACT);\n        else if (\"atleast\".equals(heightRule))\n            h.setHRule(STHeightRule.AT_LEAST);\n        else\n            h.setHRule(STHeightRule.AUTO);\n\n    }\n    boolean repeated = rowStyle.isRepeated();\n    if (repeated) {\n        CTOnOff tblHeader = (properties.sizeOfTblHeaderArray() == 0) ? properties.addNewTblHeader() : properties.getTblHeaderArray(0);\n        tblHeader.setVal(XWPFOnOff.ON);\n    }\n    boolean breakAcrossPage = rowStyle.isBreakAcrossPage();\n    if (!breakAcrossPage) {\n        if (properties.sizeOfCantSplitArray() == 0) {\n            properties.addNewCantSplit();\n        } else {\n            properties.getCantSplitArray(0).setVal(XWPFOnOff.ON);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveBorderStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTBorder.isSetSz",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveBorderStyle" ],
    "fullMethods" : [ "public static BorderStyle retriveBorderStyle(CTBorder border) {\n    BorderStyle.Builder borderBuilder = BorderStyle.builder();\n    if (border.isSetColor())\n        borderBuilder.withColor(border.xgetColor().getStringValue());\n\n    if (border.isSetSz())\n        borderBuilder.withSize(border.getSz().intValue());\n\n    if (border.getVal() != null)\n        borderBuilder.withType(XWPFBorderType.valueOf(border.getVal().toString().toUpperCase()));\n\n    return borderBuilder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.getRFontsArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CommentBodyContainer.setTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFComment.getCtComment",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CommentBodyContainer.setTable" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setTable(int pos, XWPFTable table) {\n    // cell.getTables().set(pos, table);\n    List<XWPFTable> tables = ((List<XWPFTable>) (ReflectionUtils.getValue(\"tables\", comment)));\n    tables.set(pos, table);\n    comment.getCtComment().setTblArray(pos, table.getCTTbl());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CommentBodyContainer.setParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFComment.getCtComment",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CommentBodyContainer.setParagraph" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setParagraph(XWPFParagraph p, int paraPos) {\n    List<XWPFParagraph> paragraphs = ((List<XWPFParagraph>) (ReflectionUtils.getValue(\"paragraphs\", comment)));\n    paragraphs.set(paraPos, p);\n    CTComment ctc = comment.getCtComment();\n    ctc.setPArray(paraPos, p.getCTP());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFComment.getCtComment",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment" ],
    "fullMethods" : [ "public static void renderComment(XWPFRun run, CommentRenderData data) throws Exception {\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper parentContext = new XWPFParagraphWrapper(paragraph);\n    BigInteger cId = BigInteger.ZERO;\n    CommentContent commentContent = data.getCommentContent();\n    if (null != commentContent) {\n        XWPFComments comments = ((NiceXWPFDocument) (paragraph.getDocument())).createComments();\n        XWPFComment newComment = comments.createComment(NextIDUtils.getCommentMaxId(comments).add(BigInteger.ONE));\n        newComment.setAuthor(commentContent.getAuthor());\n        newComment.setDate(commentContent.getDate());\n        newComment.setInitials(commentContent.getInitials());\n        renderDocument(newComment.createParagraph().createRun(), commentContent.getContent());\n        cId = newComment.getCtComment().getId();\n        parentContext.insertNewCommentRangeStart(run, cId);\n    }\n    renderParagraph(run, Paragraphs.of().addList(data.getContents()).create());\n    if (null != commentContent) {\n        parentContext.insertNewCommentRangeEnd(run, cId);\n        XWPFRun newRun = parentContext.insertNewRun(ParagraphUtils.getRunPos(run));\n        newRun.getCTR().addNewCommentReference().setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.NextIDUtils.getCommentMaxId",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFComment.getCtComment",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.NextIDUtils.getCommentMaxId" ],
    "fullMethods" : [ "public static BigInteger getCommentMaxId(XWPFComments docComments) {\n    List<XWPFComment> comments = docComments.getComments();\n    BigInteger max = BigInteger.ZERO;\n    if (null == comments)\n        return max;\n\n    for (XWPFComment comment : comments) {\n        BigInteger id = comment.getCtComment().getId();\n        if ((null != id) && (id.compareTo(max) == 1)) {\n            max = id;\n        }\n    }\n    return max;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.PictureRenderPolicy.Helper.renderPicture",
    "thirdPartyMethod" : "org.apache.poi.util.Units.pixelToEMU",
    "thirdPartyPackage" : "org.apache.poi.util",
    "path" : [ "com.deepoove.poi.policy.PictureRenderPolicy.Helper.renderPicture" ],
    "fullMethods" : [ "public static void renderPicture(XWPFRun run, PictureRenderData picture) throws Exception {\n    byte[] imageBytes = picture.readPictureData();\n    if (null == imageBytes) {\n        throw new IllegalStateException(\"Can't read picture byte arrays!\");\n    }\n    PictureType pictureType = picture.getPictureType();\n    if (null == pictureType) {\n        pictureType = PictureType.suggestFileType(imageBytes);\n    }\n    if (null == pictureType) {\n        throw new RenderException(\"PictureRenderData must set picture type!\");\n    }\n    PictureStyle style = picture.getPictureStyle();\n    if (null == style)\n        style = new PictureStyle();\n\n    int width = style.getWidth();\n    int height = style.getHeight();\n    int svgScale = style.getSvgScale();\n    if (pictureType == PictureType.SVG) {\n        imageBytes = SVGConvertor.toPng(imageBytes, ((float) (width)), ((float) (height)), svgScale);\n        pictureType = PictureType.PNG;\n    }\n    if (!isSetSize(style)) {\n        BufferedImage original = BufferedImageUtils.readBufferedImage(imageBytes);\n        width = original.getWidth();\n        height = original.getHeight();\n        if (style.getScalePattern() == WidthScalePattern.FIT) {\n            BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n            int pageWidth = UnitUtils.twips2Pixel(bodyContainer.elementPageWidth(((IBodyElement) (run.getParent()))));\n            if (width > pageWidth) {\n                double ratio = pageWidth / ((double) (width));\n                width = pageWidth;\n                height = ((int) (height * ratio));\n            }\n        }\n    }\n    try (InputStream stream = new ByteArrayInputStream(imageBytes)) {\n        PictureAlign align = style.getAlign();\n        if ((null != align) && (run.getParent() instanceof XWPFParagraph)) {\n            ((XWPFParagraph) (run.getParent())).setAlignment(ParagraphAlignment.valueOf(align.ordinal() + 1));\n        }\n        run.addPicture(stream, pictureType.type(), \"Generated\", Units.pixelToEMU(width), Units.pixelToEMU(height));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.WhereDelegate.addPicture",
    "thirdPartyMethod" : "org.apache.poi.util.Units.pixelToEMU",
    "thirdPartyPackage" : "org.apache.poi.util",
    "path" : [ "com.deepoove.poi.render.WhereDelegate.addPicture" ],
    "fullMethods" : [ "public void addPicture(InputStream inputStream, int type, int width, int height) throws InvalidFormatException, IOException {\n    run.addPicture(inputStream, type, \"Generated\", Units.pixelToEMU(width), Units.pixelToEMU(height));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFComment.setAuthor",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment" ],
    "fullMethods" : [ "public static void renderComment(XWPFRun run, CommentRenderData data) throws Exception {\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper parentContext = new XWPFParagraphWrapper(paragraph);\n    BigInteger cId = BigInteger.ZERO;\n    CommentContent commentContent = data.getCommentContent();\n    if (null != commentContent) {\n        XWPFComments comments = ((NiceXWPFDocument) (paragraph.getDocument())).createComments();\n        XWPFComment newComment = comments.createComment(NextIDUtils.getCommentMaxId(comments).add(BigInteger.ONE));\n        newComment.setAuthor(commentContent.getAuthor());\n        newComment.setDate(commentContent.getDate());\n        newComment.setInitials(commentContent.getInitials());\n        renderDocument(newComment.createParagraph().createRun(), commentContent.getContent());\n        cId = newComment.getCtComment().getId();\n        parentContext.insertNewCommentRangeStart(run, cId);\n    }\n    renderParagraph(run, Paragraphs.of().addList(data.getContents()).create());\n    if (null != commentContent) {\n        parentContext.insertNewCommentRangeEnd(run, cId);\n        XWPFRun newRun = parentContext.insertNewRun(ParagraphUtils.getRunPos(run));\n        newRun.getCTR().addNewCommentReference().setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getText",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTableICells",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getText", "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.appendTable" ],
    "fullMethods" : [ "@Override\npublic String getText() {\n    StringBuilder text = new StringBuilder();\n    boolean addNewLine = false;\n    for (int i = 0; i < sdtElements.size(); i++) {\n        Object o = sdtElements.get(i);\n        if (o instanceof XWPFParagraph) {\n            appendParagraph(((XWPFParagraph) (o)), text);\n            addNewLine = true;\n        } else if (o instanceof XWPFTable) {\n            appendTable(((XWPFTable) (o)), text);\n            addNewLine = true;\n        } else if (o instanceof XWPFSDT) {\n            text.append(((XWPFSDT) (o)).getContent().getText());\n            addNewLine = true;\n        } else if (o instanceof XWPFRun) {\n            text.append(o);\n            addNewLine = false;\n        }\n        if (addNewLine && (i < (sdtElements.size() - 1))) {\n            text.append(\"\\n\");\n        }\n    }\n    return text.toString();\n}", "private void appendTable(XWPFTable table, StringBuilder text) {\n    // this works recursively to pull embedded tables from within cells\n    for (XWPFTableRow row : table.getRows()) {\n        List<ICell> cells = row.getTableICells();\n        for (int i = 0; i < cells.size(); i++) {\n            ICell cell = cells.get(i);\n            if (cell instanceof XWPFTableCell) {\n                text.append(((XWPFTableCell) (cell)).getTextRecursively());\n            } else if (cell instanceof XWPFSDTCell) {\n                text.append(((XWPFSDTCell) (cell)).getContent().getText());\n            }\n            if (i < (cells.size() - 1)) {\n                text.append(\"\\t\");\n            }\n        }\n        text.append('\\n');\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.PictureRenderPolicy.Helper.renderPicture",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.ParagraphAlignment.valueOf",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.PictureRenderPolicy.Helper.renderPicture" ],
    "fullMethods" : [ "public static void renderPicture(XWPFRun run, PictureRenderData picture) throws Exception {\n    byte[] imageBytes = picture.readPictureData();\n    if (null == imageBytes) {\n        throw new IllegalStateException(\"Can't read picture byte arrays!\");\n    }\n    PictureType pictureType = picture.getPictureType();\n    if (null == pictureType) {\n        pictureType = PictureType.suggestFileType(imageBytes);\n    }\n    if (null == pictureType) {\n        throw new RenderException(\"PictureRenderData must set picture type!\");\n    }\n    PictureStyle style = picture.getPictureStyle();\n    if (null == style)\n        style = new PictureStyle();\n\n    int width = style.getWidth();\n    int height = style.getHeight();\n    int svgScale = style.getSvgScale();\n    if (pictureType == PictureType.SVG) {\n        imageBytes = SVGConvertor.toPng(imageBytes, ((float) (width)), ((float) (height)), svgScale);\n        pictureType = PictureType.PNG;\n    }\n    if (!isSetSize(style)) {\n        BufferedImage original = BufferedImageUtils.readBufferedImage(imageBytes);\n        width = original.getWidth();\n        height = original.getHeight();\n        if (style.getScalePattern() == WidthScalePattern.FIT) {\n            BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n            int pageWidth = UnitUtils.twips2Pixel(bodyContainer.elementPageWidth(((IBodyElement) (run.getParent()))));\n            if (width > pageWidth) {\n                double ratio = pageWidth / ((double) (width));\n                width = pageWidth;\n                height = ((int) (height * ratio));\n            }\n        }\n    }\n    try (InputStream stream = new ByteArrayInputStream(imageBytes)) {\n        PictureAlign align = style.getAlign();\n        if ((null != align) && (run.getParent() instanceof XWPFParagraph)) {\n            ((XWPFParagraph) (run.getParent())).setAlignment(ParagraphAlignment.valueOf(align.ordinal() + 1));\n        }\n        run.addPicture(stream, pictureType.type(), \"Generated\", Units.pixelToEMU(width), Units.pixelToEMU(height));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CTPictWrapper.setImageData",
    "thirdPartyMethod" : "org.apache.commons.collections4.CollectionUtils.isNotEmpty",
    "thirdPartyPackage" : "org.apache.commons.collections4",
    "path" : [ "com.deepoove.poi.xwpf.CTPictWrapper.setImageData" ],
    "fullMethods" : [ "public void setImageData(String rid) {\n    if (CollectionUtils.isNotEmpty(ctShape.getImagedataList())) {\n        CTImageData imageData = ctShape.getImagedataArray(0);\n        imageData.setId2(rid);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements",
    "thirdPartyMethod" : "org.apache.commons.collections4.CollectionUtils.isNotEmpty",
    "thirdPartyPackage" : "org.apache.commons.collections4",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements", "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns", "com.deepoove.poi.resolver.TemplateResolver.resolvePictImage" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveBodyElements(List<IBodyElement> bodyElements) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (null == bodyElements)\n        return metaTemplates;\n\n    // current iterable templates state\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    for (IBodyElement element : bodyElements) {\n        if (element == null)\n            continue;\n\n        if (element.getElementType() == BodyElementType.PARAGRAPH) {\n            resolveParagraph(((XWPFParagraph) (element)), metaTemplates, stack);\n        } else if (element.getElementType() == BodyElementType.TABLE) {\n            XWPFTable table = ((XWPFTable) (element));\n            List<XWPFTableRow> rows = table.getRows();\n            if (null == rows)\n                continue;\n\n            for (XWPFTableRow row : rows) {\n                resolveTableRow(row, metaTemplates, stack);\n            }\n        } else if ((element.getElementType() == BodyElementType.CONTENTCONTROL) && (element instanceof XWPFStructuredDocumentTag)) {\n            XWPFStructuredDocumentTag sdt = ((XWPFStructuredDocumentTag) (element));\n            addNewMeta(metaTemplates, stack, resolveSDTElements(sdt.getContent()));\n        }\n    }\n    checkStack(stack);\n    return metaTemplates;\n}", "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}", "private PictImageTemplate resolvePictImage(XWPFRun run) {\n    CTR ctr = run.getCTR();\n    CTPicture ctPicture = (CollectionUtils.isNotEmpty(ctr.getPictList())) ? ctr.getPictArray(0) : null;\n    if (null == ctPicture)\n        return null;\n\n    CTPictWrapper wrapper = new CTPictWrapper(ctPicture);\n    return ((PictImageTemplate) (parseTemplateFactory(wrapper.getShapeAlt(), wrapper, run)));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFRunWrapper.<init>",
    "thirdPartyMethod" : "org.apache.commons.collections4.CollectionUtils.isNotEmpty",
    "thirdPartyPackage" : "org.apache.commons.collections4",
    "path" : [ "com.deepoove.poi.xwpf.XWPFRunWrapper.<init>" ],
    "fullMethods" : [ "@SuppressWarnings(\"deprecation\")\npublic XWPFRunWrapper(XWPFRun run, boolean isParse) {\n    this.run = run;\n    if (!isParse)\n        return;\n\n    CTR r = run.getCTR();\n    XmlObject[] xmlObjects = r.selectPath(XPATH_TXBX_TXBXCONTENT);\n    if ((xmlObjects != null) && (xmlObjects.length >= 1)) {\n        try {\n            CTTxbxContent ctTxbxContent = CTTxbxContent.Factory.parse(xmlObjects[0].xmlText());\n            wpstxbx = new XWPFTextboxContent(ctTxbxContent, run, run.getParagraph().getBody(), xmlObjects[0]);\n        } catch (XmlException e) {\n            // no-op\n        }\n    }\n    xmlObjects = r.selectPath(XPATH_TEXTBOX_TXBXCONTENT);\n    if ((xmlObjects != null) && (xmlObjects.length >= 1)) {\n        try {\n            CTTxbxContent ctTxbxContent = CTTxbxContent.Factory.parse(xmlObjects[0].xmlText());\n            vtextbox = new XWPFTextboxContent(ctTxbxContent, run, run.getParagraph().getBody(), xmlObjects[0]);\n        } catch (XmlException e) {\n            // no-op\n        }\n    }\n    CTPicture ctPicture = (CollectionUtils.isNotEmpty(r.getPictList())) ? r.getPictArray(0) : null;\n    if (null != ctPicture) {\n        xmlObjects = ctPicture.selectPath(XPATH_PICT_TEXTBOX_TXBXCONTENT);\n        if ((xmlObjects != null) && (xmlObjects.length >= 1)) {\n            try {\n                CTTxbxContent ctTxbxContent = null;\n                if (xmlObjects[0] instanceof CTTxbxContent) {\n                    ctTxbxContent = ((CTTxbxContent) (xmlObjects[0]));\n                } else {\n                    ctTxbxContent = CTTxbxContent.Factory.parse(xmlObjects[0].xmlText());\n                }\n                shapetxbx = new XWPFTextboxContent(ctTxbxContent, run, run.getParagraph().getBody(), xmlObjects[0]);\n            } catch (XmlException e) {\n                // no-op\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns",
    "thirdPartyMethod" : "org.apache.commons.collections4.CollectionUtils.isNotEmpty",
    "thirdPartyPackage" : "org.apache.commons.collections4",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns", "com.deepoove.poi.resolver.TemplateResolver.resolvePictImage" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveXWPFRuns(List<XWPFRun> runs) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (runs == null)\n        return metaTemplates;\n\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    resolveXWPFRuns(runs, metaTemplates, stack);\n    checkStack(stack);\n    return metaTemplates;\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}", "private PictImageTemplate resolvePictImage(XWPFRun run) {\n    CTR ctr = run.getCTR();\n    CTPicture ctPicture = (CollectionUtils.isNotEmpty(ctr.getPictList())) ? ctr.getPictArray(0) : null;\n    if (null == ctPicture)\n        return null;\n\n    CTPictWrapper wrapper = new CTPictWrapper(ctPicture);\n    return ((PictImageTemplate) (parseTemplateFactory(wrapper.getShapeAlt(), wrapper, run)));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ParagraphUtils.havePictures",
    "thirdPartyMethod" : "org.apache.commons.collections4.CollectionUtils.isNotEmpty",
    "thirdPartyPackage" : "org.apache.commons.collections4",
    "path" : [ "com.deepoove.poi.util.ParagraphUtils.havePictures" ],
    "fullMethods" : [ "public static boolean havePictures(XWPFParagraph paragraph) {\n    List<XWPFRun> runs = paragraph.getRuns();\n    for (XWPFRun run : runs) {\n        if (CollectionUtils.isNotEmpty(run.getEmbeddedPictures()))\n            return true;\n\n    }\n    return false;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ParagraphUtils.haveObject",
    "thirdPartyMethod" : "org.apache.commons.collections4.CollectionUtils.isNotEmpty",
    "thirdPartyPackage" : "org.apache.commons.collections4",
    "path" : [ "com.deepoove.poi.util.ParagraphUtils.haveObject" ],
    "fullMethods" : [ "public static boolean haveObject(XWPFParagraph paragraph) {\n    List<XWPFRun> runs = paragraph.getRuns();\n    for (XWPFRun run : runs) {\n        if (CollectionUtils.isNotEmpty(run.getCTR().getObjectList()))\n            return true;\n\n    }\n    return false;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.AbstractRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.commons.collections4.CollectionUtils.isNotEmpty",
    "thirdPartyPackage" : "org.apache.commons.collections4",
    "path" : [ "com.deepoove.poi.policy.AbstractRenderPolicy.render", "com.deepoove.poi.policy.NumberingRenderPolicy.validate", "com.deepoove.poi.policy.NumberingRenderPolicy.validate" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    T model = null;\n    try {\n        model = cast(data);\n    } catch (Exception e) {\n        throw new RenderException(\"Error Render Data format for template: \" + eleTemplate.getSource(), e);\n    }\n    RenderContext<T> context = new RenderContext<T>(eleTemplate, model, template);\n    try {\n        // validate\n        if (!validate(model)) {\n            postValidError(context);\n            return;\n        }\n        // do render\n        beforeRender(context);\n        doRender(context);\n        afterRender(context);\n    } catch (Exception e) {\n        reThrowException(context, e);\n    }\n}", "@Override\nprotected boolean validate(NumberingRenderData data) {\n    if (null == data)\n        return false;\n\n    return CollectionUtils.isNotEmpty(((NumberingRenderData) (data)).getItems());\n}", "@Override\nprotected boolean validate(NumberingRenderData data) {\n    if (null == data)\n        return false;\n\n    return CollectionUtils.isNotEmpty(((NumberingRenderData) (data)).getItems());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph",
    "thirdPartyMethod" : "org.apache.commons.collections4.CollectionUtils.isNotEmpty",
    "thirdPartyPackage" : "org.apache.commons.collections4",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns", "com.deepoove.poi.resolver.TemplateResolver.resolvePictImage" ],
    "fullMethods" : [ "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}", "private PictImageTemplate resolvePictImage(XWPFRun run) {\n    CTR ctr = run.getCTR();\n    CTPicture ctPicture = (CollectionUtils.isNotEmpty(ctr.getPictList())) ? ctr.getPictArray(0) : null;\n    if (null == ctPicture)\n        return null;\n\n    CTPictWrapper wrapper = new CTPictWrapper(ctPicture);\n    return ((PictImageTemplate) (parseTemplateFactory(wrapper.getShapeAlt(), wrapper, run)));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ParagraphUtils.havePageBreak",
    "thirdPartyMethod" : "org.apache.commons.collections4.CollectionUtils.isNotEmpty",
    "thirdPartyPackage" : "org.apache.commons.collections4",
    "path" : [ "com.deepoove.poi.util.ParagraphUtils.havePageBreak" ],
    "fullMethods" : [ "public static boolean havePageBreak(XWPFParagraph paragraph) {\n    List<XWPFRun> runs = paragraph.getRuns();\n    for (XWPFRun run : runs) {\n        if (CollectionUtils.isNotEmpty(run.getCTR().getLastRenderedPageBreakList()))\n            return true;\n\n    }\n    return false;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.compute.ReadMapAccessor.MapAccessException.<init>",
    "thirdPartyMethod" : "org.springframework.expression.AccessException.<init>",
    "thirdPartyPackage" : "org.springframework.expression",
    "path" : [ "com.deepoove.poi.render.compute.ReadMapAccessor.MapAccessException.<init>" ],
    "fullMethods" : [ "public MapAccessException(String key) {\n    super(\"\");\n    this.key = key;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblBorders.addNewInsideV",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.getUArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblBorders.isSetInsideV",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShapeProperties",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.isSetSpPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShapeProperties" ],
    "fullMethods" : [ "@Override\npublic void setShapeProperties(XDDFShapeProperties properties) {\n    if (properties == null) {\n        if (series.isSetSpPr()) {\n            series.unsetSpPr();\n        }\n    } else if (series.isSetSpPr()) {\n        series.setSpPr(properties.getXmlObject());\n    } else {\n        series.addNewSpPr().set(properties.getXmlObject());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.getShapeProperties",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.isSetSpPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.getShapeProperties" ],
    "fullMethods" : [ "@Override\npublic XDDFShapeProperties getShapeProperties() {\n    if (series.isSetSpPr()) {\n        return new XDDFShapeProperties(series.getSpPr());\n    } else {\n        return null;\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPBdr.isSetBottom",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPBdr.isSetBottom",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyle(XWPFParagraph paragraph) {\n    if (null == paragraph)\n        return null;\n\n    Builder builder = ParagraphStyle.builder();\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    if (paragraph.isWordWrapped()) {\n        builder.withAllowWordBreak(true);\n    }\n    if (pr.isSetPBdr()) {\n        CTPBdr ct = pr.getPBdr();\n        if (ct.isSetLeft()) {\n            builder.withLeftBorder(retriveBorderStyle(ct.getLeft()));\n        }\n        if (ct.isSetTop()) {\n            builder.withTopBorder(retriveBorderStyle(ct.getTop()));\n        }\n        if (ct.isSetRight()) {\n            builder.withRightBorder(retriveBorderStyle(ct.getRight()));\n        }\n        if (ct.isSetBottom()) {\n            builder.withBottomBorder(retriveBorderStyle(ct.getBottom()));\n        }\n    }\n    if (pr.isSetShd()) {\n        CTShd shd = pr.getShd();\n        builder.withShadingPattern(XWPFShadingPattern.valueOf(shd.getVal().intValue()));\n        if (shd.isSetFill())\n            builder.withBackgroundColor(shd.xgetFill().getStringValue());\n\n    }\n    builder.withAlign(paragraph.getAlignment());\n    int spacingBeforeLines = paragraph.getSpacingBeforeLines();\n    if ((-1) != spacingBeforeLines) {\n        builder.withSpacingBeforeLines(spacingBeforeLines / 100.0F);\n    }\n    int spacingAfterLines = paragraph.getSpacingAfterLines();\n    if ((-1) != spacingAfterLines) {\n        builder.withSpacingAfterLines(spacingAfterLines / 100.0F);\n    }\n    int spacingBefore = paragraph.getSpacingBefore();\n    if ((-1) != spacingBefore) {\n        builder.withSpacingBefore(UnitUtils.twips2Point(spacingBefore));\n    }\n    int spacingAfter = paragraph.getSpacingAfter();\n    if ((-1) != spacingAfter) {\n        builder.withSpacingAfter(UnitUtils.twips2Point(spacingAfter));\n    }\n    double spacingBetween = paragraph.getSpacingBetween();\n    if ((-1) != spacingBetween) {\n        builder.withSpacing(spacingBetween);\n        builder.withSpacingRule(paragraph.getSpacingLineRule());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.setSpacingBeforeLines",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableRow",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTrPr.sizeOfCantSplitArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableRow" ],
    "fullMethods" : [ "/**\n * set row style\n *\n * @param row\n * @param rowStyle\n */\npublic static void styleTableRow(XWPFTableRow row, RowStyle rowStyle) {\n    if ((null == row) || (null == rowStyle))\n        return;\n\n    int height = rowStyle.getHeight();\n    CTRow ctRow = row.getCtRow();\n    CTTrPr properties = (ctRow.isSetTrPr()) ? ctRow.getTrPr() : ctRow.addNewTrPr();\n    if (0 != height) {\n        row.setHeight(height);\n        CTHeight h = (properties.sizeOfTrHeightArray() == 0) ? properties.addNewTrHeight() : properties.getTrHeightArray(0);\n        String heightRule = rowStyle.getHeightRule();\n        if (\"exact\".equals(heightRule))\n            h.setHRule(STHeightRule.EXACT);\n        else if (\"atleast\".equals(heightRule))\n            h.setHRule(STHeightRule.AT_LEAST);\n        else\n            h.setHRule(STHeightRule.AUTO);\n\n    }\n    boolean repeated = rowStyle.isRepeated();\n    if (repeated) {\n        CTOnOff tblHeader = (properties.sizeOfTblHeaderArray() == 0) ? properties.addNewTblHeader() : properties.getTblHeaderArray(0);\n        tblHeader.setVal(XWPFOnOff.ON);\n    }\n    boolean breakAcrossPage = rowStyle.isBreakAcrossPage();\n    if (!breakAcrossPage) {\n        if (properties.sizeOfCantSplitArray() == 0) {\n            properties.addNewCantSplit();\n        } else {\n            properties.getCantSplitArray(0).setVal(XWPFOnOff.ON);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPrBase.isSetInd",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId" ],
    "fullMethods" : [ "public BigInteger addNewMultiLevelNumberingId(NumberingFormat... numFmts) {\n    XWPFNumbering numbering = this.getNumbering();\n    if (null == numbering) {\n        numbering = this.createNumbering();\n    }\n    XWPFNumberingWrapper numberingWrapper = new XWPFNumberingWrapper(numbering);\n    CTAbstractNum cTAbstractNum = CTAbstractNum.Factory.newInstance();\n    // if we have an existing document, we must determine the next\n    // free number first.\n    cTAbstractNum.setAbstractNumId(numberingWrapper.getNextAbstractNumID());\n    // CTMultiLevelType addNewMultiLevelType = cTAbstractNum.addNewMultiLevelType();\n    // addNewMultiLevelType.setVal(STMultiLevelType.HYBRID_MULTILEVEL);\n    for (int i = 0; i < numFmts.length; i++) {\n        NumberingFormat numFmt = numFmts[i];\n        CTLvl cTLvl = cTAbstractNum.addNewLvl();\n        CTPPrBase ppr = (cTLvl.isSetPPr()) ? cTLvl.getPPr() : cTLvl.addNewPPr();\n        CTInd ind = (ppr.isSetInd()) ? ppr.getInd() : ppr.addNewInd();\n        ind.setLeft(BigInteger.valueOf(UnitUtils.cm2Twips(0.74F) * i));\n        Enum fmt = STNumberFormat.Enum.forInt(numFmt.getNumFmt());\n        String val = numFmt.getLvlText();\n        cTLvl.addNewNumFmt().setVal(fmt);\n        cTLvl.addNewLvlText().setVal(val);\n        cTLvl.addNewStart().setVal(BigInteger.valueOf(1));\n        cTLvl.setIlvl(BigInteger.valueOf(i));\n        if (fmt == STNumberFormat.BULLET) {\n            cTLvl.addNewLvlJc().setVal(STJc.LEFT);\n            CTRPr addNewRPr = cTLvl.addNewRPr();\n            CTFonts ctFonts = addNewRPr.addNewRFonts();\n            ctFonts.setAscii(\"Wingdings\");\n            ctFonts.setHAnsi(\"Wingdings\");\n            ctFonts.setHint(STHint.DEFAULT);\n        }\n    }\n    XWPFAbstractNum abstractNum = new XWPFAbstractNum(cTAbstractNum);\n    BigInteger abstractNumID = numbering.addAbstractNum(abstractNum);\n    return numbering.addNum(abstractNumID);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShowLeaderLines",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTDLbls.isSetShowLeaderLines",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShowLeaderLines" ],
    "fullMethods" : [ "@Override\npublic void setShowLeaderLines(boolean showLeaderLines) {\n    if (!series.isSetDLbls()) {\n        series.addNewDLbls();\n    }\n    if (series.getDLbls().isSetShowLeaderLines()) {\n        series.getDLbls().getShowLeaderLines().setVal(showLeaderLines);\n    } else {\n        series.getDLbls().addNewShowLeaderLines().setVal(showLeaderLines);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblBorders.isSetBottom",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShapeProperties",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.setSpPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShapeProperties" ],
    "fullMethods" : [ "@Override\npublic void setShapeProperties(XDDFShapeProperties properties) {\n    if (properties == null) {\n        if (series.isSetSpPr()) {\n            series.unsetSpPr();\n        }\n    } else if (series.isSetSpPr()) {\n        series.setSpPr(properties.getXmlObject());\n    } else {\n        series.addNewSpPr().set(properties.getXmlObject());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.getTblLayout",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblPr.addNewTblLayout",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.getTblLayout" ],
    "fullMethods" : [ "public static CTTblLayoutType getTblLayout(XWPFTable table) {\n    CTTblPr tblPr = getTblPr(table);\n    return tblPr.isSetTblLayout() ? tblPr.getTblLayout() : tblPr.addNewTblLayout();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.sizeOfIArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>",
    "thirdPartyMethod" : "org.apache.poi.xddf.usermodel.chart.XDDFDataSourcesFactory.fromDataSource",
    "thirdPartyPackage" : "org.apache.poi.xddf.usermodel.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>", "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.<init>" ],
    "fullMethods" : [ "public XDDFOfPieChartData(XDDFChart parent, CTOfPieChart chart) {\n    super(parent);\n    this.chart = chart;\n    this.seriesNum = parent.getChartSeries().size();\n    for (CTPieSer series : chart.getSerList()) {\n        this.series.add(new Series(series, series.getCat(), series.getVal()));\n    }\n}", "protected Series(CTPieSer series, XDDFDataSource<?> category, XDDFNumericalDataSource<? extends Number> values) {\n    super(category, values);\n    this.series = series;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTAxDataSource.isSetNumRef",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.plot" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartMultiSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    List<XDDFChartData> chartSeries = chart.getChartSeries();\n    validate(chartSeries, data);\n    int totalSeriesCount = ensureSeriesCount(chart, chartSeries);\n    int valueCol = 1;\n    List<SeriesRenderData> usedSeriesDatas = new ArrayList<>();\n    for (XDDFChartData chartData : chartSeries) {\n        int orignSize = chartData.getSeriesCount();\n        List<SeriesRenderData> currentSeriesData = null;\n        if (chartSeries.size() <= 1) {\n            // ignore combo type\n            currentSeriesData = data.getSeriesDatas();\n        } else {\n            currentSeriesData = obtainSeriesData(chartData.getClass(), data.getSeriesDatas());\n        }\n        usedSeriesDatas.addAll(currentSeriesData);\n        int currentSeriesSize = currentSeriesData.size();\n        XDDFDataSource<?> categoriesData = null;\n        if (chartData instanceof XDDFScatterChartData) {\n            categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n        } else {\n            categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n        }\n        for (int i = 0; i < currentSeriesSize; i++) {\n            XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, currentSeriesData.get(i).getValues(), valueCol);\n            XDDFChartData.Series currentSeries = null;\n            if (i < orignSize) {\n                currentSeries = chartData.getSeries(i);\n                valuesData.setFormatCode(currentSeries.getValuesData().getFormatCode());\n                currentSeries.replaceData(categoriesData, valuesData);\n            } else {\n                // add series, should copy series with style\n                currentSeries = chartData.addSeries(categoriesData, valuesData);\n                processNewSeries(chartData, currentSeries);\n            }\n            String name = currentSeriesData.get(i).getName();\n            currentSeries.setTitle(name, chart.setSheetTitle(name, valueCol));\n            valueCol++;\n        }\n        // clear extra series\n        removeExtraSeries(chartData, orignSize, currentSeriesSize);\n    }\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    updateCTTable(sheet, usedSeriesDatas);\n    removeExtraSheetCell(sheet, data.getCategories().length, totalSeriesCount, usedSeriesDatas.size());\n    for (XDDFChartData chartData : chartSeries) {\n        plot(chart, chartData);\n    }\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "@SuppressWarnings(\"deprecation\")\nprotected void plot(XWPFChart chart, XDDFChartData data) throws Exception {\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    Method method = XDDFChart.class.getDeclaredMethod(\"fillSheet\", XSSFSheet.class, XDDFDataSource.class, XDDFNumericalDataSource.class);\n    method.setAccessible(true);\n    for (XDDFChartData.Series series : data.getSeries()) {\n        boolean numeric = series.getCategoryData().isNumeric();\n        if (!numeric) {\n            Method getAxDSMethod = series.getClass().getDeclaredMethod(\"getAxDS\");\n            getAxDSMethod.setAccessible(true);\n            CTAxDataSource axDataSource = ((CTAxDataSource) (getAxDSMethod.invoke(series)));\n            if (axDataSource.isSetNumRef()) {\n                axDataSource.unsetNumRef();\n            }\n            if (axDataSource.isSetNumLit()) {\n                axDataSource.unsetNumLit();\n            }\n        }\n        series.plot();\n        method.invoke(chart, sheet, series.getCategoryData(), series.getValuesData());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTAxDataSource.isSetNumRef",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.plot" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartSingleSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    XDDFChartData pie = ChartUtils.getChartSeries(chart).get(0);\n    SeriesRenderData seriesDatas = data.getSeriesData();\n    XDDFDataSource<?> categoriesData = null;\n    if (pie instanceof XDDFScatterChartData) {\n        categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n    } else {\n        categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n    }\n    XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, seriesDatas.getValues(), 1);\n    XDDFChartData.Series currentSeries = pie.getSeries(0);\n    currentSeries.replaceData(categoriesData, valuesData);\n    currentSeries.setTitle(seriesDatas.getName(), chart.setSheetTitle(seriesDatas.getName(), 1));\n    updateCTTable(chart.getWorkbook().getSheetAt(0), Arrays.asList(seriesDatas));\n    plot(chart, pie);\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "@SuppressWarnings(\"deprecation\")\nprotected void plot(XWPFChart chart, XDDFChartData data) throws Exception {\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    Method method = XDDFChart.class.getDeclaredMethod(\"fillSheet\", XSSFSheet.class, XDDFDataSource.class, XDDFNumericalDataSource.class);\n    method.setAccessible(true);\n    for (XDDFChartData.Series series : data.getSeries()) {\n        boolean numeric = series.getCategoryData().isNumeric();\n        if (!numeric) {\n            Method getAxDSMethod = series.getClass().getDeclaredMethod(\"getAxDS\");\n            getAxDSMethod.setAccessible(true);\n            CTAxDataSource axDataSource = ((CTAxDataSource) (getAxDSMethod.invoke(series)));\n            if (axDataSource.isSetNumRef()) {\n                axDataSource.unsetNumRef();\n            }\n            if (axDataSource.isSetNumLit()) {\n                axDataSource.unsetNumLit();\n            }\n        }\n        series.plot();\n        method.invoke(chart, sheet, series.getCategoryData(), series.getValuesData());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTAxDataSource.unsetNumLit",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.plot" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartMultiSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    List<XDDFChartData> chartSeries = chart.getChartSeries();\n    validate(chartSeries, data);\n    int totalSeriesCount = ensureSeriesCount(chart, chartSeries);\n    int valueCol = 1;\n    List<SeriesRenderData> usedSeriesDatas = new ArrayList<>();\n    for (XDDFChartData chartData : chartSeries) {\n        int orignSize = chartData.getSeriesCount();\n        List<SeriesRenderData> currentSeriesData = null;\n        if (chartSeries.size() <= 1) {\n            // ignore combo type\n            currentSeriesData = data.getSeriesDatas();\n        } else {\n            currentSeriesData = obtainSeriesData(chartData.getClass(), data.getSeriesDatas());\n        }\n        usedSeriesDatas.addAll(currentSeriesData);\n        int currentSeriesSize = currentSeriesData.size();\n        XDDFDataSource<?> categoriesData = null;\n        if (chartData instanceof XDDFScatterChartData) {\n            categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n        } else {\n            categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n        }\n        for (int i = 0; i < currentSeriesSize; i++) {\n            XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, currentSeriesData.get(i).getValues(), valueCol);\n            XDDFChartData.Series currentSeries = null;\n            if (i < orignSize) {\n                currentSeries = chartData.getSeries(i);\n                valuesData.setFormatCode(currentSeries.getValuesData().getFormatCode());\n                currentSeries.replaceData(categoriesData, valuesData);\n            } else {\n                // add series, should copy series with style\n                currentSeries = chartData.addSeries(categoriesData, valuesData);\n                processNewSeries(chartData, currentSeries);\n            }\n            String name = currentSeriesData.get(i).getName();\n            currentSeries.setTitle(name, chart.setSheetTitle(name, valueCol));\n            valueCol++;\n        }\n        // clear extra series\n        removeExtraSeries(chartData, orignSize, currentSeriesSize);\n    }\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    updateCTTable(sheet, usedSeriesDatas);\n    removeExtraSheetCell(sheet, data.getCategories().length, totalSeriesCount, usedSeriesDatas.size());\n    for (XDDFChartData chartData : chartSeries) {\n        plot(chart, chartData);\n    }\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "@SuppressWarnings(\"deprecation\")\nprotected void plot(XWPFChart chart, XDDFChartData data) throws Exception {\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    Method method = XDDFChart.class.getDeclaredMethod(\"fillSheet\", XSSFSheet.class, XDDFDataSource.class, XDDFNumericalDataSource.class);\n    method.setAccessible(true);\n    for (XDDFChartData.Series series : data.getSeries()) {\n        boolean numeric = series.getCategoryData().isNumeric();\n        if (!numeric) {\n            Method getAxDSMethod = series.getClass().getDeclaredMethod(\"getAxDS\");\n            getAxDSMethod.setAccessible(true);\n            CTAxDataSource axDataSource = ((CTAxDataSource) (getAxDSMethod.invoke(series)));\n            if (axDataSource.isSetNumRef()) {\n                axDataSource.unsetNumRef();\n            }\n            if (axDataSource.isSetNumLit()) {\n                axDataSource.unsetNumLit();\n            }\n        }\n        series.plot();\n        method.invoke(chart, sheet, series.getCategoryData(), series.getValuesData());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTAxDataSource.unsetNumLit",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.plot" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartSingleSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    XDDFChartData pie = ChartUtils.getChartSeries(chart).get(0);\n    SeriesRenderData seriesDatas = data.getSeriesData();\n    XDDFDataSource<?> categoriesData = null;\n    if (pie instanceof XDDFScatterChartData) {\n        categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n    } else {\n        categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n    }\n    XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, seriesDatas.getValues(), 1);\n    XDDFChartData.Series currentSeries = pie.getSeries(0);\n    currentSeries.replaceData(categoriesData, valuesData);\n    currentSeries.setTitle(seriesDatas.getName(), chart.setSheetTitle(seriesDatas.getName(), 1));\n    updateCTTable(chart.getWorkbook().getSheetAt(0), Arrays.asList(seriesDatas));\n    plot(chart, pie);\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "@SuppressWarnings(\"deprecation\")\nprotected void plot(XWPFChart chart, XDDFChartData data) throws Exception {\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    Method method = XDDFChart.class.getDeclaredMethod(\"fillSheet\", XSSFSheet.class, XDDFDataSource.class, XDDFNumericalDataSource.class);\n    method.setAccessible(true);\n    for (XDDFChartData.Series series : data.getSeries()) {\n        boolean numeric = series.getCategoryData().isNumeric();\n        if (!numeric) {\n            Method getAxDSMethod = series.getClass().getDeclaredMethod(\"getAxDS\");\n            getAxDSMethod.setAccessible(true);\n            CTAxDataSource axDataSource = ((CTAxDataSource) (getAxDSMethod.invoke(series)));\n            if (axDataSource.isSetNumRef()) {\n                axDataSource.unsetNumRef();\n            }\n            if (axDataSource.isSetNumLit()) {\n                axDataSource.unsetNumLit();\n            }\n        }\n        series.plot();\n        method.invoke(chart, sheet, series.getCategoryData(), series.getValuesData());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFFootnotes.addFootnote",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableString", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeFootnote" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "protected String createMergeableString(NiceXWPFDocument source, NiceXWPFDocument merged, Map<String, String> styleIdsMap) throws InvalidFormatException, IOException {\n    CTBody mergedBody = merged.getDocument().getBody();\n    // TODO For the same style, reduce the number of merges\n    // Map<String, String> styleIdsMap = mergeStyles(docMerge);\n    Map<String, String> numIdsMap = mergeNumbering(source, merged);\n    Map<String, String> blipIdsMap = mergePicture(source, merged);\n    Map<String, String> externalBlipIdsMap = mergeExternalPicture(source, merged);\n    Map<String, String> hyperlinkMap = mergeHyperlink(source, merged);\n    Map<String, String> chartIdsMap = mergeChart(source, merged);\n    Map<String, String> attachmentIdsMap = mergeAttachment(source, merged);\n    Map<String, String> footnoteIdsMap = mergeFootnote(source, merged);\n    Map<String, String> endnoteIdsMap = mergeEndnote(source, merged);\n    String appendString = mergedBody.xmlText(DefaultXmlOptions.OPTIONS_OUTER);\n    String addPart = ridSectPr(appendString);\n    // style\n    for (String styleId : styleIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:pStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:pStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:tblStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:tblStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:rStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:rStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\");\n    }\n    // picture id\n    Map<String, String> placeHolderblipIdsMap = new HashMap<String, String>();\n    for (String relaId : blipIdsMap.keySet()) {\n        placeHolderblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:embed=\\\"\" + relaId) + \"\\\"\", (\"r:embed=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n        // w:pict v:shape v:imagedata\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    Map<String, String> placeHolderExternalblipIdsMap = new HashMap<String, String>();\n    for (String relaId : externalBlipIdsMap.keySet()) {\n        placeHolderExternalblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderExternalblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:link=\\\"\" + relaId) + \"\\\"\", (\"r:link=\\\"\" + placeHolderExternalblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // hyperlink id\n    for (String relaId : hyperlinkMap.keySet()) {\n        hyperlinkMap.put(relaId, hyperlinkMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : hyperlinkMap.keySet()) {\n        // w:hyperlink r:id\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + hyperlinkMap.get(relaId)) + \"\\\"\");\n    }\n    // chart id\n    for (String relaId : chartIdsMap.keySet()) {\n        chartIdsMap.put(relaId, chartIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : chartIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + chartIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // attachment id\n    for (String relaId : attachmentIdsMap.keySet()) {\n        attachmentIdsMap.put(relaId, attachmentIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : attachmentIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + attachmentIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // footnote id\n    for (String relaId : footnoteIdsMap.keySet()) {\n        footnoteIdsMap.put(relaId, footnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : footnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"footnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"footnoteReference w:id=\\\"\" + footnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // endnote id\n    for (String relaId : endnoteIdsMap.keySet()) {\n        endnoteIdsMap.put(relaId, endnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : endnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"endnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"endnoteReference w:id=\\\"\" + endnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // numbering numId\n    for (String relaId : numIdsMap.keySet()) {\n        numIdsMap.put(relaId, numIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String numId : numIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:numId\\\\sw:val=\\\"\" + numId) + \"\\\"\", (\"<w:numId w:val=\\\"\" + numIdsMap.get(numId)) + \"\\\"\");\n    }\n    return addPart.replaceAll(CROSS_REPLACE_STRING, \"\");\n}", "protected Map<String, String> mergeFootnote(NiceXWPFDocument source, NiceXWPFDocument merged) {\n    Map<String, String> blipIdsMap = new HashMap<>();\n    FootnoteEndnoteIdManager footnoteEndnoteIdManager = new FootnoteEndnoteIdManager(source);\n    List<XWPFFootnote> footnotes = merged.getFootnotes();\n    if (!footnotes.isEmpty()) {\n        XWPFFootnotes sourceFootnotes = source.createFootnotes();\n        for (XWPFFootnote footnote : footnotes) {\n            String relationId = footnote.getId().toString();\n            footnote.getCTFtnEdn().setId(footnoteEndnoteIdManager.nextId());\n            sourceFootnotes.addFootnote(footnote);\n            String blidId = footnote.getId().toString();\n            blipIdsMap.put(relationId, blidId);\n        }\n    }\n    return blipIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.SDTContentContext.createRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.SDTContentContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XWPFRun xwpfRun, IRunBody p) {\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink().copy())), ((CTR) (((XWPFHyperlinkRun) (xwpfRun)).getCTR().copy())), p);\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        return new XWPFFieldRun(((CTSimpleField) (((XWPFFieldRun) (xwpfRun)).getCTField().copy())), ((CTR) (((XWPFFieldRun) (xwpfRun)).getCTR().copy())), p);\n    } else {\n        return new XWPFRun(((CTR) (xwpfRun.getCTR().copy())), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.setAndUpdateRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.setAndUpdateRun" ],
    "fullMethods" : [ "public void setAndUpdateRun(XWPFRun xwpfRun, XWPFRun source, int insertPostionCursor) {\n    // body\n    // maybe need find correct position:rPos;\n    int rPos = 0;\n    List<XWPFRun> runs = getRuns();\n    if ((insertPostionCursor >= 0) && (insertPostionCursor <= runs.size())) {\n        // calculate the correct pos as our run/irun list contains\n        // hyperlinks\n        // and fields so it is different to the paragraph R array.\n        for (int i = 0; i < insertPostionCursor; i++) {\n            XWPFRun currRun = runs.get(i);\n            if (xwpfRun instanceof XWPFHyperlinkRun) {\n                if (currRun instanceof XWPFHyperlinkRun) {\n                    rPos++;\n                }\n            } else if (xwpfRun instanceof XWPFFieldRun) {\n                if (currRun instanceof XWPFFieldRun) {\n                    rPos++;\n                }\n            } else if (!((currRun instanceof XWPFHyperlinkRun) || (currRun instanceof XWPFFieldRun))) {\n                rPos++;\n            }\n        }\n    }\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        paragraph.getCTP().setHyperlinkArray(rPos, ((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink());\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        paragraph.getCTP().setFldSimpleArray(rPos, ((XWPFFieldRun) (xwpfRun)).getCTField());\n    } else {\n        paragraph.getCTP().setRArray(rPos, xwpfRun.getCTR());\n    }\n    // runs\n    for (int i = 0; i < runs.size(); i++) {\n        XWPFRun ele = runs.get(i);\n        if (ele == source) {\n            runs.set(i, xwpfRun);\n        }\n    }\n    // iruns\n    List<IRunElement> iruns = getIRuns();\n    for (int i = 0; i < iruns.size(); i++) {\n        IRunElement ele = iruns.get(i);\n        if (ele == source) {\n            iruns.set(i, xwpfRun);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFRunWrapper.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFRunWrapper.<init>" ],
    "fullMethods" : [ "@SuppressWarnings(\"deprecation\")\npublic XWPFRunWrapper(XWPFRun run, boolean isParse) {\n    this.run = run;\n    if (!isParse)\n        return;\n\n    CTR r = run.getCTR();\n    XmlObject[] xmlObjects = r.selectPath(XPATH_TXBX_TXBXCONTENT);\n    if ((xmlObjects != null) && (xmlObjects.length >= 1)) {\n        try {\n            CTTxbxContent ctTxbxContent = CTTxbxContent.Factory.parse(xmlObjects[0].xmlText());\n            wpstxbx = new XWPFTextboxContent(ctTxbxContent, run, run.getParagraph().getBody(), xmlObjects[0]);\n        } catch (XmlException e) {\n            // no-op\n        }\n    }\n    xmlObjects = r.selectPath(XPATH_TEXTBOX_TXBXCONTENT);\n    if ((xmlObjects != null) && (xmlObjects.length >= 1)) {\n        try {\n            CTTxbxContent ctTxbxContent = CTTxbxContent.Factory.parse(xmlObjects[0].xmlText());\n            vtextbox = new XWPFTextboxContent(ctTxbxContent, run, run.getParagraph().getBody(), xmlObjects[0]);\n        } catch (XmlException e) {\n            // no-op\n        }\n    }\n    CTPicture ctPicture = (CollectionUtils.isNotEmpty(r.getPictList())) ? r.getPictArray(0) : null;\n    if (null != ctPicture) {\n        xmlObjects = ctPicture.selectPath(XPATH_PICT_TEXTBOX_TXBXCONTENT);\n        if ((xmlObjects != null) && (xmlObjects.length >= 1)) {\n            try {\n                CTTxbxContent ctTxbxContent = null;\n                if (xmlObjects[0] instanceof CTTxbxContent) {\n                    ctTxbxContent = ((CTTxbxContent) (xmlObjects[0]));\n                } else {\n                    ctTxbxContent = CTTxbxContent.Factory.parse(xmlObjects[0].xmlText());\n                }\n                shapetxbx = new XWPFTextboxContent(ctTxbxContent, run, run.getParagraph().getBody(), xmlObjects[0]);\n            } catch (XmlException e) {\n                // no-op\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.setAndUpdateRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.setAndUpdateRun" ],
    "fullMethods" : [ "public void setAndUpdateRun(XWPFRun xwpfRun, XWPFRun source, int insertPostionCursor) {\n    // body\n    // maybe need find correct position:rPos;\n    int rPos = 0;\n    if ((insertPostionCursor >= 0) && (insertPostionCursor <= runs.size())) {\n        // calculate the correct pos as our run/irun list contains\n        // hyperlinks\n        // and fields so it is different to the paragraph R array.\n        for (int i = 0; i < insertPostionCursor; i++) {\n            XWPFRun currRun = runs.get(i);\n            if (!((currRun instanceof XWPFHyperlinkRun) || (currRun instanceof XWPFFieldRun))) {\n                rPos++;\n            }\n        }\n    }\n    sdtContentRun.setRArray(rPos, xwpfRun.getCTR());\n    // runs\n    for (int i = 0; i < runs.size(); i++) {\n        XWPFRun ele = runs.get(i);\n        if (ele == source) {\n            runs.set(i, xwpfRun);\n        }\n    }\n    // iruns\n    List<ISDTContents> iruns = getSdtElements();\n    for (int i = 0; i < iruns.size(); i++) {\n        ISDTContents ele = iruns.get(i);\n        if (ele == source) {\n            iruns.set(i, xwpfRun);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns", "com.deepoove.poi.resolver.TemplateResolver.resolvePictImage" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveXWPFRuns(List<XWPFRun> runs) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (runs == null)\n        return metaTemplates;\n\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    resolveXWPFRuns(runs, metaTemplates, stack);\n    checkStack(stack);\n    return metaTemplates;\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}", "private PictImageTemplate resolvePictImage(XWPFRun run) {\n    CTR ctr = run.getCTR();\n    CTPicture ctPicture = (CollectionUtils.isNotEmpty(ctr.getPictList())) ? ctr.getPictArray(0) : null;\n    if (null == ctPicture)\n        return null;\n\n    CTPictWrapper wrapper = new CTPictWrapper(ctPicture);\n    return ((PictImageTemplate) (parseTemplateFactory(wrapper.getShapeAlt(), wrapper, run)));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.AttachmentRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.AttachmentRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(RenderContext<AttachmentRenderData> context) throws Exception {\n    NiceXWPFDocument doc = context.getXWPFDocument();\n    XWPFRun run = context.getRun();\n    CTR ctr = run.getCTR();\n    // Only one shapetype is needed\n    String shapeTypeXml = \"\";\n    if (!haveShapeType) {\n        haveShapeType = true;\n        shapeTypeXml = SHAPE_TYPE_XML;\n    }\n    String uuidRandom = UUID.randomUUID().toString().replace(\"-\", \"\") + ThreadLocalRandom.current().nextInt(1024);\n    String shapeId = \"_x0000_i20\" + uuidRandom;\n    AttachmentRenderData data = context.getData();\n    AttachmentType fileType = data.getFileType();\n    byte[] attachment = data.readAttachmentData();\n    PictureRenderData icon = data.getIcon();\n    if (null == icon) {\n        icon = Pictures.ofBase64(fileType.icon(), PictureType.PNG).size(64, 64).create();\n    }\n    byte[] image = icon.readPictureData();\n    PictureType pictureType = icon.getPictureType();\n    if (null == pictureType) {\n        pictureType = PictureType.suggestFileType(image);\n    }\n    PictureStyle style = icon.getPictureStyle();\n    if (null == style)\n        style = new PictureStyle();\n\n    double widthPt = Units.pixelToPoints(style.getWidth());\n    double heightPt = Units.pixelToPoints(style.getHeight());\n    String imageRId = doc.addPictureData(image, pictureType.type());\n    // String embeddId = doc.addEmbeddData(attachment, fileType.ordinal());\n    String embeddId = doc.addEmbeddData(attachment, fileType.contentType(), (\"/word/embeddings/\" + uuidRandom) + fileType.ext());\n    String wObjectXml = (((((((((((((((((((((((((((((\"<w:object xmlns:w=\\\"http://schemas.openxmlformats.org/wordprocessingml/2006/main\\\"\" + \"             xmlns:v=\\\"urn:schemas-microsoft-com:vml\\\"\") + \"             xmlns:o=\\\"urn:schemas-microsoft-com:office:office\\\"\") + \"             xmlns:r=\\\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\\\"\") + \"             w:dxaOrig=\\\"1520\\\" w:dyaOrig=\\\"960\\\">\\n\") + shapeTypeXml) + \"                    <v:shape id=\\\"\") + shapeId) + \"\\\" type=\\\"#\") + SHAPE_TYPE_ID) + \"\\\" alt=\\\"\\\" style=\\\"width:\") + widthPt) + \"pt;height:\") + heightPt) + \"pt;mso-width-percent:0;mso-height-percent:0;mso-width-percent:0;mso-height-percent:0\\\" o:ole=\\\"\\\">\\n\") + \"                        <v:imagedata r:id=\\\"\") + imageRId) + \"\\\" o:title=\\\"\\\"/>\\n\") + \"                    </v:shape>\\n\") + \"                    <o:OLEObject Type=\\\"Embed\\\" ProgID=\\\"\") + fileType.programId()) + \"\\\" ShapeID=\\\"\") + shapeId) + \"\\\" DrawAspect=\\\"Icon\\\" ObjectID=\\\"\") + shapeId) + \"\\\" r:id=\\\"\") + embeddId) + \"\\\">\\n\") + \"                     <o:FieldCodes>\\\\s</o:FieldCodes>\\n\") + \"                    </o:OLEObject>\") + \"            </w:object>\";\n    Document document = DocumentHelper.readDocument(new InputSource(new StringReader(wObjectXml)));\n    ctr.set(XmlObject.Factory.parse(document.getDocumentElement(), POIXMLTypeLoader.DEFAULT_XML_OPTIONS));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.<init>", "com.deepoove.poi.resolver.RunningRunBody.refactorBody" ],
    "fullMethods" : [ "public RunningRunBody(RunBodyContext context, Pattern pattern) {\n    this.runBodyContext = context;\n    this.runs = context.getRuns();\n    if ((null == runs) || runs.isEmpty())\n        return;\n\n    Matcher matcher = pattern.matcher(getText(context));\n    if (matcher.find()) {\n        refactorBody();\n    }\n    buildRunEdge(pattern);\n}", "private void refactorBody() {\n    for (int i = runs.size() - 1; i >= 0; i--) {\n        XWPFRun xwpfRun = runs.get(i);\n        CTR ctr = xwpfRun.getCTR();\n        CTRImpl ctrimpl = ((CTRImpl) (ctr));\n        int sizeOfBrArray = ctr.sizeOfBrArray();\n        int sizeOfCrArray = ctr.sizeOfCrArray();\n        int sizeOfTabArray = ctr.sizeOfTabArray();\n        if (((sizeOfBrArray + sizeOfCrArray) + sizeOfTabArray) > 0) {\n            synchronized(ctrimpl.monitor()) {\n                // ctrimpl.check_orphaned();\n                List<? extends XmlObject> localArrayList = new ArrayList<XmlObject>();\n                ctrimpl.get_store().find_all_element_users(qname, localArrayList);\n                int size = localArrayList.size();\n                for (int j = size - 1; j >= 0; j--) {\n                    Object obj = localArrayList.get(j);\n                    if (obj instanceof CTEmpty) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        String tagName = ((CTEmpty) (obj)).getDomNode().getNodeName();\n                        if (\"w:br\".equals(tagName) || \"br\".equals(tagName)) {\n                            insertNewRun.addBreak();\n                        }\n                        if (\"w:cr\".equals(tagName) || \"cr\".equals(tagName)) {\n                            insertNewRun.addCarriageReturn();\n                        }\n                        if (\"w:tab\".equals(tagName) || \"tab\".equals(tagName)) {\n                            insertNewRun.addTab();\n                        }\n                    } else if (obj instanceof CTBr) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        CTBr addNewBr = insertNewRun.getCTR().addNewBr();\n                        if (null != ((CTBr) (obj)).getType())\n                            addNewBr.setType(((CTBr) (obj)).getType());\n\n                        if (null != ((CTBr) (obj)).getClear())\n                            addNewBr.setClear(((CTBr) (obj)).getClear());\n\n                    } else if (obj instanceof CTText) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        StyleUtils.styleRun(insertNewRun, xwpfRun);\n                        insertNewRun.setText(((CTText) (obj)).getStringValue());\n                    }\n                }\n                runBodyContext.removeRun(i);\n            }\n        }\n    }\n    this.runs = runBodyContext.getRuns();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ParagraphUtils.haveObject",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.ParagraphUtils.haveObject" ],
    "fullMethods" : [ "public static boolean haveObject(XWPFParagraph paragraph) {\n    List<XWPFRun> runs = paragraph.getRuns();\n    for (XWPFRun run : runs) {\n        if (CollectionUtils.isNotEmpty(run.getCTR().getObjectList()))\n            return true;\n\n    }\n    return false;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment" ],
    "fullMethods" : [ "public static void renderComment(XWPFRun run, CommentRenderData data) throws Exception {\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper parentContext = new XWPFParagraphWrapper(paragraph);\n    BigInteger cId = BigInteger.ZERO;\n    CommentContent commentContent = data.getCommentContent();\n    if (null != commentContent) {\n        XWPFComments comments = ((NiceXWPFDocument) (paragraph.getDocument())).createComments();\n        XWPFComment newComment = comments.createComment(NextIDUtils.getCommentMaxId(comments).add(BigInteger.ONE));\n        newComment.setAuthor(commentContent.getAuthor());\n        newComment.setDate(commentContent.getDate());\n        newComment.setInitials(commentContent.getInitials());\n        renderDocument(newComment.createParagraph().createRun(), commentContent.getContent());\n        cId = newComment.getCtComment().getId();\n        parentContext.insertNewCommentRangeStart(run, cId);\n    }\n    renderParagraph(run, Paragraphs.of().addList(data.getContents()).create());\n    if (null != commentContent) {\n        parentContext.insertNewCommentRangeEnd(run, cId);\n        XWPFRun newRun = parentContext.insertNewRun(ParagraphUtils.getRunPos(run));\n        newRun.getCTR().addNewCommentReference().setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewRunAfter",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewRunAfter" ],
    "fullMethods" : [ "public XWPFRun insertNewRunAfter(int pos) {\n    if (pos == runs.size()) {\n        return createRun();\n    }\n    if ((pos >= 0) && (pos < runs.size())) {\n        XWPFRun run = runs.get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInRunContent(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInRunContent(newCursor)) {\n            boolean nextSibling = newCursor.toNextSibling();\n            if (!nextSibling) {\n                return createRun();\n            }\n            // provide a new run\n            String uri = CTR.type.getName().getNamespaceURI();\n            String localPart = \"r\";\n            // creates a new run, cursor is positioned inside the new\n            // element\n            newCursor.beginElement(localPart, uri);\n            // move the cursor to the START token to the run just created\n            newCursor.toParent();\n            CTR r = ((CTR) (newCursor.getObject()));\n            XWPFRun newRun = new XWPFRun(r, ((IRunBody) (this)));\n            // To update the iruns, find where we're going\n            // in the normal runs, and go in there\n            int iPos = sdtElements.size();\n            int oldAt = sdtElements.indexOf(run);\n            if (oldAt != (-1)) {\n                iPos = oldAt;\n            }\n            if ((iPos + 1) >= sdtElements.size()) {\n                sdtElements.add(newRun);\n            } else {\n                sdtElements.add(iPos, newRun);\n            }\n            // Runs itself is easy to update\n            if ((pos + 1) >= runs.size()) {\n                runs.add(newRun);\n            } else {\n                runs.add(pos + 1, newRun);\n            }\n            newCursor.dispose();\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.InlineIterableProcessor.next",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.InlineIterableProcessor.next" ],
    "fullMethods" : [ "@Override\npublic void next(IterableTemplate iterable, ParentContext parentContext, IterableContext context, Object model) {\n    RunBodyContext paragraphContext = ((RunBodyContext) (parentContext));\n    RunTemplate end = iterable.getEndMark();\n    CTR endCtr = end.getRun().getCTR();\n    int startPos = context.getStart();\n    int endPos = context.getEnd();\n    // copy position cursor\n    int insertPostionCursor = end.getRunPos();\n    // copy content\n    List<XWPFRun> runs = paragraphContext.getRuns();\n    List<XWPFRun> copies = new ArrayList<XWPFRun>();\n    for (int i = startPos + 1; i < endPos; i++) {\n        insertPostionCursor = end.getRunPos();\n        XWPFRun xwpfRun = runs.get(i);\n        XWPFRun insertNewRun = paragraphContext.insertNewRun(xwpfRun, insertPostionCursor);\n        XWPFRun replaceXwpfRun = paragraphContext.createRun(xwpfRun, paragraphContext.getTarget());\n        paragraphContext.setAndUpdateRun(replaceXwpfRun, insertNewRun, insertPostionCursor);\n        XmlCursor newCursor = endCtr.newCursor();\n        newCursor.toPrevSibling();\n        XmlObject object = newCursor.getObject();\n        XWPFRun copy = paragraphContext.createRun(object, paragraphContext.getTarget());\n        DrawingSupport.updateDocPrId(copy);\n        copies.add(copy);\n        paragraphContext.setAndUpdateRun(copy, replaceXwpfRun, insertPostionCursor);\n    }\n    // re-parse\n    List<MetaTemplate> templates = this.resolver.resolveXWPFRuns(copies);\n    // render\n    process(templates, model);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.field.SimpleFieldRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.field.SimpleFieldRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(RenderContext<String> context) throws Exception {\n    RunTemplate runTemplate = ((RunTemplate) (context.getEleTemplate()));\n    XWPFRun run = context.getRun();\n    run.setText(\"\", 0);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    XWPFRun startRun = paragraphWrapper.insertNewRun(runTemplate.getRunPos());\n    StyleUtils.styleRun(startRun, run);\n    CTR ctr = startRun.getCTR();\n    CTFldChar addNewFldChar = ctr.addNewFldChar();\n    addNewFldChar.setFldCharType(STFldCharType.BEGIN);\n    XWPFRun instrRun = paragraphWrapper.insertNewRun(runTemplate.getRunPos());\n    StyleUtils.styleRun(instrRun, run);\n    ctr = instrRun.getCTR();\n    CTText addNewInstrText = ctr.addNewInstrText();\n    // \"EQ \\\\o\\\\ac(, 1)\"\n    addNewInstrText.setStringValue(context.getData());\n    XWPFRun sepRun = paragraphWrapper.insertNewRun(runTemplate.getRunPos());\n    StyleUtils.styleRun(sepRun, run);\n    ctr = sepRun.getCTR();\n    addNewFldChar = ctr.addNewFldChar();\n    addNewFldChar.setFldCharType(STFldCharType.SEPARATE);\n    XWPFRun endRun = paragraphWrapper.insertNewRun(runTemplate.getRunPos());\n    StyleUtils.styleRun(endRun, run);\n    ctr = endRun.getCTR();\n    addNewFldChar = ctr.addNewFldChar();\n    addNewFldChar.setFldCharType(STFldCharType.END);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.removeRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.removeRun" ],
    "fullMethods" : [ "/**\n * removes a Run at the position pos in the paragraph\n *\n * @return true if the run was removed\n */\npublic boolean removeRun(int pos) {\n    if ((pos >= 0) && (pos < runs.size())) {\n        XWPFRun run = runs.get(pos);\n        XmlCursor c = run.getCTR().newCursor();\n        c.removeXml();\n        c.dispose();\n        runs.remove(pos);\n        sdtElements.remove(run);\n        return true;\n    }\n    return false;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.ParagraphContext.createRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.ParagraphContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XWPFRun xwpfRun, IRunBody p) {\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink().copy())), ((CTR) (((XWPFHyperlinkRun) (xwpfRun)).getCTR().copy())), p);\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        return new XWPFFieldRun(((CTSimpleField) (((XWPFFieldRun) (xwpfRun)).getCTField().copy())), ((CTR) (((XWPFFieldRun) (xwpfRun)).getCTR().copy())), p);\n    } else {\n        return new XWPFRun(((CTR) (xwpfRun.getCTR().copy())), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ParagraphUtils.havePageBreak",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.ParagraphUtils.havePageBreak" ],
    "fullMethods" : [ "public static boolean havePageBreak(XWPFParagraph paragraph) {\n    List<XWPFRun> runs = paragraph.getRuns();\n    for (XWPFRun run : runs) {\n        if (CollectionUtils.isNotEmpty(run.getCTR().getLastRenderedPageBreakList()))\n            return true;\n\n    }\n    return false;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun", "com.deepoove.poi.util.StyleUtils.getRunProperties" ],
    "fullMethods" : [ "/**\n * set run style by style\n *\n * @param run\n * @param style\n */\npublic static void styleRun(XWPFRun run, Style style) {\n    if ((null == run) || (null == style))\n        return;\n\n    CTRPr pr = getRunProperties(run);\n    String color = style.getColor();\n    if (StringUtils.isNotBlank(color)) {\n        // run.setColor(color);\n        // issue 326\n        CTColor ctColor = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        ctColor.setVal(color);\n        if (ctColor.isSetThemeColor())\n            ctColor.unsetThemeColor();\n\n    }\n    double fontSize = style.getFontSize();\n    if ((0 != fontSize) && ((-1) != fontSize)) {\n        run.setFontSize(fontSize);\n    }\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        run.setFontFamily(fontFamily, FontCharRange.eastAsia);\n        run.setFontFamily(fontFamily, FontCharRange.ascii);\n        run.setFontFamily(fontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(fontFamily, FontCharRange.cs);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        run.setFontFamily(westernFontFamily, FontCharRange.ascii);\n        run.setFontFamily(westernFontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(westernFontFamily, FontCharRange.cs);\n    }\n    XWPFHighlightColor highlightColor = style.getHighlightColor();\n    if (null != highlightColor) {\n        CTHighlight highlight = (pr.sizeOfHighlightArray() > 0) ? pr.getHighlightArray(0) : pr.addNewHighlight();\n        highlight.setVal(STHighlightColor.Enum.forInt(highlightColor.getValue()));\n    }\n    Boolean bold = style.isBold();\n    if (null != bold)\n        run.setBold(bold);\n\n    Boolean italic = style.isItalic();\n    if (null != italic)\n        run.setItalic(italic);\n\n    Boolean strike = style.isStrike();\n    if (null != strike)\n        run.setStrikeThrough(strike);\n\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        run.setUnderline(underlinePatern);\n        if (null != style.getUnderlineColor()) {\n            run.setUnderlineColor(style.getUnderlineColor());\n        }\n    }\n    int point = style.getCharacterSpacing();\n    // in twentieths of a point\n    if ((0 != point) && ((-1) != point))\n        run.setCharacterSpacing(UnitUtils.point2Twips(point));\n\n    String vertAlign = style.getVertAlign();\n    if (StringUtils.isNotBlank(vertAlign)) {\n        run.setVerticalAlignment(vertAlign);\n    }\n}", "private static CTRPr getRunProperties(XWPFRun run) {\n    return run.getCTR().isSetRPr() ? run.getCTR().getRPr() : run.getCTR().addNewRPr();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements", "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph", "com.deepoove.poi.resolver.RunningRunBody.<init>", "com.deepoove.poi.resolver.RunningRunBody.refactorBody" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveBodyElements(List<IBodyElement> bodyElements) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (null == bodyElements)\n        return metaTemplates;\n\n    // current iterable templates state\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    for (IBodyElement element : bodyElements) {\n        if (element == null)\n            continue;\n\n        if (element.getElementType() == BodyElementType.PARAGRAPH) {\n            resolveParagraph(((XWPFParagraph) (element)), metaTemplates, stack);\n        } else if (element.getElementType() == BodyElementType.TABLE) {\n            XWPFTable table = ((XWPFTable) (element));\n            List<XWPFTableRow> rows = table.getRows();\n            if (null == rows)\n                continue;\n\n            for (XWPFTableRow row : rows) {\n                resolveTableRow(row, metaTemplates, stack);\n            }\n        } else if ((element.getElementType() == BodyElementType.CONTENTCONTROL) && (element instanceof XWPFStructuredDocumentTag)) {\n            XWPFStructuredDocumentTag sdt = ((XWPFStructuredDocumentTag) (element));\n            addNewMeta(metaTemplates, stack, resolveSDTElements(sdt.getContent()));\n        }\n    }\n    checkStack(stack);\n    return metaTemplates;\n}", "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}", "public RunningRunBody(RunBodyContext context, Pattern pattern) {\n    this.runBodyContext = context;\n    this.runs = context.getRuns();\n    if ((null == runs) || runs.isEmpty())\n        return;\n\n    Matcher matcher = pattern.matcher(getText(context));\n    if (matcher.find()) {\n        refactorBody();\n    }\n    buildRunEdge(pattern);\n}", "private void refactorBody() {\n    for (int i = runs.size() - 1; i >= 0; i--) {\n        XWPFRun xwpfRun = runs.get(i);\n        CTR ctr = xwpfRun.getCTR();\n        CTRImpl ctrimpl = ((CTRImpl) (ctr));\n        int sizeOfBrArray = ctr.sizeOfBrArray();\n        int sizeOfCrArray = ctr.sizeOfCrArray();\n        int sizeOfTabArray = ctr.sizeOfTabArray();\n        if (((sizeOfBrArray + sizeOfCrArray) + sizeOfTabArray) > 0) {\n            synchronized(ctrimpl.monitor()) {\n                // ctrimpl.check_orphaned();\n                List<? extends XmlObject> localArrayList = new ArrayList<XmlObject>();\n                ctrimpl.get_store().find_all_element_users(qname, localArrayList);\n                int size = localArrayList.size();\n                for (int j = size - 1; j >= 0; j--) {\n                    Object obj = localArrayList.get(j);\n                    if (obj instanceof CTEmpty) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        String tagName = ((CTEmpty) (obj)).getDomNode().getNodeName();\n                        if (\"w:br\".equals(tagName) || \"br\".equals(tagName)) {\n                            insertNewRun.addBreak();\n                        }\n                        if (\"w:cr\".equals(tagName) || \"cr\".equals(tagName)) {\n                            insertNewRun.addCarriageReturn();\n                        }\n                        if (\"w:tab\".equals(tagName) || \"tab\".equals(tagName)) {\n                            insertNewRun.addTab();\n                        }\n                    } else if (obj instanceof CTBr) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        CTBr addNewBr = insertNewRun.getCTR().addNewBr();\n                        if (null != ((CTBr) (obj)).getType())\n                            addNewBr.setType(((CTBr) (obj)).getType());\n\n                        if (null != ((CTBr) (obj)).getClear())\n                            addNewBr.setClear(((CTBr) (obj)).getClear());\n\n                    } else if (obj instanceof CTText) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        StyleUtils.styleRun(insertNewRun, xwpfRun);\n                        insertNewRun.setText(((CTText) (obj)).getStringValue());\n                    }\n                }\n                runBodyContext.removeRun(i);\n            }\n        }\n    }\n    this.runs = runBodyContext.getRuns();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.DrawingSupport.updateDocPrId",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.DrawingSupport.updateDocPrId" ],
    "fullMethods" : [ "public static void updateDocPrId(XWPFRun run) {\n    NiceXWPFDocument document = ((NiceXWPFDocument) (run.getDocument()));\n    if (!document.getDocPrIdenifierManager().isValid())\n        return;\n\n    CTR r = run.getCTR();\n    for (CTDrawing ctDrawing : r.getDrawingList()) {\n        processCTDrawing(document, ctDrawing);\n    }\n    XmlObject[] xmlObjects = r.selectPath(IdenifierManagerWrapper.XPATH_DRAWING);\n    if ((null == xmlObjects) || (xmlObjects.length <= 0))\n        return;\n\n    for (XmlObject xmlObject : xmlObjects) {\n        try {\n            CTDrawing ctDrawing = CTDrawing.Factory.parse(xmlObject.xmlText());\n            processCTDrawing(document, ctDrawing);\n            xmlObject.set(ctDrawing);\n        } catch (XmlException e) {\n            // no-op\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter" ],
    "fullMethods" : [ "public XWPFRun insertNewRunAfter(int pos) {\n    if (pos == paragraph.getRuns().size()) {\n        return paragraph.createRun();\n    }\n    if ((pos >= 0) && (pos < paragraph.getRuns().size())) {\n        XWPFRun run = paragraph.getRuns().get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInParagraph(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInParagraph(newCursor)) {\n            boolean nextSibling = newCursor.toNextSibling();\n            if (!nextSibling) {\n                return paragraph.createRun();\n            }\n            String uri = CTR.type.getName().getNamespaceURI();\n            String localPart = \"r\";\n            newCursor.beginElement(localPart, uri);\n            newCursor.toParent();\n            CTR r = ((CTR) (newCursor.getObject()));\n            XWPFRun newRun = new XWPFRun(r, ((IRunBody) (this.paragraph)));\n            List<IRunElement> iruns = getIRuns();\n            List<XWPFRun> runs = getRuns();\n            int iPos = iruns.size();\n            if (pos < runs.size()) {\n                XWPFRun oldAtPos = runs.get(pos);\n                int oldAt = iruns.indexOf(oldAtPos);\n                if (oldAt != (-1)) {\n                    iPos = oldAt;\n                }\n            }\n            if ((iPos + 1) >= iruns.size()) {\n                iruns.add(newRun);\n            } else {\n                iruns.add(iPos + 1, newRun);\n            }\n            // Runs itself is easy to update\n            if ((pos + 1) >= runs.size()) {\n                runs.add(newRun);\n            } else {\n                runs.add(pos + 1, newRun);\n            }\n            newCursor.dispose();\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewRun", "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewProvidedRun" ],
    "fullMethods" : [ "public XWPFRun insertNewRun(int pos) {\n    if (pos == runs.size()) {\n        return createRun();\n    }\n    return insertNewProvidedRun(pos, newCursor -> {\n        String uri = CTR.type.getName().getNamespaceURI();\n        String localPart = \"r\";\n        // creates a new run, cursor is positioned inside the new\n        // element\n        newCursor.beginElement(localPart, uri);\n        // move the cursor to the START token to the run just created\n        newCursor.toParent();\n        CTR r = ((CTR) (newCursor.getObject()));\n        return new XWPFRun(r, ((IRunBody) (this)));\n    });\n}", "/**\n * insert a new run provided by in all runs\n *\n * @param <T>\n * \t\tXWPFRun or XWPFHyperlinkRun or XWPFFieldRun\n * @param pos\n * \t\tThe position at which the new run should be added.\n * @param provider\n * \t\tprovide a new run at position of the given cursor.\n * @return the inserted run or null if the given pos is out of bounds.\n */\nprivate <T extends XWPFRun> T insertNewProvidedRun(int pos, Function<XmlCursor, T> provider) {\n    if ((pos >= 0) && (pos < runs.size())) {\n        XWPFRun run = runs.get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInRunContent(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInRunContent(newCursor)) {\n            // provide a new run\n            T newRun = provider.apply(newCursor);\n            // To update the iruns, find where we're going\n            // in the normal runs, and go in there\n            int iPos = sdtElements.size();\n            int oldAt = sdtElements.indexOf(run);\n            if (oldAt != (-1)) {\n                iPos = oldAt;\n            }\n            sdtElements.add(iPos, newRun);\n            // Runs itself is easy to update\n            runs.add(pos, newRun);\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getCTR",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph", "com.deepoove.poi.resolver.RunningRunBody.<init>", "com.deepoove.poi.resolver.RunningRunBody.refactorBody" ],
    "fullMethods" : [ "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}", "public RunningRunBody(RunBodyContext context, Pattern pattern) {\n    this.runBodyContext = context;\n    this.runs = context.getRuns();\n    if ((null == runs) || runs.isEmpty())\n        return;\n\n    Matcher matcher = pattern.matcher(getText(context));\n    if (matcher.find()) {\n        refactorBody();\n    }\n    buildRunEdge(pattern);\n}", "private void refactorBody() {\n    for (int i = runs.size() - 1; i >= 0; i--) {\n        XWPFRun xwpfRun = runs.get(i);\n        CTR ctr = xwpfRun.getCTR();\n        CTRImpl ctrimpl = ((CTRImpl) (ctr));\n        int sizeOfBrArray = ctr.sizeOfBrArray();\n        int sizeOfCrArray = ctr.sizeOfCrArray();\n        int sizeOfTabArray = ctr.sizeOfTabArray();\n        if (((sizeOfBrArray + sizeOfCrArray) + sizeOfTabArray) > 0) {\n            synchronized(ctrimpl.monitor()) {\n                // ctrimpl.check_orphaned();\n                List<? extends XmlObject> localArrayList = new ArrayList<XmlObject>();\n                ctrimpl.get_store().find_all_element_users(qname, localArrayList);\n                int size = localArrayList.size();\n                for (int j = size - 1; j >= 0; j--) {\n                    Object obj = localArrayList.get(j);\n                    if (obj instanceof CTEmpty) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        String tagName = ((CTEmpty) (obj)).getDomNode().getNodeName();\n                        if (\"w:br\".equals(tagName) || \"br\".equals(tagName)) {\n                            insertNewRun.addBreak();\n                        }\n                        if (\"w:cr\".equals(tagName) || \"cr\".equals(tagName)) {\n                            insertNewRun.addCarriageReturn();\n                        }\n                        if (\"w:tab\".equals(tagName) || \"tab\".equals(tagName)) {\n                            insertNewRun.addTab();\n                        }\n                    } else if (obj instanceof CTBr) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        CTBr addNewBr = insertNewRun.getCTR().addNewBr();\n                        if (null != ((CTBr) (obj)).getType())\n                            addNewBr.setType(((CTBr) (obj)).getType());\n\n                        if (null != ((CTBr) (obj)).getClear())\n                            addNewBr.setClear(((CTBr) (obj)).getClear());\n\n                    } else if (obj instanceof CTText) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        StyleUtils.styleRun(insertNewRun, xwpfRun);\n                        insertNewRun.setText(((CTText) (obj)).getStringValue());\n                    }\n                }\n                runBodyContext.removeRun(i);\n            }\n        }\n    }\n    this.runs = runBodyContext.getRuns();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.main.CTTextBody.removeP",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.main",
    "path" : [ "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setTitle", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setCTTitle" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartMultiSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    List<XDDFChartData> chartSeries = chart.getChartSeries();\n    validate(chartSeries, data);\n    int totalSeriesCount = ensureSeriesCount(chart, chartSeries);\n    int valueCol = 1;\n    List<SeriesRenderData> usedSeriesDatas = new ArrayList<>();\n    for (XDDFChartData chartData : chartSeries) {\n        int orignSize = chartData.getSeriesCount();\n        List<SeriesRenderData> currentSeriesData = null;\n        if (chartSeries.size() <= 1) {\n            // ignore combo type\n            currentSeriesData = data.getSeriesDatas();\n        } else {\n            currentSeriesData = obtainSeriesData(chartData.getClass(), data.getSeriesDatas());\n        }\n        usedSeriesDatas.addAll(currentSeriesData);\n        int currentSeriesSize = currentSeriesData.size();\n        XDDFDataSource<?> categoriesData = null;\n        if (chartData instanceof XDDFScatterChartData) {\n            categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n        } else {\n            categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n        }\n        for (int i = 0; i < currentSeriesSize; i++) {\n            XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, currentSeriesData.get(i).getValues(), valueCol);\n            XDDFChartData.Series currentSeries = null;\n            if (i < orignSize) {\n                currentSeries = chartData.getSeries(i);\n                valuesData.setFormatCode(currentSeries.getValuesData().getFormatCode());\n                currentSeries.replaceData(categoriesData, valuesData);\n            } else {\n                // add series, should copy series with style\n                currentSeries = chartData.addSeries(categoriesData, valuesData);\n                processNewSeries(chartData, currentSeries);\n            }\n            String name = currentSeriesData.get(i).getName();\n            currentSeries.setTitle(name, chart.setSheetTitle(name, valueCol));\n            valueCol++;\n        }\n        // clear extra series\n        removeExtraSeries(chartData, orignSize, currentSeriesSize);\n    }\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    updateCTTable(sheet, usedSeriesDatas);\n    removeExtraSheetCell(sheet, data.getCategories().length, totalSeriesCount, usedSeriesDatas.size());\n    for (XDDFChartData chartData : chartSeries) {\n        plot(chart, chartData);\n    }\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "protected void setTitle(XWPFChart chart, String title) {\n    if ((null == title) && chart.getCTChart().isSetTitle()) {\n        chart.getCTChart().unsetTitle();\n        return;\n    }\n    CTTitle ctTitle = chart.getCTChart().getTitle();\n    boolean isSet = setCTTitle(ctTitle, title);\n    if (!isSet) {\n        chart.setTitleText(title);\n        chart.setTitleOverlay(false);\n    }\n}", "private boolean setCTTitle(CTTitle ctTitle, String title) {\n    boolean isSet = false;\n    if (null != ctTitle) {\n        if (!ctTitle.isSetTx()) {\n            ctTitle.addNewTx();\n        }\n        CTTx tx = ctTitle.getTx();\n        if (tx.isSetStrRef()) {\n            tx.unsetStrRef();\n        }\n        if (!tx.isSetRich()) {\n            tx.addNewRich();\n        }\n        CTTextBody body = tx.getRich();\n        if (body.sizeOfPArray() > 0) {\n            // remove all but first paragraph\n            for (int i = body.sizeOfPArray() - 1; i > 0; i--) {\n                body.removeP(i);\n            }\n            CTTextParagraph pArray = body.getPArray(0);\n            if (pArray.sizeOfRArray() > 0) {\n                for (int i = pArray.sizeOfRArray() - 1; i > 0; i--) {\n                    pArray.removeR(i);\n                }\n                CTRegularTextRun rArray = pArray.getRArray(0);\n                rArray.setT(title);\n                isSet = true;\n            }\n        }\n    }\n    return isSet;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.main.CTTextBody.removeP",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.main",
    "path" : [ "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setTitle", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setCTTitle" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartSingleSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    XDDFChartData pie = ChartUtils.getChartSeries(chart).get(0);\n    SeriesRenderData seriesDatas = data.getSeriesData();\n    XDDFDataSource<?> categoriesData = null;\n    if (pie instanceof XDDFScatterChartData) {\n        categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n    } else {\n        categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n    }\n    XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, seriesDatas.getValues(), 1);\n    XDDFChartData.Series currentSeries = pie.getSeries(0);\n    currentSeries.replaceData(categoriesData, valuesData);\n    currentSeries.setTitle(seriesDatas.getName(), chart.setSheetTitle(seriesDatas.getName(), 1));\n    updateCTTable(chart.getWorkbook().getSheetAt(0), Arrays.asList(seriesDatas));\n    plot(chart, pie);\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "protected void setTitle(XWPFChart chart, String title) {\n    if ((null == title) && chart.getCTChart().isSetTitle()) {\n        chart.getCTChart().unsetTitle();\n        return;\n    }\n    CTTitle ctTitle = chart.getCTChart().getTitle();\n    boolean isSet = setCTTitle(ctTitle, title);\n    if (!isSet) {\n        chart.setTitleText(title);\n        chart.setTitleOverlay(false);\n    }\n}", "private boolean setCTTitle(CTTitle ctTitle, String title) {\n    boolean isSet = false;\n    if (null != ctTitle) {\n        if (!ctTitle.isSetTx()) {\n            ctTitle.addNewTx();\n        }\n        CTTx tx = ctTitle.getTx();\n        if (tx.isSetStrRef()) {\n            tx.unsetStrRef();\n        }\n        if (!tx.isSetRich()) {\n            tx.addNewRich();\n        }\n        CTTextBody body = tx.getRich();\n        if (body.sizeOfPArray() > 0) {\n            // remove all but first paragraph\n            for (int i = body.sizeOfPArray() - 1; i > 0; i--) {\n                body.removeP(i);\n            }\n            CTTextParagraph pArray = body.getPArray(0);\n            if (pArray.sizeOfRArray() > 0) {\n                for (int i = pArray.sizeOfRArray() - 1; i > 0; i--) {\n                    pArray.removeR(i);\n                }\n                CTRegularTextRun rArray = pArray.getRArray(0);\n                rArray.setT(title);\n                isSet = true;\n            }\n        }\n    }\n    return isSet;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setExplosion",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.getExplosion",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setExplosion" ],
    "fullMethods" : [ "public void setExplosion(Long explosion) {\n    if (explosion == null) {\n        if (series.isSetExplosion()) {\n            series.unsetExplosion();\n        }\n    } else if (series.isSetExplosion()) {\n        series.getExplosion().setVal(explosion);\n    } else {\n        series.addNewExplosion().setVal(explosion);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.getExplosion",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.getExplosion",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.getExplosion" ],
    "fullMethods" : [ "public Long getExplosion() {\n    if (series.isSetExplosion()) {\n        return series.getExplosion().getVal();\n    } else {\n        return null;\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.getTblLayout",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblPr.isSetTblLayout",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.getTblLayout" ],
    "fullMethods" : [ "public static CTTblLayoutType getTblLayout(XWPFTable table) {\n    CTTblPr tblPr = getTblPr(table);\n    return tblPr.isSetTblLayout() ? tblPr.getTblLayout() : tblPr.addNewTblLayout();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.addNewB",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.getBArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblPr.getTblInd",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTable" ],
    "fullMethods" : [ "/**\n * set table style\n *\n * @param table\n * @param tableStyle\n */\npublic static void styleTable(XWPFTable table, TableStyle tableStyle) {\n    if ((null == table) || (null == tableStyle))\n        return;\n\n    TableTools.setWidth(table, tableStyle.getWidth(), tableStyle.getColWidths());\n    TableTools.setBorder(table::setLeftBorder, tableStyle.getLeftBorder());\n    TableTools.setBorder(table::setRightBorder, tableStyle.getRightBorder());\n    TableTools.setBorder(table::setTopBorder, tableStyle.getTopBorder());\n    TableTools.setBorder(table::setBottomBorder, tableStyle.getBottomBorder());\n    TableTools.setBorder(table::setInsideHBorder, tableStyle.getInsideHBorder());\n    TableTools.setBorder(table::setInsideVBorder, tableStyle.getInsideVBorder());\n    if (null != tableStyle.getAlign()) {\n        table.setTableAlignment(tableStyle.getAlign());\n    }\n    table.setCellMargins(tableStyle.getTopCellMargin(), tableStyle.getLeftCellMargin(), tableStyle.getBottomCellMargin(), tableStyle.getRightCellMargin());\n    if (null != tableStyle.getIndentation()) {\n        CTTbl ctTbl = table.getCTTbl();\n        CTTblPr tPr = (ctTbl.getTblPr() != null) ? ctTbl.getTblPr() : ctTbl.addNewTblPr();\n        CTTblWidth tw = (tPr.isSetTblInd()) ? tPr.getTblInd() : tPr.addNewTblInd();\n        tw.setType(STTblWidth.DXA);\n        tw.setW(BigInteger.valueOf(UnitUtils.cm2Twips(tableStyle.getIndentation())));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTLvl.addNewPPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId" ],
    "fullMethods" : [ "public BigInteger addNewMultiLevelNumberingId(NumberingFormat... numFmts) {\n    XWPFNumbering numbering = this.getNumbering();\n    if (null == numbering) {\n        numbering = this.createNumbering();\n    }\n    XWPFNumberingWrapper numberingWrapper = new XWPFNumberingWrapper(numbering);\n    CTAbstractNum cTAbstractNum = CTAbstractNum.Factory.newInstance();\n    // if we have an existing document, we must determine the next\n    // free number first.\n    cTAbstractNum.setAbstractNumId(numberingWrapper.getNextAbstractNumID());\n    // CTMultiLevelType addNewMultiLevelType = cTAbstractNum.addNewMultiLevelType();\n    // addNewMultiLevelType.setVal(STMultiLevelType.HYBRID_MULTILEVEL);\n    for (int i = 0; i < numFmts.length; i++) {\n        NumberingFormat numFmt = numFmts[i];\n        CTLvl cTLvl = cTAbstractNum.addNewLvl();\n        CTPPrBase ppr = (cTLvl.isSetPPr()) ? cTLvl.getPPr() : cTLvl.addNewPPr();\n        CTInd ind = (ppr.isSetInd()) ? ppr.getInd() : ppr.addNewInd();\n        ind.setLeft(BigInteger.valueOf(UnitUtils.cm2Twips(0.74F) * i));\n        Enum fmt = STNumberFormat.Enum.forInt(numFmt.getNumFmt());\n        String val = numFmt.getLvlText();\n        cTLvl.addNewNumFmt().setVal(fmt);\n        cTLvl.addNewLvlText().setVal(val);\n        cTLvl.addNewStart().setVal(BigInteger.valueOf(1));\n        cTLvl.setIlvl(BigInteger.valueOf(i));\n        if (fmt == STNumberFormat.BULLET) {\n            cTLvl.addNewLvlJc().setVal(STJc.LEFT);\n            CTRPr addNewRPr = cTLvl.addNewRPr();\n            CTFonts ctFonts = addNewRPr.addNewRFonts();\n            ctFonts.setAscii(\"Wingdings\");\n            ctFonts.setHAnsi(\"Wingdings\");\n            ctFonts.setHint(STHint.DEFAULT);\n        }\n    }\n    XWPFAbstractNum abstractNum = new XWPFAbstractNum(cTAbstractNum);\n    BigInteger abstractNumID = numbering.addAbstractNum(abstractNum);\n    return numbering.addNum(abstractNumID);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.SDTContentContext.createRun",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTSimpleField.getRArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.SDTContentContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XmlObject object, IRunBody p) {\n    if (object instanceof CTHyperlink) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (object)), ((CTHyperlink) (object)).getRArray(0), p);\n    } else if (object instanceof CTSimpleField) {\n        return new XWPFFieldRun(((CTSimpleField) (object)), ((CTSimpleField) (object)).getRArray(0), p);\n    } else {\n        return new XWPFRun(((CTR) (object)), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.ParagraphContext.createRun",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTSimpleField.getRArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.ParagraphContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XmlObject object, IRunBody p) {\n    if (object instanceof CTHyperlink) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (object)), ((CTHyperlink) (object)).getRArray(0), p);\n    } else if (object instanceof CTSimpleField) {\n        return new XWPFFieldRun(((CTSimpleField) (object)), ((CTSimpleField) (object)).getRArray(0), p);\n    } else {\n        return new XWPFRun(((CTR) (object)), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.addNewRFonts",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        for (int i = rowSize - 1; i >= 0; i--) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            String text = row.getCell(actualInsertPosition).getText();\n            if (\"_delete_\".equals(text)) {\n                table.removeRow(i);\n            } else {\n                removeCell(row, actualInsertPosition);\n            }\n        }\n    } catch (Exception e) {\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CommentBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CommentBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFHeaderFooter\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.<init>", "com.deepoove.poi.xwpf.NiceXWPFDocument.niceDocumentRead", "com.deepoove.poi.xwpf.NiceXWPFDocument.read", "com.deepoove.poi.xwpf.NiceXWPFDocument.readTables" ],
    "fullMethods" : [ "public NiceXWPFDocument(InputStream in, boolean adjustDoc) throws IOException {\n    super(in);\n    this.adjustDoc = adjustDoc;\n    idenifierManagerWrapper = new IdenifierManagerWrapper(this);\n    niceDocumentRead();\n}", "private void niceDocumentRead() throws IOException {\n    read(this);\n    this.getHeaderList().forEach(header -> read(header));\n    this.getFooterList().forEach(header -> read(header));\n    // structured document tag\n    if (!contentControls.isEmpty()) {\n        XmlCursor docCursor = getDocument().newCursor();\n        docCursor.selectPath(\"./*\");\n        while (docCursor.toNextSelection()) {\n            XmlObject o = docCursor.getObject();\n            if (o instanceof CTBody) {\n                XmlCursor bodyCursor = o.newCursor();\n                bodyCursor.selectPath(\"./*\");\n                while (bodyCursor.toNextSelection()) {\n                    XmlObject bodyObj = bodyCursor.getObject();\n                    if (bodyObj instanceof CTSdtBlock) {\n                        XWPFStructuredDocumentTag c = new XWPFStructuredDocumentTag(((CTSdtBlock) (bodyObj)), this);\n                        bodyElements.add(c);\n                        structuredDocumentTags.add(c);\n                    }\n                } \n                bodyCursor.dispose();\n            }\n        } \n        docCursor.dispose();\n    }\n}", "private void read(IBody body) {\n    readParagraphs(body.getParagraphs());\n    readTables(body.getTables());\n}", "private void readTables(List<XWPFTable> tables) {\n    allTables.addAll(tables);\n    for (XWPFTable table : tables) {\n        List<XWPFTableRow> rows = table.getRows();\n        if (null == rows)\n            continue;\n\n        for (XWPFTableRow row : rows) {\n            List<XWPFTableCell> cells = row.getTableCells();\n            if (null == cells)\n                continue;\n\n            for (XWPFTableCell cell : cells) {\n                read(cell);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.DrawingSupport.updateDocPrId",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.DrawingSupport.updateDocPrId" ],
    "fullMethods" : [ "public static void updateDocPrId(XWPFTable table) {\n    List<XWPFTableRow> rows = table.getRows();\n    rows.forEach(row -> {\n        List<XWPFTableCell> cells = row.getTableCells();\n        cells.forEach(cell -> {\n            cell.getParagraphs().forEach(DrawingSupport::updateDocPrId);\n            cell.getTables().forEach(DrawingSupport::updateDocPrId);\n        });\n    });\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderTable" ],
    "fullMethods" : [ "public static XWPFTable renderTable(XWPFRun run, TableRenderData data) throws Exception {\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    XWPFTable table = bodyContainer.insertNewTable(run, data.obtainRowSize(), data.obtainColSize());\n    StyleUtils.styleTable(table, data.getTableStyle());\n    int size = table.getRows().size();\n    for (int i = 0; i < size; i++) {\n        RowRenderData rowRenderData = data.getRows().get(i);\n        renderRow(table.getRows().get(i), rowRenderData, StyleUtils.retriveStyle(run));\n    }\n    applyMergeRule(table, data.getMergeRule());\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFHeaderFooter\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getText",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getText", "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.appendTable" ],
    "fullMethods" : [ "@Override\npublic String getText() {\n    StringBuilder text = new StringBuilder();\n    boolean addNewLine = false;\n    for (int i = 0; i < sdtElements.size(); i++) {\n        Object o = sdtElements.get(i);\n        if (o instanceof XWPFParagraph) {\n            appendParagraph(((XWPFParagraph) (o)), text);\n            addNewLine = true;\n        } else if (o instanceof XWPFTable) {\n            appendTable(((XWPFTable) (o)), text);\n            addNewLine = true;\n        } else if (o instanceof XWPFSDT) {\n            text.append(((XWPFSDT) (o)).getContent().getText());\n            addNewLine = true;\n        } else if (o instanceof XWPFRun) {\n            text.append(o);\n            addNewLine = false;\n        }\n        if (addNewLine && (i < (sdtElements.size() - 1))) {\n            text.append(\"\\n\");\n        }\n    }\n    return text.toString();\n}", "private void appendTable(XWPFTable table, StringBuilder text) {\n    // this works recursively to pull embedded tables from within cells\n    for (XWPFTableRow row : table.getRows()) {\n        List<ICell> cells = row.getTableICells();\n        for (int i = 0; i < cells.size(); i++) {\n            ICell cell = cells.get(i);\n            if (cell instanceof XWPFTableCell) {\n                text.append(((XWPFTableCell) (cell)).getTextRecursively());\n            } else if (cell instanceof XWPFSDTCell) {\n                text.append(((XWPFSDTCell) (cell)).getContent().getText());\n            }\n            if (i < (cells.size() - 1)) {\n                text.append(\"\\t\");\n            }\n        }\n        text.append('\\n');\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveBodyElements(List<IBodyElement> bodyElements) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (null == bodyElements)\n        return metaTemplates;\n\n    // current iterable templates state\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    for (IBodyElement element : bodyElements) {\n        if (element == null)\n            continue;\n\n        if (element.getElementType() == BodyElementType.PARAGRAPH) {\n            resolveParagraph(((XWPFParagraph) (element)), metaTemplates, stack);\n        } else if (element.getElementType() == BodyElementType.TABLE) {\n            XWPFTable table = ((XWPFTable) (element));\n            List<XWPFTableRow> rows = table.getRows();\n            if (null == rows)\n                continue;\n\n            for (XWPFTableRow row : rows) {\n                resolveTableRow(row, metaTemplates, stack);\n            }\n        } else if ((element.getElementType() == BodyElementType.CONTENTCONTROL) && (element instanceof XWPFStructuredDocumentTag)) {\n            XWPFStructuredDocumentTag sdt = ((XWPFStructuredDocumentTag) (element));\n            addNewMeta(metaTemplates, stack, resolveSDTElements(sdt.getContent()));\n        }\n    }\n    checkStack(stack);\n    return metaTemplates;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFTableCell\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.setWidth",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.setWidth" ],
    "fullMethods" : [ "/**\n * set table width\n *\n * @param table\n * @param width\n * @param colWidths\n */\npublic static void setWidth(XWPFTable table, String width, int[] colWidths) {\n    ensureTblW(table);\n    table.setWidth(width);\n    if (null == colWidths) {\n        int columnSize = TableTools.obtainColumnSize(table);\n        if (table.getWidthType() == TableWidthType.DXA) {\n            colWidths = UnitUtils.average(Integer.valueOf(width), columnSize);\n        } else if (table.getWidthType() == TableWidthType.PCT) {\n            int sum = 0;\n            colWidths = new int[columnSize];\n            for (int i = 0; i < (columnSize - 1); i++) {\n                colWidths[i] = 100 / columnSize;\n                sum += colWidths[i];\n            }\n            colWidths[columnSize - 1] = 100 - sum;\n        }\n    }\n    if (null != colWidths) {\n        BigInteger[] gridCol = null;\n        String[] cellWidth = null;\n        if (table.getWidthType() == TableWidthType.DXA) {\n            cellWidth = Arrays.stream(colWidths).mapToObj(String::valueOf).toArray(String[]::new);\n            gridCol = Arrays.stream(colWidths).mapToObj(BigInteger::valueOf).toArray(BigInteger[]::new);\n        } else if (table.getWidthType() == TableWidthType.PCT) {\n            cellWidth = Arrays.stream(colWidths).mapToObj(w -> w + \"%\").toArray(String[]::new);\n            BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(table.getBody());\n            int pageWidth = bodyContainer.elementPageWidth(table);\n            int tableWidth = (pageWidth * Integer.valueOf(width.substring(0, width.length() - 1))) / 100;\n            gridCol = Arrays.stream(colWidths).mapToObj(w -> BigInteger.valueOf((w * tableWidth) / 100)).toArray(BigInteger[]::new);\n        }\n        CTTblGrid tblGrid = TableTools.getTblGrid(table);\n        CTTblLayoutType tblLayout = TableTools.getTblLayout(table);\n        tblLayout.setType(STTblLayoutType.FIXED);\n        for (int index = 0; index < colWidths.length; index++) {\n            if (null != gridCol) {\n                CTTblGridCol addNewGridCol = tblGrid.addNewGridCol();\n                addNewGridCol.setW(gridCol[index]);\n            }\n            List<XWPFTableRow> rows = table.getRows();\n            for (XWPFTableRow row : rows) {\n                row.getCell(index).setWidth(cellWidth[index]);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.obtainColumnSize",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.obtainColumnSize" ],
    "fullMethods" : [ "public static int obtainColumnSize(XWPFTable table) {\n    return table.getRows().get(0).getTableCells().size();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render", "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.getTemplateRowIndex", "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.getRowIndex" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        if ((null != data) && (data instanceof Iterable)) {\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            XWPFTableRow templateRow = table.getRow(templateRowIndex);\n            int insertPosition = templateRowIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            boolean firstFlag = true;\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateRowIndex++;\n                XWPFTableRow nextRow = table.insertNewTableRow(insertPosition);\n                setTableRow(table, templateRow, insertPosition);\n                // double set row\n                XmlCursor newCursor = templateRow.getCtRow().newCursor();\n                newCursor.toPrevSibling();\n                XmlObject object = newCursor.getObject();\n                nextRow = new XWPFTableRow(((CTRow) (object)), table);\n                if (!firstFlag) {\n                    // update VMerge cells for non-first row\n                    List<XWPFTableCell> tableCells = nextRow.getTableCells();\n                    for (XWPFTableCell cell : tableCells) {\n                        CTTcPr tcPr = TableTools.getTcPr(cell);\n                        CTVMerge vMerge = tcPr.getVMerge();\n                        if (null == vMerge)\n                            continue;\n\n                        if (STMerge.RESTART == vMerge.getVal()) {\n                            vMerge.setVal(STMerge.CONTINUE);\n                        }\n                    }\n                } else {\n                    firstFlag = false;\n                }\n                setTableRow(table, nextRow, insertPosition);\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                List<XWPFTableCell> cells = nextRow.getTableCells();\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        table.removeRow(templateRowIndex);\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \" error: \") + e.getMessage(), e);\n    }\n}", "private int getTemplateRowIndex(XWPFTableCell tagCell) {\n    XWPFTableRow tagRow = tagCell.getTableRow();\n    return onSameLine ? getRowIndex(tagRow) : getRowIndex(tagRow) + 1;\n}", "private int getRowIndex(XWPFTableRow row) {\n    List<XWPFTableRow> rows = row.getTable().getRows();\n    return rows.indexOf(row);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.obtainRowSize",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.obtainRowSize" ],
    "fullMethods" : [ "public static int obtainRowSize(XWPFTable table) {\n    return table.getRows().size();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getRows",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render", "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.getTemplateRowIndex", "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.getRowIndex" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        int templateColIndex = getColIndex(tagCell);\n        if ((null == data) || ((data instanceof Boolean) && (!((Boolean) (data))))) {\n            // table.removeRow(templateRowIndex);\n            // tagCell.setText(\"_delete_\");\n            run.setText(\"_delete_\", 0);\n            CTTcPr tcPr = TableTools.getTcPr(tagCell);\n            CTVMerge vMerge = tcPr.getVMerge();\n            System.out.println(null == vMerge ? null : vMerge.getVal());\n            if ((null != vMerge) && vMerge.getVal().equals(STMerge.RESTART)) {\n                XWPFTableRow row = table.getRow(templateRowIndex + 1);\n                int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n                XWPFTableCell actualCell = row.getCell(actualInsertPosition);\n                System.out.println(actualCell.getCTTc());\n                actualCell.getParagraphArray(0).createRun().setText(\"_delete_\", 0);\n            }\n        } else {\n            run.setText(\"\", 0);\n        }\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}", "private int getTemplateRowIndex(XWPFTableCell tagCell) {\n    XWPFTableRow tagRow = tagCell.getTableRow();\n    return getRowIndex(tagRow);\n}", "private int getRowIndex(XWPFTableRow row) {\n    List<XWPFTableRow> rows = row.getTable().getRows();\n    return rows.indexOf(row);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFEndnote.getCTFtnEdn",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableString", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeEndnote" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "protected String createMergeableString(NiceXWPFDocument source, NiceXWPFDocument merged, Map<String, String> styleIdsMap) throws InvalidFormatException, IOException {\n    CTBody mergedBody = merged.getDocument().getBody();\n    // TODO For the same style, reduce the number of merges\n    // Map<String, String> styleIdsMap = mergeStyles(docMerge);\n    Map<String, String> numIdsMap = mergeNumbering(source, merged);\n    Map<String, String> blipIdsMap = mergePicture(source, merged);\n    Map<String, String> externalBlipIdsMap = mergeExternalPicture(source, merged);\n    Map<String, String> hyperlinkMap = mergeHyperlink(source, merged);\n    Map<String, String> chartIdsMap = mergeChart(source, merged);\n    Map<String, String> attachmentIdsMap = mergeAttachment(source, merged);\n    Map<String, String> footnoteIdsMap = mergeFootnote(source, merged);\n    Map<String, String> endnoteIdsMap = mergeEndnote(source, merged);\n    String appendString = mergedBody.xmlText(DefaultXmlOptions.OPTIONS_OUTER);\n    String addPart = ridSectPr(appendString);\n    // style\n    for (String styleId : styleIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:pStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:pStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:tblStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:tblStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:rStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:rStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\");\n    }\n    // picture id\n    Map<String, String> placeHolderblipIdsMap = new HashMap<String, String>();\n    for (String relaId : blipIdsMap.keySet()) {\n        placeHolderblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:embed=\\\"\" + relaId) + \"\\\"\", (\"r:embed=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n        // w:pict v:shape v:imagedata\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    Map<String, String> placeHolderExternalblipIdsMap = new HashMap<String, String>();\n    for (String relaId : externalBlipIdsMap.keySet()) {\n        placeHolderExternalblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderExternalblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:link=\\\"\" + relaId) + \"\\\"\", (\"r:link=\\\"\" + placeHolderExternalblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // hyperlink id\n    for (String relaId : hyperlinkMap.keySet()) {\n        hyperlinkMap.put(relaId, hyperlinkMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : hyperlinkMap.keySet()) {\n        // w:hyperlink r:id\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + hyperlinkMap.get(relaId)) + \"\\\"\");\n    }\n    // chart id\n    for (String relaId : chartIdsMap.keySet()) {\n        chartIdsMap.put(relaId, chartIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : chartIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + chartIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // attachment id\n    for (String relaId : attachmentIdsMap.keySet()) {\n        attachmentIdsMap.put(relaId, attachmentIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : attachmentIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + attachmentIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // footnote id\n    for (String relaId : footnoteIdsMap.keySet()) {\n        footnoteIdsMap.put(relaId, footnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : footnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"footnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"footnoteReference w:id=\\\"\" + footnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // endnote id\n    for (String relaId : endnoteIdsMap.keySet()) {\n        endnoteIdsMap.put(relaId, endnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : endnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"endnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"endnoteReference w:id=\\\"\" + endnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // numbering numId\n    for (String relaId : numIdsMap.keySet()) {\n        numIdsMap.put(relaId, numIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String numId : numIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:numId\\\\sw:val=\\\"\" + numId) + \"\\\"\", (\"<w:numId w:val=\\\"\" + numIdsMap.get(numId)) + \"\\\"\");\n    }\n    return addPart.replaceAll(CROSS_REPLACE_STRING, \"\");\n}", "protected Map<String, String> mergeEndnote(NiceXWPFDocument source, NiceXWPFDocument merged) {\n    Map<String, String> blipIdsMap = new HashMap<>();\n    FootnoteEndnoteIdManager footnoteEndnoteIdManager = new FootnoteEndnoteIdManager(source);\n    List<XWPFEndnote> endnotes = merged.getEndnotes();\n    if (!endnotes.isEmpty()) {\n        XWPFEndnotes sourceEndnotes = source.createEndnotes();\n        for (XWPFEndnote endnote : endnotes) {\n            String relationId = endnote.getId().toString();\n            endnote.getCTFtnEdn().setId(footnoteEndnoteIdManager.nextId());\n            sourceEndnotes.addEndnote(endnote);\n            String blidId = endnote.getId().toString();\n            blipIdsMap.put(relationId, blidId);\n        }\n    }\n    return blipIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFEndnotes.addEndnote",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableString", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeEndnote" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "protected String createMergeableString(NiceXWPFDocument source, NiceXWPFDocument merged, Map<String, String> styleIdsMap) throws InvalidFormatException, IOException {\n    CTBody mergedBody = merged.getDocument().getBody();\n    // TODO For the same style, reduce the number of merges\n    // Map<String, String> styleIdsMap = mergeStyles(docMerge);\n    Map<String, String> numIdsMap = mergeNumbering(source, merged);\n    Map<String, String> blipIdsMap = mergePicture(source, merged);\n    Map<String, String> externalBlipIdsMap = mergeExternalPicture(source, merged);\n    Map<String, String> hyperlinkMap = mergeHyperlink(source, merged);\n    Map<String, String> chartIdsMap = mergeChart(source, merged);\n    Map<String, String> attachmentIdsMap = mergeAttachment(source, merged);\n    Map<String, String> footnoteIdsMap = mergeFootnote(source, merged);\n    Map<String, String> endnoteIdsMap = mergeEndnote(source, merged);\n    String appendString = mergedBody.xmlText(DefaultXmlOptions.OPTIONS_OUTER);\n    String addPart = ridSectPr(appendString);\n    // style\n    for (String styleId : styleIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:pStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:pStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:tblStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:tblStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:rStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:rStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\");\n    }\n    // picture id\n    Map<String, String> placeHolderblipIdsMap = new HashMap<String, String>();\n    for (String relaId : blipIdsMap.keySet()) {\n        placeHolderblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:embed=\\\"\" + relaId) + \"\\\"\", (\"r:embed=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n        // w:pict v:shape v:imagedata\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    Map<String, String> placeHolderExternalblipIdsMap = new HashMap<String, String>();\n    for (String relaId : externalBlipIdsMap.keySet()) {\n        placeHolderExternalblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderExternalblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:link=\\\"\" + relaId) + \"\\\"\", (\"r:link=\\\"\" + placeHolderExternalblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // hyperlink id\n    for (String relaId : hyperlinkMap.keySet()) {\n        hyperlinkMap.put(relaId, hyperlinkMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : hyperlinkMap.keySet()) {\n        // w:hyperlink r:id\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + hyperlinkMap.get(relaId)) + \"\\\"\");\n    }\n    // chart id\n    for (String relaId : chartIdsMap.keySet()) {\n        chartIdsMap.put(relaId, chartIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : chartIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + chartIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // attachment id\n    for (String relaId : attachmentIdsMap.keySet()) {\n        attachmentIdsMap.put(relaId, attachmentIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : attachmentIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + attachmentIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // footnote id\n    for (String relaId : footnoteIdsMap.keySet()) {\n        footnoteIdsMap.put(relaId, footnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : footnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"footnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"footnoteReference w:id=\\\"\" + footnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // endnote id\n    for (String relaId : endnoteIdsMap.keySet()) {\n        endnoteIdsMap.put(relaId, endnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : endnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"endnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"endnoteReference w:id=\\\"\" + endnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // numbering numId\n    for (String relaId : numIdsMap.keySet()) {\n        numIdsMap.put(relaId, numIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String numId : numIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:numId\\\\sw:val=\\\"\" + numId) + \"\\\"\", (\"<w:numId w:val=\\\"\" + numIdsMap.get(numId)) + \"\\\"\");\n    }\n    return addPart.replaceAll(CROSS_REPLACE_STRING, \"\");\n}", "protected Map<String, String> mergeEndnote(NiceXWPFDocument source, NiceXWPFDocument merged) {\n    Map<String, String> blipIdsMap = new HashMap<>();\n    FootnoteEndnoteIdManager footnoteEndnoteIdManager = new FootnoteEndnoteIdManager(source);\n    List<XWPFEndnote> endnotes = merged.getEndnotes();\n    if (!endnotes.isEmpty()) {\n        XWPFEndnotes sourceEndnotes = source.createEndnotes();\n        for (XWPFEndnote endnote : endnotes) {\n            String relationId = endnote.getId().toString();\n            endnote.getCTFtnEdn().setId(footnoteEndnoteIdManager.nextId());\n            sourceEndnotes.addEndnote(endnote);\n            String blidId = endnote.getId().toString();\n            blipIdsMap.put(relationId, blidId);\n        }\n    }\n    return blipIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setExplosion",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.addNewExplosion",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setExplosion" ],
    "fullMethods" : [ "public void setExplosion(Long explosion) {\n    if (explosion == null) {\n        if (series.isSetExplosion()) {\n            series.unsetExplosion();\n        }\n    } else if (series.isSetExplosion()) {\n        series.getExplosion().setVal(explosion);\n    } else {\n        series.addNewExplosion().setVal(explosion);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.toc.TOCRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.insertNewFieldRun",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.toc.TOCRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    XWPFRun run = ((RunTemplate) (eleTemplate)).getRun();\n    run.setText(\"\", 0);\n    XWPFParagraph tocPara = ((XWPFParagraph) (run.getParent()));\n    XWPFFieldRun fieldRun = tocPara.insertNewFieldRun(0);\n    CTSimpleField toc = fieldRun.getCTField();\n    toc.setInstr(\"TOC \\\\o\");\n    toc.setDirty(XWPFOnOff.ON);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.getCat",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>" ],
    "fullMethods" : [ "public XDDFOfPieChartData(XDDFChart parent, CTOfPieChart chart) {\n    super(parent);\n    this.chart = chart;\n    this.seriesNum = parent.getChartSeries().size();\n    for (CTPieSer series : chart.getSerList()) {\n        this.series.add(new Series(series, series.getCat(), series.getVal()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TextRenderPolicy.Helper.renderTextRun",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTBookmark.setName",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.policy.TextRenderPolicy.Helper.renderTextRun", "com.deepoove.poi.policy.TextRenderPolicy.Helper.createBookmark" ],
    "fullMethods" : [ "public static void renderTextRun(XWPFRun run, TextRenderData data) {\n    XWPFRun textRun = run;\n    if (data instanceof HyperlinkTextRenderData) {\n        textRun = createHyperlink(run, ((HyperlinkTextRenderData) (data)).getUrl());\n    }\n    StyleUtils.styleRun(textRun, data.getStyle());\n    String text = Optional.ofNullable(data.getText()).orElse(\"\");\n    String[] fragment = text.split(REGEX_LINE_CHARACTOR, -1);\n    if (fragment.length > 0) {\n        textRun.setText(fragment[0], 0);\n        boolean lineAtTable = ((fragment.length > 1) && (!(data instanceof HyperlinkTextRenderData))) && TableTools.isInsideTable(run);\n        for (int i = 1; i < fragment.length; i++) {\n            if (lineAtTable) {\n                textRun.addBreak(BreakType.TEXT_WRAPPING);\n            } else {\n                textRun.addCarriageReturn();\n            }\n            textRun.setText(fragment[i]);\n        }\n    }\n    if (data instanceof BookmarkTextRenderData) {\n        createBookmark(textRun, ((BookmarkTextRenderData) (data)).getBookmark());\n    }\n}", "private static void createBookmark(XWPFRun textRun, String name) {\n    XWPFParagraphWrapper wapper = new XWPFParagraphWrapper(((XWPFParagraph) (textRun.getParent())));\n    CTBookmark bookmarkStart = wapper.insertNewBookmark(textRun);\n    bookmarkStart.setName(name);\n    // bookmarkStart.setName(Base64.getEncoder().encodeToString(text.getBytes()));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.bookmark.BookmarkRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTBookmark.setName",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.bookmark.BookmarkRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(RenderContext<TextRenderData> context) throws Exception {\n    Helper.renderTextRun(context.getRun(), context.getData());\n    XWPFRun run = context.getRun();\n    XWPFParagraphWrapper wapper = new XWPFParagraphWrapper(((XWPFParagraph) (run.getParent())));\n    CTBookmark bookmarkStart = wapper.insertNewBookmark(run);\n    Object renderData = context.getData();\n    TextRenderData data = (renderData instanceof TextRenderData) ? ((TextRenderData) (renderData)) : new TextRenderData(renderData.toString());\n    String text = (null == data.getText()) ? \"\" : data.getText();\n    bookmarkStart.setName(text);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ParagraphUtils.haveObject",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTR.getObjectList",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.ParagraphUtils.haveObject" ],
    "fullMethods" : [ "public static boolean haveObject(XWPFParagraph paragraph) {\n    List<XWPFRun> runs = paragraph.getRuns();\n    for (XWPFRun run : runs) {\n        if (CollectionUtils.isNotEmpty(run.getCTR().getObjectList()))\n            return true;\n\n    }\n    return false;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.PictureRenderPolicy.Helper.renderPicture",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.setAlignment",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.PictureRenderPolicy.Helper.renderPicture" ],
    "fullMethods" : [ "public static void renderPicture(XWPFRun run, PictureRenderData picture) throws Exception {\n    byte[] imageBytes = picture.readPictureData();\n    if (null == imageBytes) {\n        throw new IllegalStateException(\"Can't read picture byte arrays!\");\n    }\n    PictureType pictureType = picture.getPictureType();\n    if (null == pictureType) {\n        pictureType = PictureType.suggestFileType(imageBytes);\n    }\n    if (null == pictureType) {\n        throw new RenderException(\"PictureRenderData must set picture type!\");\n    }\n    PictureStyle style = picture.getPictureStyle();\n    if (null == style)\n        style = new PictureStyle();\n\n    int width = style.getWidth();\n    int height = style.getHeight();\n    int svgScale = style.getSvgScale();\n    if (pictureType == PictureType.SVG) {\n        imageBytes = SVGConvertor.toPng(imageBytes, ((float) (width)), ((float) (height)), svgScale);\n        pictureType = PictureType.PNG;\n    }\n    if (!isSetSize(style)) {\n        BufferedImage original = BufferedImageUtils.readBufferedImage(imageBytes);\n        width = original.getWidth();\n        height = original.getHeight();\n        if (style.getScalePattern() == WidthScalePattern.FIT) {\n            BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n            int pageWidth = UnitUtils.twips2Pixel(bodyContainer.elementPageWidth(((IBodyElement) (run.getParent()))));\n            if (width > pageWidth) {\n                double ratio = pageWidth / ((double) (width));\n                width = pageWidth;\n                height = ((int) (height * ratio));\n            }\n        }\n    }\n    try (InputStream stream = new ByteArrayInputStream(imageBytes)) {\n        PictureAlign align = style.getAlign();\n        if ((null != align) && (run.getParent() instanceof XWPFParagraph)) {\n            ((XWPFParagraph) (run.getParent())).setAlignment(ParagraphAlignment.valueOf(align.ordinal() + 1));\n        }\n        run.addPicture(stream, pictureType.type(), \"Generated\", Units.pixelToEMU(width), Units.pixelToEMU(height));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.setAlignment",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTComment.getId",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment" ],
    "fullMethods" : [ "public static void renderComment(XWPFRun run, CommentRenderData data) throws Exception {\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper parentContext = new XWPFParagraphWrapper(paragraph);\n    BigInteger cId = BigInteger.ZERO;\n    CommentContent commentContent = data.getCommentContent();\n    if (null != commentContent) {\n        XWPFComments comments = ((NiceXWPFDocument) (paragraph.getDocument())).createComments();\n        XWPFComment newComment = comments.createComment(NextIDUtils.getCommentMaxId(comments).add(BigInteger.ONE));\n        newComment.setAuthor(commentContent.getAuthor());\n        newComment.setDate(commentContent.getDate());\n        newComment.setInitials(commentContent.getInitials());\n        renderDocument(newComment.createParagraph().createRun(), commentContent.getContent());\n        cId = newComment.getCtComment().getId();\n        parentContext.insertNewCommentRangeStart(run, cId);\n    }\n    renderParagraph(run, Paragraphs.of().addList(data.getContents()).create());\n    if (null != commentContent) {\n        parentContext.insertNewCommentRangeEnd(run, cId);\n        XWPFRun newRun = parentContext.insertNewRun(ParagraphUtils.getRunPos(run));\n        newRun.getCTR().addNewCommentReference().setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.NextIDUtils.getCommentMaxId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTComment.getId",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.NextIDUtils.getCommentMaxId" ],
    "fullMethods" : [ "public static BigInteger getCommentMaxId(XWPFComments docComments) {\n    List<XWPFComment> comments = docComments.getComments();\n    BigInteger max = BigInteger.ZERO;\n    if (null == comments)\n        return max;\n\n    for (XWPFComment comment : comments) {\n        BigInteger id = comment.getCtComment().getId();\n        if ((null != id) && (id.compareTo(max) == 1)) {\n            max = id;\n        }\n    }\n    return max;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toPrevSibling",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph" ],
    "fullMethods" : [ "@Override\npublic XWPFParagraph insertNewParagraph(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTP.type.getName().getNamespaceURI();\n        /* TODO DO not use a coded constant, find the constant in the OOXML\n        classes instead, as the child of type CT_Paragraph is defined in the\n        OOXML schema as 'p'\n         */\n        String localPart = \"p\";\n        // creates a new Paragraph, cursor is positioned inside the new\n        // element\n        cursor.beginElement(localPart, uri);\n        // move the cursor to the START token to the paragraph just created\n        cursor.toParent();\n        CTP p = ((CTP) (cursor.getObject()));\n        XWPFParagraph newP = new XWPFParagraph(p, this);\n        XmlObject o = null;\n        /* move the cursor to the previous element until a) the next\n        paragraph is found or b) all elements have been passed\n         */\n        while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        /* if the object that has been found is a) not a paragraph or b) is\n        the paragraph that has just been inserted, as the cursor in the\n        while loop above was not moved as there were no other siblings,\n        then the paragraph that was just inserted is the first paragraph\n        in the body. Otherwise, take the previous paragraph and calculate\n        the new index for the new paragraph.\n         */\n        if ((!(o instanceof CTP)) || (o == p)) {\n            paragraphs.add(0, newP);\n        } else {\n            int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n            paragraphs.add(pos, newP);\n        }\n        /* create a new cursor, that points to the START token of the just\n        inserted paragraph\n         */\n        XmlCursor newParaPos = p.newCursor();\n        try {\n            /* Calculate the paragraphs index in the list of all body\n            elements\n             */\n            int i = 0;\n            cursor.toCursor(newParaPos);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newP);\n            cursor.toCursor(newParaPos);\n            cursor.toEndToken();\n            return newP;\n        } finally {\n            newParaPos.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toPrevSibling",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph" ],
    "fullMethods" : [ "/**\n * add a new paragraph at position of the cursor\n *\n * @param cursor\n * \t\tThe XmlCursor structure created with XmlBeans\n * @return the inserted paragraph\n */\n@Override\npublic XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInTextBox(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    bodyElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toPrevSibling",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.IterableProcessor.next",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toPrevSibling",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.render.processor.IterableProcessor.next" ],
    "fullMethods" : [ "@Override\npublic void next(IterableTemplate iterable, ParentContext parentContext, IterableContext context, Object model) {\n    BodyContainer bodyContainer = ((BodyContainer) (parentContext));\n    XWPFParagraph endParagraph = ((XWPFParagraph) (iterable.getEndRun().getParent()));\n    CTP endCtp = endParagraph.getCTP();\n    int start = context.getStart();\n    int end = context.getEnd();\n    context.getNumberingContinue().resetCache();\n    // copy positon cursor\n    XmlCursor insertPostionCursor = endCtp.newCursor();\n    // copy content\n    List<IBodyElement> bodyElements = bodyContainer.getBodyElements();\n    List<IBodyElement> copies = new ArrayList<IBodyElement>();\n    for (int i = start + 1; i < end; i++) {\n        IBodyElement iBodyElement = bodyElements.get(i);\n        if (iBodyElement.getElementType() == BodyElementType.PARAGRAPH) {\n            insertPostionCursor = endCtp.newCursor();\n            XWPFParagraph insertNewParagraph = bodyContainer.insertNewParagraph(insertPostionCursor);\n            // find insert paragraph pos\n            int paraPos = bodyContainer.getParaPos(insertNewParagraph);\n            bodyContainer.setParagraph(((XWPFParagraph) (iBodyElement)), paraPos);\n            // re-update ctp reference\n            insertPostionCursor = endCtp.newCursor();\n            insertPostionCursor.toPrevSibling();\n            XmlObject object = insertPostionCursor.getObject();\n            XWPFParagraph copy = new XWPFParagraph(((CTP) (object)), bodyContainer.getTarget());\n            // update docpr\n            DrawingSupport.updateDocPrId(copy);\n            // update numbering\n            context.getNumberingContinue().updateNumbering(((XWPFParagraph) (iBodyElement)), copy);\n            copies.add(copy);\n            bodyContainer.updateBodyElements(insertNewParagraph, copy);\n            bodyContainer.setParagraph(copy, paraPos);\n        } else if (iBodyElement.getElementType() == BodyElementType.TABLE) {\n            insertPostionCursor = endCtp.newCursor();\n            XWPFTable insertNewTbl = bodyContainer.insertNewTbl(insertPostionCursor);\n            // find insert table pos\n            int tablePos = bodyContainer.getTablePos(insertNewTbl);\n            bodyContainer.setTable(tablePos, ((XWPFTable) (iBodyElement)));\n            insertPostionCursor = endCtp.newCursor();\n            insertPostionCursor.toPrevSibling();\n            XmlObject object = insertPostionCursor.getObject();\n            XWPFTable copy = new XWPFTable(((CTTbl) (object)), bodyContainer.getTarget());\n            DrawingSupport.updateDocPrId(copy);\n            copies.add(copy);\n            bodyContainer.updateBodyElements(insertNewTbl, copy);\n            bodyContainer.setTable(tablePos, copy);\n        }\n    }\n    // re-parse\n    List<MetaTemplate> templates = this.resolver.resolveBodyElements(copies);\n    // render\n    process(templates, model);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toPrevSibling",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph" ],
    "fullMethods" : [ "public XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInBlockContent(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    sdtElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewTbl",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toPrevSibling",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewTbl" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTbl(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTTbl.type.getName().getNamespaceURI();\n        String localPart = \"tbl\";\n        cursor.beginElement(localPart, uri);\n        cursor.toParent();\n        CTTbl t = ((CTTbl) (cursor.getObject()));\n        XWPFTable newT = new XWPFTable(t, this);\n        XmlObject o = null;\n        while ((!(o instanceof CTTbl)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        if (!(o instanceof CTTbl)) {\n            tables.add(0, newT);\n        } else {\n            int pos = tables.indexOf(getTable(((CTTbl) (o)))) + 1;\n            tables.add(pos, newT);\n        }\n        int i = 0;\n        XmlCursor tableCursor = t.newCursor();\n        try {\n            cursor.toCursor(tableCursor);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newT);\n            cursor.toCursor(tableCursor);\n            cursor.toEndToken();\n            return newT;\n        } finally {\n            tableCursor.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.InlineIterableProcessor.next",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toPrevSibling",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.render.processor.InlineIterableProcessor.next" ],
    "fullMethods" : [ "@Override\npublic void next(IterableTemplate iterable, ParentContext parentContext, IterableContext context, Object model) {\n    RunBodyContext paragraphContext = ((RunBodyContext) (parentContext));\n    RunTemplate end = iterable.getEndMark();\n    CTR endCtr = end.getRun().getCTR();\n    int startPos = context.getStart();\n    int endPos = context.getEnd();\n    // copy position cursor\n    int insertPostionCursor = end.getRunPos();\n    // copy content\n    List<XWPFRun> runs = paragraphContext.getRuns();\n    List<XWPFRun> copies = new ArrayList<XWPFRun>();\n    for (int i = startPos + 1; i < endPos; i++) {\n        insertPostionCursor = end.getRunPos();\n        XWPFRun xwpfRun = runs.get(i);\n        XWPFRun insertNewRun = paragraphContext.insertNewRun(xwpfRun, insertPostionCursor);\n        XWPFRun replaceXwpfRun = paragraphContext.createRun(xwpfRun, paragraphContext.getTarget());\n        paragraphContext.setAndUpdateRun(replaceXwpfRun, insertNewRun, insertPostionCursor);\n        XmlCursor newCursor = endCtr.newCursor();\n        newCursor.toPrevSibling();\n        XmlObject object = newCursor.getObject();\n        XWPFRun copy = paragraphContext.createRun(object, paragraphContext.getTarget());\n        DrawingSupport.updateDocPrId(copy);\n        copies.add(copy);\n        paragraphContext.setAndUpdateRun(copy, replaceXwpfRun, insertPostionCursor);\n    }\n    // re-parse\n    List<MetaTemplate> templates = this.resolver.resolveXWPFRuns(copies);\n    // render\n    process(templates, model);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toPrevSibling",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toPrevSibling",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        if ((null != data) && (data instanceof Iterable)) {\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            XWPFTableRow templateRow = table.getRow(templateRowIndex);\n            int insertPosition = templateRowIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            boolean firstFlag = true;\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateRowIndex++;\n                XWPFTableRow nextRow = table.insertNewTableRow(insertPosition);\n                setTableRow(table, templateRow, insertPosition);\n                // double set row\n                XmlCursor newCursor = templateRow.getCtRow().newCursor();\n                newCursor.toPrevSibling();\n                XmlObject object = newCursor.getObject();\n                nextRow = new XWPFTableRow(((CTRow) (object)), table);\n                if (!firstFlag) {\n                    // update VMerge cells for non-first row\n                    List<XWPFTableCell> tableCells = nextRow.getTableCells();\n                    for (XWPFTableCell cell : tableCells) {\n                        CTTcPr tcPr = TableTools.getTcPr(cell);\n                        CTVMerge vMerge = tcPr.getVMerge();\n                        if (null == vMerge)\n                            continue;\n\n                        if (STMerge.RESTART == vMerge.getVal()) {\n                            vMerge.setVal(STMerge.CONTINUE);\n                        }\n                    }\n                } else {\n                    firstFlag = false;\n                }\n                setTableRow(table, nextRow, insertPosition);\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                List<XWPFTableCell> cells = nextRow.getTableCells();\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        table.removeRow(templateRowIndex);\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \" error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toPrevSibling",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    try {\n        RunTemplate runTemplate = cast2runTemplate(eleTemplate);\n        XWPFRun run = runTemplate.getRun();\n        checkTargetIsTable(run, (\"Processing [\" + runTemplate.getTagName()) + \"] failed, the target content is not a table\");\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        final XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n        // \n        int position = getRowIndex(tagCell.getTableRow());\n        List<XWPFTableRow> tempRows = getAllTemplateRow(table, position);\n        if ((null != data) && (data instanceof Iterable)) {\n            // \n            final XWPFTableRow firstTempRow = tempRows.get(0);\n            Iterator<?> dataIt = ((Iterable<?>) (data)).iterator();\n            boolean hasNextData = dataIt.hasNext();\n            int index = 0;\n            while (hasNextData) {\n                Object dt = dataIt.next();\n                hasNextData = dataIt.hasNext();\n                Iterator<XWPFTableRow> rowTempIt = tempRows.iterator();\n                boolean hasNextTempRow = rowTempIt.hasNext();\n                while (hasNextTempRow) {\n                    XWPFTableRow tempRow = rowTempIt.next();\n                    hasNextTempRow = rowTempIt.hasNext();\n                    if (!table.addRow(tempRow, position)) {\n                        throw new RenderException(\"\");\n                    }\n                    // \n                    XmlCursor newCursor = firstTempRow.getCtRow().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    XWPFTableRow newRow = new XWPFTableRow(((CTRow) (object)), table);\n                    newRow.getCtRow().set(object);\n                    setTableRow(table, newRow, position);\n                    List<XWPFTableCell> cells = newRow.getTableCells();\n                    RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(dt, EnvIterator.makeEnv(index, hasNextData || hasNextTempRow)));\n                    cells.forEach(tableCell -> {\n                        List<MetaTemplate> metaTemplates = resolver.resolveBodyElements(tableCell.getBodyElements());\n                        new DocumentProcessor(template, resolver, dataCompute).process(metaTemplates);\n                    });\n                    ++position;\n                } \n                ++index;\n            } \n        }\n        removeTableRow(table, position, tempRows.size());\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-row template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableRow",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRow.isSetTrPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableRow" ],
    "fullMethods" : [ "/**\n * set row style\n *\n * @param row\n * @param rowStyle\n */\npublic static void styleTableRow(XWPFTableRow row, RowStyle rowStyle) {\n    if ((null == row) || (null == rowStyle))\n        return;\n\n    int height = rowStyle.getHeight();\n    CTRow ctRow = row.getCtRow();\n    CTTrPr properties = (ctRow.isSetTrPr()) ? ctRow.getTrPr() : ctRow.addNewTrPr();\n    if (0 != height) {\n        row.setHeight(height);\n        CTHeight h = (properties.sizeOfTrHeightArray() == 0) ? properties.addNewTrHeight() : properties.getTrHeightArray(0);\n        String heightRule = rowStyle.getHeightRule();\n        if (\"exact\".equals(heightRule))\n            h.setHRule(STHeightRule.EXACT);\n        else if (\"atleast\".equals(heightRule))\n            h.setHRule(STHeightRule.AT_LEAST);\n        else\n            h.setHRule(STHeightRule.AUTO);\n\n    }\n    boolean repeated = rowStyle.isRepeated();\n    if (repeated) {\n        CTOnOff tblHeader = (properties.sizeOfTblHeaderArray() == 0) ? properties.addNewTblHeader() : properties.getTblHeaderArray(0);\n        tblHeader.setVal(XWPFOnOff.ON);\n    }\n    boolean breakAcrossPage = rowStyle.isBreakAcrossPage();\n    if (!breakAcrossPage) {\n        if (properties.sizeOfCantSplitArray() == 0) {\n            properties.addNewCantSplit();\n        } else {\n            properties.getCantSplitArray(0).setVal(XWPFOnOff.ON);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.SDTContentContext.createRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFFieldRun.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.SDTContentContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XmlObject object, IRunBody p) {\n    if (object instanceof CTHyperlink) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (object)), ((CTHyperlink) (object)).getRArray(0), p);\n    } else if (object instanceof CTSimpleField) {\n        return new XWPFFieldRun(((CTSimpleField) (object)), ((CTSimpleField) (object)).getRArray(0), p);\n    } else {\n        return new XWPFRun(((CTR) (object)), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.SDTContentContext.createRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFFieldRun.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.SDTContentContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XWPFRun xwpfRun, IRunBody p) {\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink().copy())), ((CTR) (((XWPFHyperlinkRun) (xwpfRun)).getCTR().copy())), p);\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        return new XWPFFieldRun(((CTSimpleField) (((XWPFFieldRun) (xwpfRun)).getCTField().copy())), ((CTR) (((XWPFFieldRun) (xwpfRun)).getCTR().copy())), p);\n    } else {\n        return new XWPFRun(((CTR) (xwpfRun.getCTR().copy())), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.ParagraphContext.createRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFFieldRun.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.ParagraphContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XmlObject object, IRunBody p) {\n    if (object instanceof CTHyperlink) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (object)), ((CTHyperlink) (object)).getRArray(0), p);\n    } else if (object instanceof CTSimpleField) {\n        return new XWPFFieldRun(((CTSimpleField) (object)), ((CTSimpleField) (object)).getRArray(0), p);\n    } else {\n        return new XWPFRun(((CTR) (object)), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewField",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFFieldRun.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewField" ],
    "fullMethods" : [ "public XWPFFieldRun insertNewField(int pos) {\n    if ((pos >= 0) && (pos <= paragraph.getRuns().size())) {\n        CTSimpleField ctSimpleField = this.insertNewFldSimple(pos);\n        CTR addNewR = ctSimpleField.addNewR();\n        XWPFFieldRun newRun = new XWPFFieldRun(ctSimpleField, addNewR, ((IRunBody) (paragraph)));\n        // To update the iruns, find where we're going\n        // in the normal runs, and go in there\n        updateRunsAndIRuns(pos, newRun);\n        return newRun;\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.ParagraphContext.createRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFFieldRun.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.ParagraphContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XWPFRun xwpfRun, IRunBody p) {\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink().copy())), ((CTR) (((XWPFHyperlinkRun) (xwpfRun)).getCTR().copy())), p);\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        return new XWPFFieldRun(((CTSimpleField) (((XWPFFieldRun) (xwpfRun)).getCTField().copy())), ((CTR) (((XWPFFieldRun) (xwpfRun)).getCTR().copy())), p);\n    } else {\n        return new XWPFRun(((CTR) (xwpfRun.getCTR().copy())), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.TextBoxBodyContainer.removeBodyElement",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.IBodyElement.getElementType",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.TextBoxBodyContainer.removeBodyElement" ],
    "fullMethods" : [ "@Override\npublic void removeBodyElement(int pos) {\n    List<IBodyElement> bodyElements = getBodyElements();\n    if ((pos >= 0) && (pos < bodyElements.size())) {\n        BodyElementType type = bodyElements.get(pos).getElementType();\n        if (type == BodyElementType.TABLE) {\n            // TODO remove table\n        }\n        if (type == BodyElementType.PARAGRAPH) {\n            textbox.removeParagraph(((XWPFParagraph) (bodyElements.get(pos))));\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.removeBodyElement",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.IBodyElement.getElementType",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.removeBodyElement" ],
    "fullMethods" : [ "@Override\npublic void removeBodyElement(int pos) {\n    List<IBodyElement> bodyElements = getBodyElements();\n    if ((pos >= 0) && (pos < bodyElements.size())) {\n        BodyElementType type = bodyElements.get(pos).getElementType();\n        if (type == BodyElementType.TABLE) {\n            headerFooter.removeTable(((XWPFTable) (bodyElements.get(pos))));\n        }\n        if (type == BodyElementType.PARAGRAPH) {\n            headerFooter.removeParagraph(((XWPFParagraph) (bodyElements.get(pos))));\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.IBodyElement.getElementType",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveBodyElements(List<IBodyElement> bodyElements) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (null == bodyElements)\n        return metaTemplates;\n\n    // current iterable templates state\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    for (IBodyElement element : bodyElements) {\n        if (element == null)\n            continue;\n\n        if (element.getElementType() == BodyElementType.PARAGRAPH) {\n            resolveParagraph(((XWPFParagraph) (element)), metaTemplates, stack);\n        } else if (element.getElementType() == BodyElementType.TABLE) {\n            XWPFTable table = ((XWPFTable) (element));\n            List<XWPFTableRow> rows = table.getRows();\n            if (null == rows)\n                continue;\n\n            for (XWPFTableRow row : rows) {\n                resolveTableRow(row, metaTemplates, stack);\n            }\n        } else if ((element.getElementType() == BodyElementType.CONTENTCONTROL) && (element instanceof XWPFStructuredDocumentTag)) {\n            XWPFStructuredDocumentTag sdt = ((XWPFStructuredDocumentTag) (element));\n            addNewMeta(metaTemplates, stack, resolveSDTElements(sdt.getContent()));\n        }\n    }\n    checkStack(stack);\n    return metaTemplates;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.SDTBodyContainer.removeBodyElement",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.IBodyElement.getElementType",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.SDTBodyContainer.removeBodyElement" ],
    "fullMethods" : [ "@Override\npublic void removeBodyElement(int pos) {\n    List<IBodyElement> bodyElements = getBodyElements();\n    if ((pos >= 0) && (pos < bodyElements.size())) {\n        BodyElementType type = bodyElements.get(pos).getElementType();\n        if (type == BodyElementType.TABLE) {\n            // TODO remove table\n        }\n        if (type == BodyElementType.PARAGRAPH) {\n            sdtContent.removeParagraph(((XWPFParagraph) (bodyElements.get(pos))));\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.removeBodyElement",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.IBodyElement.getElementType",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.removeBodyElement" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void removeBodyElement(int pos) {\n    // TODO remove Nest Table\n    List<IBodyElement> bodyElements = getBodyElements();\n    if ((pos >= 0) && (pos < bodyElements.size())) {\n        BodyElementType type = bodyElements.get(pos).getElementType();\n        if (type == BodyElementType.TABLE) {\n            int indexOf = cell.getTables().indexOf(bodyElements.get(pos));\n            // remove cell's table\n            List<XWPFTable> tables = ((List<XWPFTable>) (ReflectionUtils.getValue(\"tables\", cell)));\n            tables.remove(indexOf);\n            cell.getCTTc().removeTbl(indexOf);\n        }\n        if (type == BodyElementType.PARAGRAPH) {\n            int indexOf = cell.getParagraphs().indexOf(bodyElements.get(pos));\n            // cell.removeParagraph may has bug\n            // cell.removeParagraph(indexOf);\n            List<XWPFParagraph> paragraphs = ((List<XWPFParagraph>) (ReflectionUtils.getValue(\"paragraphs\", cell)));\n            paragraphs.remove(indexOf);\n            cell.getCTTc().removeP(indexOf);\n        }\n        bodyElements.remove(pos);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.IterableProcessor.next",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.IBodyElement.getElementType",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.IterableProcessor.next" ],
    "fullMethods" : [ "@Override\npublic void next(IterableTemplate iterable, ParentContext parentContext, IterableContext context, Object model) {\n    BodyContainer bodyContainer = ((BodyContainer) (parentContext));\n    XWPFParagraph endParagraph = ((XWPFParagraph) (iterable.getEndRun().getParent()));\n    CTP endCtp = endParagraph.getCTP();\n    int start = context.getStart();\n    int end = context.getEnd();\n    context.getNumberingContinue().resetCache();\n    // copy positon cursor\n    XmlCursor insertPostionCursor = endCtp.newCursor();\n    // copy content\n    List<IBodyElement> bodyElements = bodyContainer.getBodyElements();\n    List<IBodyElement> copies = new ArrayList<IBodyElement>();\n    for (int i = start + 1; i < end; i++) {\n        IBodyElement iBodyElement = bodyElements.get(i);\n        if (iBodyElement.getElementType() == BodyElementType.PARAGRAPH) {\n            insertPostionCursor = endCtp.newCursor();\n            XWPFParagraph insertNewParagraph = bodyContainer.insertNewParagraph(insertPostionCursor);\n            // find insert paragraph pos\n            int paraPos = bodyContainer.getParaPos(insertNewParagraph);\n            bodyContainer.setParagraph(((XWPFParagraph) (iBodyElement)), paraPos);\n            // re-update ctp reference\n            insertPostionCursor = endCtp.newCursor();\n            insertPostionCursor.toPrevSibling();\n            XmlObject object = insertPostionCursor.getObject();\n            XWPFParagraph copy = new XWPFParagraph(((CTP) (object)), bodyContainer.getTarget());\n            // update docpr\n            DrawingSupport.updateDocPrId(copy);\n            // update numbering\n            context.getNumberingContinue().updateNumbering(((XWPFParagraph) (iBodyElement)), copy);\n            copies.add(copy);\n            bodyContainer.updateBodyElements(insertNewParagraph, copy);\n            bodyContainer.setParagraph(copy, paraPos);\n        } else if (iBodyElement.getElementType() == BodyElementType.TABLE) {\n            insertPostionCursor = endCtp.newCursor();\n            XWPFTable insertNewTbl = bodyContainer.insertNewTbl(insertPostionCursor);\n            // find insert table pos\n            int tablePos = bodyContainer.getTablePos(insertNewTbl);\n            bodyContainer.setTable(tablePos, ((XWPFTable) (iBodyElement)));\n            insertPostionCursor = endCtp.newCursor();\n            insertPostionCursor.toPrevSibling();\n            XmlObject object = insertPostionCursor.getObject();\n            XWPFTable copy = new XWPFTable(((CTTbl) (object)), bodyContainer.getTarget());\n            DrawingSupport.updateDocPrId(copy);\n            copies.add(copy);\n            bodyContainer.updateBodyElements(insertNewTbl, copy);\n            bodyContainer.setTable(tablePos, copy);\n        }\n    }\n    // re-parse\n    List<MetaTemplate> templates = this.resolver.resolveBodyElements(copies);\n    // render\n    process(templates, model);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CommentBodyContainer.removeBodyElement",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.IBodyElement.getElementType",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CommentBodyContainer.removeBodyElement" ],
    "fullMethods" : [ "@Override\npublic void removeBodyElement(int pos) {\n    List<IBodyElement> bodyElements = getBodyElements();\n    if ((pos >= 0) && (pos < bodyElements.size())) {\n        BodyElementType type = bodyElements.get(pos).getElementType();\n        if (type == BodyElementType.TABLE) {\n            comment.removeTable(((XWPFTable) (bodyElements.get(pos))));\n        }\n        if (type == BodyElementType.PARAGRAPH) {\n            comment.removeParagraph(((XWPFParagraph) (bodyElements.get(pos))));\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.BodyContainer.getPosOfParagraphCTP",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.IBodyElement.getElementType",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.BodyContainer.getPosOfParagraphCTP" ],
    "fullMethods" : [ "/**\n * get the position of paragraph in bodyElements\n *\n * @param ctp\n * \t\tparagraph\n * @return the position of paragraph\n */\ndefault int getPosOfParagraphCTP(CTP ctp) {\n    IBodyElement current;\n    List<IBodyElement> bodyElements = getTarget().getBodyElements();\n    for (int i = 0; i < bodyElements.size(); i++) {\n        current = bodyElements.get(i);\n        if (current.getElementType() == BodyElementType.PARAGRAPH) {\n            if (((XWPFParagraph) (current)).getCTP().equals(ctp)) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.removeBodyElement",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.IBodyElement.getElementType",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.removeBodyElement" ],
    "fullMethods" : [ "@Override\npublic boolean removeBodyElement(int pos) {\n    if ((pos >= 0) && (pos < this.bodyElements.size())) {\n        BodyElementType type = ((IBodyElement) (this.bodyElements.get(pos))).getElementType();\n        int paraPos;\n        if (type == BodyElementType.TABLE) {\n            paraPos = this.getTablePos(pos);\n            this.tables.remove(paraPos);\n            this.getDocument().getBody().removeTbl(paraPos);\n        }\n        if (type == BodyElementType.PARAGRAPH) {\n            paraPos = this.getParagraphPos(pos);\n            this.paragraphs.remove(paraPos);\n            this.getDocument().getBody().removeP(paraPos);\n        }\n        if (type == BodyElementType.CONTENTCONTROL) {\n            paraPos = getBodyElementSpecificPos(pos, contentControls);\n            this.contentControls.remove(paraPos);\n            this.getDocument().getBody().removeSdt(paraPos);\n        }\n        this.bodyElements.remove(pos);\n        return true;\n    } else {\n        return false;\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.NumberingContinue.of",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.IBodyElement.getElementType",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.NumberingContinue.of" ],
    "fullMethods" : [ "public static NumberingContinue of(BodyContainer bodyContainer, int start, int end, IterableTemplate iterable) {\n    if ((start + 1) >= end)\n        return new NumberingContinue();\n\n    final List<IBodyElement> elements = bodyContainer.getBodyElements().subList(start + 1, end);\n    if (elements.isEmpty())\n        return new NumberingContinue();\n\n    CTNumPr first = null;\n    int firstPos = -1;\n    for (IBodyElement element : elements) {\n        if (element.getElementType() == BodyElementType.PARAGRAPH) {\n            XWPFParagraph paragraph = ((XWPFParagraph) (element));\n            CTP ctp = paragraph.getCTP();\n            if ((ctp.getPPr() != null) && (ctp.getPPr().getNumPr() != null)) {\n                CTNumPr numPr = ctp.getPPr().getNumPr();\n                // find first\n                if (null == first) {\n                    first = numPr;\n                    firstPos = bodyContainer.getPosOfParagraphCTP(ctp);\n                } else // first is not unique\n                if (Objects.equals(numPr.getIlvl().getVal(), first.getIlvl().getVal()) && Objects.equals(numPr.getNumId().getVal(), first.getNumId().getVal())) {\n                    first = null;\n                    break;\n                }\n            }\n        }\n    }\n    if (null == first)\n        return new NumberingContinue();\n\n    // the first is unique, if first inside other iterable section\n    List<MetaTemplate> templates = iterable.getTemplates();\n    for (MetaTemplate template : templates) {\n        if (template instanceof IterableTemplate) {\n            CTP startCtp = ((XWPFParagraph) (((IterableTemplate) (template)).getStartRun().getParent())).getCTP();\n            CTP endCtp = ((XWPFParagraph) (((IterableTemplate) (template)).getEndRun().getParent())).getCTP();\n            int startPos = bodyContainer.getPosOfParagraphCTP(startCtp);\n            if (startPos >= firstPos)\n                break;\n\n            int endPos = bodyContainer.getPosOfParagraphCTP(endCtp);\n            if ((firstPos > startPos) && (firstPos < endPos)) {\n                return new NumberingContinue();\n            }\n        }\n    }\n    return new NumberingContinue(first.getNumId().getVal());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.clearPlaceholder",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.IBodyElement.getElementType",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.clearPlaceholder", "com.deepoove.poi.xwpf.CellBodyContainer.canRemoveParagraph" ],
    "fullMethods" : [ "@Override\npublic void clearPlaceholder(XWPFRun run) {\n    IRunBody parent = run.getParent();\n    run.setText(\"\", 0);\n    // <p>elements must be located before </tc> elements\n    if (parent instanceof XWPFParagraph) {\n        String paragraphText = ParagraphUtils.trimLine(((XWPFParagraph) (parent)));\n        boolean havePictures = ParagraphUtils.havePictures(((XWPFParagraph) (parent)));\n        if (\"\".equals(paragraphText) && (!havePictures)) {\n            int pos = getPosOfParagraph(((XWPFParagraph) (parent)));\n            int lastPos = cell.getBodyElements().size() - 1;\n            if (canRemoveParagraph(pos, lastPos)) {\n                removeBodyElement(pos);\n            }\n        }\n    }\n}", "private boolean canRemoveParagraph(int pos, int lastPos) {\n    return (pos < lastPos) || ((pos > 0) && (cell.getBodyElements().get(pos - 1).getElementType() == BodyElementType.PARAGRAPH));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.BufferedImageUtils.getBufferByteArray",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isEmpty",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.util.BufferedImageUtils.getBufferByteArray" ],
    "fullMethods" : [ "/**\n * Get picture byte array of BufferedImage\n *\n * @param image\n * @param format\n * \t\tformat of the image\n * @return  */\npublic static byte[] getBufferByteArray(BufferedImage image, String format) {\n    if (null == image)\n        return null;\n\n    String formatName = (StringUtils.isNotEmpty(format) && (format.charAt(0) == '.')) ? format.substring(1) : format;\n    if (StringUtils.isEmpty(formatName))\n        formatName = \"png\";\n\n    ByteArrayOutputStream os = new ByteArrayOutputStream();\n    try {\n        ImageIO.write(image, formatName, os);\n        return os.toByteArray();\n    } catch (Exception e) {\n        logger.error(\"getBufferByteArray error\", e);\n        return null;\n    } finally {\n        IOUtils.closeQuietly(os);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShowLeaderLines",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.addNewDLbls",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShowLeaderLines" ],
    "fullMethods" : [ "@Override\npublic void setShowLeaderLines(boolean showLeaderLines) {\n    if (!series.isSetDLbls()) {\n        series.addNewDLbls();\n    }\n    if (series.getDLbls().isSetShowLeaderLines()) {\n        series.getDLbls().getShowLeaderLines().setVal(showLeaderLines);\n    } else {\n        series.getDLbls().addNewShowLeaderLines().setVal(showLeaderLines);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isNotBlank",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun" ],
    "fullMethods" : [ "/**\n * set run style by other run\n *\n * @param dest\n * @param src\n */\npublic static void styleRun(XWPFRun dest, XWPFRun src) {\n    if ((null == dest) || (null == src))\n        return;\n\n    if (StringUtils.isNotEmpty(src.getStyle()))\n        dest.setStyle(src.getStyle());\n\n    if (Boolean.TRUE.equals(src.isBold()))\n        dest.setBold(src.isBold());\n\n    if (StringUtils.isNotBlank(src.getColor()))\n        dest.setColor(src.getColor());\n\n    if (0 != src.getCharacterSpacing())\n        dest.setCharacterSpacing(src.getCharacterSpacing());\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.ascii)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.ascii);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.eastAsia)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.eastAsia);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.hAnsi)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.hAnsi);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.cs)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.cs);\n\n    Double fontSize = src.getFontSizeAsDouble();\n    if (null != fontSize) {\n        dest.setFontSize(fontSize);\n    }\n    if (Boolean.TRUE.equals(src.isItalic()))\n        dest.setItalic(src.isItalic());\n\n    if (Boolean.TRUE.equals(src.isStrikeThrough()))\n        dest.setStrikeThrough(src.isStrikeThrough());\n\n    if (UnderlinePatterns.NONE != src.getUnderline())\n        dest.setUnderline(src.getUnderline());\n\n    if (null != src.getUnderlineColor())\n        dest.setUnderlineColor(src.getUnderlineColor());\n\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyleFromCss",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isNotBlank",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyleFromCss" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyleFromCss(Map<String, String> propertyValues) {\n    Builder builder = ParagraphStyle.builder();\n    if (propertyValues != null) {\n        String background = propertyValues.get(\"background\");\n        String color = propertyValues.get(\"color\");\n        if (StringUtils.isNotBlank(background)) {\n            builder.withBackgroundColor(toRgb(background));\n        }\n        if (StringUtils.isNotBlank(color)) {\n            String rgb = toRgb(color);\n            builder.withDefaultTextStyle(Style.builder().buildColor(rgb).build());\n        }\n    } else {\n        return null;\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveStyleFromCss",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isNotBlank",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveStyleFromCss" ],
    "fullMethods" : [ "public static Style retriveStyleFromCss(Map<String, String> propertyValues) {\n    StyleBuilder builder = Style.builder();\n    if (propertyValues != null) {\n        String style = propertyValues.get(\"font-style\");\n        String weight = propertyValues.get(\"font-weight\");\n        String color = propertyValues.get(\"color\");\n        String size = propertyValues.get(\"font-size\");\n        if (StringUtils.isNotBlank(style) && \"italic\".equalsIgnoreCase(style)) {\n            builder.buildItalic();\n        }\n        if (StringUtils.isNotBlank(size)) {\n            // builder.buildFontSize(fontSize);\n        }\n        if (StringUtils.isNotBlank(weight)) {\n            builder.buildBold();\n        }\n        if (StringUtils.isNotBlank(color)) {\n            String rgb = toRgb(color);\n            builder.buildColor(rgb);\n        }\n    } else {\n        return null;\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isNotBlank",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.RegexUtils.escapeExprSpecialWord",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isNotBlank",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.util.RegexUtils.escapeExprSpecialWord" ],
    "fullMethods" : [ "public static String escapeExprSpecialWord(String keyword) {\n    if (StringUtils.isNotBlank(keyword)) {\n        String[] fbsArr = new String[]{ \"\\\\\", \"$\", \"(\", \")\", \"*\", \"+\", \".\", \"[\", \"]\", \"?\", \"^\", \"{\", \"}\", \"|\" };\n        for (String key : fbsArr) {\n            if (keyword.contains(key)) {\n                keyword = keyword.replace(key, \"\\\\\" + key);\n            }\n        }\n    }\n    return keyword;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isNotBlank",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun" ],
    "fullMethods" : [ "/**\n * set run style by style\n *\n * @param run\n * @param style\n */\npublic static void styleRun(XWPFRun run, Style style) {\n    if ((null == run) || (null == style))\n        return;\n\n    CTRPr pr = getRunProperties(run);\n    String color = style.getColor();\n    if (StringUtils.isNotBlank(color)) {\n        // run.setColor(color);\n        // issue 326\n        CTColor ctColor = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        ctColor.setVal(color);\n        if (ctColor.isSetThemeColor())\n            ctColor.unsetThemeColor();\n\n    }\n    double fontSize = style.getFontSize();\n    if ((0 != fontSize) && ((-1) != fontSize)) {\n        run.setFontSize(fontSize);\n    }\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        run.setFontFamily(fontFamily, FontCharRange.eastAsia);\n        run.setFontFamily(fontFamily, FontCharRange.ascii);\n        run.setFontFamily(fontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(fontFamily, FontCharRange.cs);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        run.setFontFamily(westernFontFamily, FontCharRange.ascii);\n        run.setFontFamily(westernFontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(westernFontFamily, FontCharRange.cs);\n    }\n    XWPFHighlightColor highlightColor = style.getHighlightColor();\n    if (null != highlightColor) {\n        CTHighlight highlight = (pr.sizeOfHighlightArray() > 0) ? pr.getHighlightArray(0) : pr.addNewHighlight();\n        highlight.setVal(STHighlightColor.Enum.forInt(highlightColor.getValue()));\n    }\n    Boolean bold = style.isBold();\n    if (null != bold)\n        run.setBold(bold);\n\n    Boolean italic = style.isItalic();\n    if (null != italic)\n        run.setItalic(italic);\n\n    Boolean strike = style.isStrike();\n    if (null != strike)\n        run.setStrikeThrough(strike);\n\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        run.setUnderline(underlinePatern);\n        if (null != style.getUnderlineColor()) {\n            run.setUnderlineColor(style.getUnderlineColor());\n        }\n    }\n    int point = style.getCharacterSpacing();\n    // in twentieths of a point\n    if ((0 != point) && ((-1) != point))\n        run.setCharacterSpacing(UnitUtils.point2Twips(point));\n\n    String vertAlign = style.getVertAlign();\n    if (StringUtils.isNotBlank(vertAlign)) {\n        run.setVerticalAlignment(vertAlign);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTInd.unsetLeft",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveBorderStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.STHexColor.getStringValue",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveBorderStyle" ],
    "fullMethods" : [ "public static BorderStyle retriveBorderStyle(CTBorder border) {\n    BorderStyle.Builder borderBuilder = BorderStyle.builder();\n    if (border.isSetColor())\n        borderBuilder.withColor(border.xgetColor().getStringValue());\n\n    if (border.isSetSz())\n        borderBuilder.withSize(border.getSz().intValue());\n\n    if (border.getVal() != null)\n        borderBuilder.withType(XWPFBorderType.valueOf(border.getVal().toString().toUpperCase()));\n\n    return borderBuilder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.STHexColor.getStringValue",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyle(XWPFParagraph paragraph) {\n    if (null == paragraph)\n        return null;\n\n    Builder builder = ParagraphStyle.builder();\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    if (paragraph.isWordWrapped()) {\n        builder.withAllowWordBreak(true);\n    }\n    if (pr.isSetPBdr()) {\n        CTPBdr ct = pr.getPBdr();\n        if (ct.isSetLeft()) {\n            builder.withLeftBorder(retriveBorderStyle(ct.getLeft()));\n        }\n        if (ct.isSetTop()) {\n            builder.withTopBorder(retriveBorderStyle(ct.getTop()));\n        }\n        if (ct.isSetRight()) {\n            builder.withRightBorder(retriveBorderStyle(ct.getRight()));\n        }\n        if (ct.isSetBottom()) {\n            builder.withBottomBorder(retriveBorderStyle(ct.getBottom()));\n        }\n    }\n    if (pr.isSetShd()) {\n        CTShd shd = pr.getShd();\n        builder.withShadingPattern(XWPFShadingPattern.valueOf(shd.getVal().intValue()));\n        if (shd.isSetFill())\n            builder.withBackgroundColor(shd.xgetFill().getStringValue());\n\n    }\n    builder.withAlign(paragraph.getAlignment());\n    int spacingBeforeLines = paragraph.getSpacingBeforeLines();\n    if ((-1) != spacingBeforeLines) {\n        builder.withSpacingBeforeLines(spacingBeforeLines / 100.0F);\n    }\n    int spacingAfterLines = paragraph.getSpacingAfterLines();\n    if ((-1) != spacingAfterLines) {\n        builder.withSpacingAfterLines(spacingAfterLines / 100.0F);\n    }\n    int spacingBefore = paragraph.getSpacingBefore();\n    if ((-1) != spacingBefore) {\n        builder.withSpacingBefore(UnitUtils.twips2Point(spacingBefore));\n    }\n    int spacingAfter = paragraph.getSpacingAfter();\n    if ((-1) != spacingAfter) {\n        builder.withSpacingAfter(UnitUtils.twips2Point(spacingAfter));\n    }\n    double spacingBetween = paragraph.getSpacingBetween();\n    if ((-1) != spacingBetween) {\n        builder.withSpacing(spacingBetween);\n        builder.withSpacingRule(paragraph.getSpacingLineRule());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.officeDocument.x2006.sharedTypes.STHexColorRGB.setStringValue",
    "thirdPartyPackage" : "org.openxmlformats.schemas.officeDocument.x2006.sharedTypes",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.NumberingContinue.updateNumbering",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTAbstractNum.isSetNsid",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.render.processor.NumberingContinue.updateNumbering" ],
    "fullMethods" : [ "public void updateNumbering(XWPFParagraph source, XWPFParagraph target) {\n    XWPFDocument document = source.getDocument();\n    XWPFNumbering numbering = document.getNumbering();\n    if (null == numbering)\n        return;\n\n    BigInteger numID = source.getNumID();\n    if (numID == null)\n        return;\n\n    if ((null != continueNumID) && numID.equals(continueNumID)) {\n        return;\n    }\n    if (consistCache.get(numID) != null) {\n        target.setNumID(consistCache.get(numID));\n        return;\n    }\n    XWPFNumberingWrapper wrapper = new XWPFNumberingWrapper(numbering);\n    XWPFNum num = numbering.getNum(numID);\n    if (null == num)\n        return;\n\n    XWPFAbstractNum abstractNum = numbering.getAbstractNum(num.getCTNum().getAbstractNumId().getVal());\n    CTAbstractNum ctAbstractNum = ((CTAbstractNum) (abstractNum.getAbstractNum().copy()));\n    ctAbstractNum.setAbstractNumId(wrapper.getNextAbstractNumID());\n    // clear continues list\n    // (related to tracking numbering definitions when documents are\n    // repurposed and\n    // changed\n    if (ctAbstractNum.isSetNsid())\n        ctAbstractNum.unsetNsid();\n\n    // related to where the definition can be displayed in the user\n    // interface\n    if (ctAbstractNum.isSetTmpl())\n        ctAbstractNum.unsetTmpl();\n\n    BigInteger abstractNumID = numbering.addAbstractNum(new XWPFAbstractNum(ctAbstractNum));\n    BigInteger newNumId = numbering.addNum(abstractNumID);\n    target.setNumID(newNumId);\n    consistCache.put(numID, newNumId);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTAbstractNum.isSetNsid",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableString", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeNumbering" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "protected String createMergeableString(NiceXWPFDocument source, NiceXWPFDocument merged, Map<String, String> styleIdsMap) throws InvalidFormatException, IOException {\n    CTBody mergedBody = merged.getDocument().getBody();\n    // TODO For the same style, reduce the number of merges\n    // Map<String, String> styleIdsMap = mergeStyles(docMerge);\n    Map<String, String> numIdsMap = mergeNumbering(source, merged);\n    Map<String, String> blipIdsMap = mergePicture(source, merged);\n    Map<String, String> externalBlipIdsMap = mergeExternalPicture(source, merged);\n    Map<String, String> hyperlinkMap = mergeHyperlink(source, merged);\n    Map<String, String> chartIdsMap = mergeChart(source, merged);\n    Map<String, String> attachmentIdsMap = mergeAttachment(source, merged);\n    Map<String, String> footnoteIdsMap = mergeFootnote(source, merged);\n    Map<String, String> endnoteIdsMap = mergeEndnote(source, merged);\n    String appendString = mergedBody.xmlText(DefaultXmlOptions.OPTIONS_OUTER);\n    String addPart = ridSectPr(appendString);\n    // style\n    for (String styleId : styleIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:pStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:pStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:tblStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:tblStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:rStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:rStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\");\n    }\n    // picture id\n    Map<String, String> placeHolderblipIdsMap = new HashMap<String, String>();\n    for (String relaId : blipIdsMap.keySet()) {\n        placeHolderblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:embed=\\\"\" + relaId) + \"\\\"\", (\"r:embed=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n        // w:pict v:shape v:imagedata\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    Map<String, String> placeHolderExternalblipIdsMap = new HashMap<String, String>();\n    for (String relaId : externalBlipIdsMap.keySet()) {\n        placeHolderExternalblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderExternalblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:link=\\\"\" + relaId) + \"\\\"\", (\"r:link=\\\"\" + placeHolderExternalblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // hyperlink id\n    for (String relaId : hyperlinkMap.keySet()) {\n        hyperlinkMap.put(relaId, hyperlinkMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : hyperlinkMap.keySet()) {\n        // w:hyperlink r:id\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + hyperlinkMap.get(relaId)) + \"\\\"\");\n    }\n    // chart id\n    for (String relaId : chartIdsMap.keySet()) {\n        chartIdsMap.put(relaId, chartIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : chartIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + chartIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // attachment id\n    for (String relaId : attachmentIdsMap.keySet()) {\n        attachmentIdsMap.put(relaId, attachmentIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : attachmentIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + attachmentIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // footnote id\n    for (String relaId : footnoteIdsMap.keySet()) {\n        footnoteIdsMap.put(relaId, footnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : footnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"footnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"footnoteReference w:id=\\\"\" + footnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // endnote id\n    for (String relaId : endnoteIdsMap.keySet()) {\n        endnoteIdsMap.put(relaId, endnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : endnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"endnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"endnoteReference w:id=\\\"\" + endnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // numbering numId\n    for (String relaId : numIdsMap.keySet()) {\n        numIdsMap.put(relaId, numIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String numId : numIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:numId\\\\sw:val=\\\"\" + numId) + \"\\\"\", (\"<w:numId w:val=\\\"\" + numIdsMap.get(numId)) + \"\\\"\");\n    }\n    return addPart.replaceAll(CROSS_REPLACE_STRING, \"\");\n}", "protected Map<String, String> mergeNumbering(NiceXWPFDocument source, NiceXWPFDocument merged) {\n    Map<String, String> numIdsMap = new HashMap<String, String>();\n    XWPFNumbering numberingMerge = merged.getNumbering();\n    if (null == numberingMerge)\n        return numIdsMap;\n\n    XWPFNumberingWrapper wrapperMerge = new XWPFNumberingWrapper(numberingMerge);\n    List<XWPFNum> nums = wrapperMerge.getNums();\n    if (null == nums)\n        return numIdsMap;\n\n    XWPFNumbering numbering = source.getNumbering();\n    if (null == numbering)\n        numbering = source.createNumbering();\n\n    XWPFNumberingWrapper wrapper = new XWPFNumberingWrapper(numbering);\n    XWPFAbstractNum xwpfAbstractNum;\n    CTAbstractNum cTAbstractNum;\n    Map<BigInteger, CTAbstractNum> cache = new HashMap<BigInteger, CTAbstractNum>();\n    Map<BigInteger, CTAbstractNum> ret = new HashMap<BigInteger, CTAbstractNum>();\n    for (XWPFNum xwpfNum : nums) {\n        BigInteger mergeNumId = xwpfNum.getCTNum().getNumId();\n        cTAbstractNum = cache.get(xwpfNum.getCTNum().getAbstractNumId().getVal());\n        if (null == cTAbstractNum) {\n            xwpfAbstractNum = numberingMerge.getAbstractNum(xwpfNum.getCTNum().getAbstractNumId().getVal());\n            if (null == xwpfAbstractNum) {\n                logger.warn(\"cannot find cTAbstractNum by XWPFNum.\");\n                continue;\n            }\n            cTAbstractNum = xwpfAbstractNum.getCTAbstractNum();\n            // cTAbstractNum.setAbstractNumId(wrapper.getNextAbstractNumID());\n            if (cTAbstractNum.isSetNsid())\n                cTAbstractNum.unsetNsid();\n\n            if (cTAbstractNum.isSetTmpl())\n                cTAbstractNum.unsetTmpl();\n\n            cache.put(xwpfNum.getCTNum().getAbstractNumId().getVal(), cTAbstractNum);\n        }\n        ret.put(mergeNumId, cTAbstractNum);\n    }\n    long nextId = wrapper.getNextAbstractNumID().longValue();\n    Set<CTAbstractNum> hashSet = new HashSet<>(ret.values());\n    for (CTAbstractNum abnum : hashSet) {\n        abnum.setAbstractNumId(BigInteger.valueOf(nextId++));\n    }\n    final XWPFNumbering finalNumbering = numbering;\n    ret.forEach((mergeNumId, abnum) -> {\n        BigInteger numID = finalNumbering.addNum(finalNumbering.addAbstractNum(new XWPFAbstractNum(abnum)));\n        numIdsMap.put(mergeNumId.toString(), numID.toString());\n    });\n    return numIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.setPageBreak",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShapeProperties",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.addNewSpPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShapeProperties" ],
    "fullMethods" : [ "@Override\npublic void setShapeProperties(XDDFShapeProperties properties) {\n    if (properties == null) {\n        if (series.isSetSpPr()) {\n            series.unsetSpPr();\n        }\n    } else if (series.isSetSpPr()) {\n        series.setSpPr(properties.getXmlObject());\n    } else {\n        series.addNewSpPr().set(properties.getXmlObject());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableRow",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRow.addNewTrPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableRow" ],
    "fullMethods" : [ "/**\n * set row style\n *\n * @param row\n * @param rowStyle\n */\npublic static void styleTableRow(XWPFTableRow row, RowStyle rowStyle) {\n    if ((null == row) || (null == rowStyle))\n        return;\n\n    int height = rowStyle.getHeight();\n    CTRow ctRow = row.getCtRow();\n    CTTrPr properties = (ctRow.isSetTrPr()) ? ctRow.getTrPr() : ctRow.addNewTrPr();\n    if (0 != height) {\n        row.setHeight(height);\n        CTHeight h = (properties.sizeOfTrHeightArray() == 0) ? properties.addNewTrHeight() : properties.getTrHeightArray(0);\n        String heightRule = rowStyle.getHeightRule();\n        if (\"exact\".equals(heightRule))\n            h.setHRule(STHeightRule.EXACT);\n        else if (\"atleast\".equals(heightRule))\n            h.setHRule(STHeightRule.AT_LEAST);\n        else\n            h.setHRule(STHeightRule.AUTO);\n\n    }\n    boolean repeated = rowStyle.isRepeated();\n    if (repeated) {\n        CTOnOff tblHeader = (properties.sizeOfTblHeaderArray() == 0) ? properties.addNewTblHeader() : properties.getTblHeaderArray(0);\n        tblHeader.setVal(XWPFOnOff.ON);\n    }\n    boolean breakAcrossPage = rowStyle.isBreakAcrossPage();\n    if (!breakAcrossPage) {\n        if (properties.sizeOfCantSplitArray() == 0) {\n            properties.addNewCantSplit();\n        } else {\n            properties.getCantSplitArray(0).setVal(XWPFOnOff.ON);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFComments.createComment",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment" ],
    "fullMethods" : [ "public static void renderComment(XWPFRun run, CommentRenderData data) throws Exception {\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper parentContext = new XWPFParagraphWrapper(paragraph);\n    BigInteger cId = BigInteger.ZERO;\n    CommentContent commentContent = data.getCommentContent();\n    if (null != commentContent) {\n        XWPFComments comments = ((NiceXWPFDocument) (paragraph.getDocument())).createComments();\n        XWPFComment newComment = comments.createComment(NextIDUtils.getCommentMaxId(comments).add(BigInteger.ONE));\n        newComment.setAuthor(commentContent.getAuthor());\n        newComment.setDate(commentContent.getDate());\n        newComment.setInitials(commentContent.getInitials());\n        renderDocument(newComment.createParagraph().createRun(), commentContent.getContent());\n        cId = newComment.getCtComment().getId();\n        parentContext.insertNewCommentRangeStart(run, cId);\n    }\n    renderParagraph(run, Paragraphs.of().addList(data.getContents()).create());\n    if (null != commentContent) {\n        parentContext.insertNewCommentRangeEnd(run, cId);\n        XWPFRun newRun = parentContext.insertNewRun(ParagraphUtils.getRunPos(run));\n        newRun.getCTR().addNewCommentReference().setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr.getWidowControl",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.EnhancedXWPFChart.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFChart.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.EnhancedXWPFChart.<init>" ],
    "fullMethods" : [ "public EnhancedXWPFChart(PackagePart part) throws IOException, XmlException {\n    super(part);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getText",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFSDT.getContent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getText" ],
    "fullMethods" : [ "@Override\npublic String getText() {\n    StringBuilder text = new StringBuilder();\n    boolean addNewLine = false;\n    for (int i = 0; i < sdtElements.size(); i++) {\n        Object o = sdtElements.get(i);\n        if (o instanceof XWPFParagraph) {\n            appendParagraph(((XWPFParagraph) (o)), text);\n            addNewLine = true;\n        } else if (o instanceof XWPFTable) {\n            appendTable(((XWPFTable) (o)), text);\n            addNewLine = true;\n        } else if (o instanceof XWPFSDT) {\n            text.append(((XWPFSDT) (o)).getContent().getText());\n            addNewLine = true;\n        } else if (o instanceof XWPFRun) {\n            text.append(o);\n            addNewLine = false;\n        }\n        if (addNewLine && (i < (sdtElements.size() - 1))) {\n            text.append(\"\\n\");\n        }\n    }\n    return text.toString();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTInd.isSetFirstLine",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.NumberingContinue.updateNumbering",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTAbstractNum.unsetTmpl",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.render.processor.NumberingContinue.updateNumbering" ],
    "fullMethods" : [ "public void updateNumbering(XWPFParagraph source, XWPFParagraph target) {\n    XWPFDocument document = source.getDocument();\n    XWPFNumbering numbering = document.getNumbering();\n    if (null == numbering)\n        return;\n\n    BigInteger numID = source.getNumID();\n    if (numID == null)\n        return;\n\n    if ((null != continueNumID) && numID.equals(continueNumID)) {\n        return;\n    }\n    if (consistCache.get(numID) != null) {\n        target.setNumID(consistCache.get(numID));\n        return;\n    }\n    XWPFNumberingWrapper wrapper = new XWPFNumberingWrapper(numbering);\n    XWPFNum num = numbering.getNum(numID);\n    if (null == num)\n        return;\n\n    XWPFAbstractNum abstractNum = numbering.getAbstractNum(num.getCTNum().getAbstractNumId().getVal());\n    CTAbstractNum ctAbstractNum = ((CTAbstractNum) (abstractNum.getAbstractNum().copy()));\n    ctAbstractNum.setAbstractNumId(wrapper.getNextAbstractNumID());\n    // clear continues list\n    // (related to tracking numbering definitions when documents are\n    // repurposed and\n    // changed\n    if (ctAbstractNum.isSetNsid())\n        ctAbstractNum.unsetNsid();\n\n    // related to where the definition can be displayed in the user\n    // interface\n    if (ctAbstractNum.isSetTmpl())\n        ctAbstractNum.unsetTmpl();\n\n    BigInteger abstractNumID = numbering.addAbstractNum(new XWPFAbstractNum(ctAbstractNum));\n    BigInteger newNumId = numbering.addNum(abstractNumID);\n    target.setNumID(newNumId);\n    consistCache.put(numID, newNumId);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTAbstractNum.unsetTmpl",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableString", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeNumbering" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "protected String createMergeableString(NiceXWPFDocument source, NiceXWPFDocument merged, Map<String, String> styleIdsMap) throws InvalidFormatException, IOException {\n    CTBody mergedBody = merged.getDocument().getBody();\n    // TODO For the same style, reduce the number of merges\n    // Map<String, String> styleIdsMap = mergeStyles(docMerge);\n    Map<String, String> numIdsMap = mergeNumbering(source, merged);\n    Map<String, String> blipIdsMap = mergePicture(source, merged);\n    Map<String, String> externalBlipIdsMap = mergeExternalPicture(source, merged);\n    Map<String, String> hyperlinkMap = mergeHyperlink(source, merged);\n    Map<String, String> chartIdsMap = mergeChart(source, merged);\n    Map<String, String> attachmentIdsMap = mergeAttachment(source, merged);\n    Map<String, String> footnoteIdsMap = mergeFootnote(source, merged);\n    Map<String, String> endnoteIdsMap = mergeEndnote(source, merged);\n    String appendString = mergedBody.xmlText(DefaultXmlOptions.OPTIONS_OUTER);\n    String addPart = ridSectPr(appendString);\n    // style\n    for (String styleId : styleIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:pStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:pStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:tblStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:tblStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:rStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:rStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\");\n    }\n    // picture id\n    Map<String, String> placeHolderblipIdsMap = new HashMap<String, String>();\n    for (String relaId : blipIdsMap.keySet()) {\n        placeHolderblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:embed=\\\"\" + relaId) + \"\\\"\", (\"r:embed=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n        // w:pict v:shape v:imagedata\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    Map<String, String> placeHolderExternalblipIdsMap = new HashMap<String, String>();\n    for (String relaId : externalBlipIdsMap.keySet()) {\n        placeHolderExternalblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderExternalblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:link=\\\"\" + relaId) + \"\\\"\", (\"r:link=\\\"\" + placeHolderExternalblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // hyperlink id\n    for (String relaId : hyperlinkMap.keySet()) {\n        hyperlinkMap.put(relaId, hyperlinkMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : hyperlinkMap.keySet()) {\n        // w:hyperlink r:id\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + hyperlinkMap.get(relaId)) + \"\\\"\");\n    }\n    // chart id\n    for (String relaId : chartIdsMap.keySet()) {\n        chartIdsMap.put(relaId, chartIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : chartIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + chartIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // attachment id\n    for (String relaId : attachmentIdsMap.keySet()) {\n        attachmentIdsMap.put(relaId, attachmentIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : attachmentIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + attachmentIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // footnote id\n    for (String relaId : footnoteIdsMap.keySet()) {\n        footnoteIdsMap.put(relaId, footnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : footnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"footnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"footnoteReference w:id=\\\"\" + footnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // endnote id\n    for (String relaId : endnoteIdsMap.keySet()) {\n        endnoteIdsMap.put(relaId, endnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : endnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"endnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"endnoteReference w:id=\\\"\" + endnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // numbering numId\n    for (String relaId : numIdsMap.keySet()) {\n        numIdsMap.put(relaId, numIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String numId : numIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:numId\\\\sw:val=\\\"\" + numId) + \"\\\"\", (\"<w:numId w:val=\\\"\" + numIdsMap.get(numId)) + \"\\\"\");\n    }\n    return addPart.replaceAll(CROSS_REPLACE_STRING, \"\");\n}", "protected Map<String, String> mergeNumbering(NiceXWPFDocument source, NiceXWPFDocument merged) {\n    Map<String, String> numIdsMap = new HashMap<String, String>();\n    XWPFNumbering numberingMerge = merged.getNumbering();\n    if (null == numberingMerge)\n        return numIdsMap;\n\n    XWPFNumberingWrapper wrapperMerge = new XWPFNumberingWrapper(numberingMerge);\n    List<XWPFNum> nums = wrapperMerge.getNums();\n    if (null == nums)\n        return numIdsMap;\n\n    XWPFNumbering numbering = source.getNumbering();\n    if (null == numbering)\n        numbering = source.createNumbering();\n\n    XWPFNumberingWrapper wrapper = new XWPFNumberingWrapper(numbering);\n    XWPFAbstractNum xwpfAbstractNum;\n    CTAbstractNum cTAbstractNum;\n    Map<BigInteger, CTAbstractNum> cache = new HashMap<BigInteger, CTAbstractNum>();\n    Map<BigInteger, CTAbstractNum> ret = new HashMap<BigInteger, CTAbstractNum>();\n    for (XWPFNum xwpfNum : nums) {\n        BigInteger mergeNumId = xwpfNum.getCTNum().getNumId();\n        cTAbstractNum = cache.get(xwpfNum.getCTNum().getAbstractNumId().getVal());\n        if (null == cTAbstractNum) {\n            xwpfAbstractNum = numberingMerge.getAbstractNum(xwpfNum.getCTNum().getAbstractNumId().getVal());\n            if (null == xwpfAbstractNum) {\n                logger.warn(\"cannot find cTAbstractNum by XWPFNum.\");\n                continue;\n            }\n            cTAbstractNum = xwpfAbstractNum.getCTAbstractNum();\n            // cTAbstractNum.setAbstractNumId(wrapper.getNextAbstractNumID());\n            if (cTAbstractNum.isSetNsid())\n                cTAbstractNum.unsetNsid();\n\n            if (cTAbstractNum.isSetTmpl())\n                cTAbstractNum.unsetTmpl();\n\n            cache.put(xwpfNum.getCTNum().getAbstractNumId().getVal(), cTAbstractNum);\n        }\n        ret.put(mergeNumId, cTAbstractNum);\n    }\n    long nextId = wrapper.getNextAbstractNumID().longValue();\n    Set<CTAbstractNum> hashSet = new HashSet<>(ret.values());\n    for (CTAbstractNum abnum : hashSet) {\n        abnum.setAbstractNumId(BigInteger.valueOf(nextId++));\n    }\n    final XWPFNumbering finalNumbering = numbering;\n    ret.forEach((mergeNumId, abnum) -> {\n        BigInteger numID = finalNumbering.addNum(finalNumbering.addAbstractNum(new XWPFAbstractNum(abnum)));\n        numIdsMap.put(mergeNumId.toString(), numID.toString());\n    });\n    return numIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.text",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.<init>", "com.deepoove.poi.resolver.RunningRunBody.getText" ],
    "fullMethods" : [ "public RunningRunBody(RunBodyContext context, Pattern pattern) {\n    this.runBodyContext = context;\n    this.runs = context.getRuns();\n    if ((null == runs) || runs.isEmpty())\n        return;\n\n    Matcher matcher = pattern.matcher(getText(context));\n    if (matcher.find()) {\n        refactorBody();\n    }\n    buildRunEdge(pattern);\n}", "private String getText(RunBodyContext context) {\n    StringBuilder out = new StringBuilder(64);\n    for (XWPFRun run : runs) {\n        out.append(run.text());\n    }\n    return out.toString();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.merge",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.text",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.merge" ],
    "fullMethods" : [ "public NiceXWPFDocument merge(Iterator<NiceXWPFDocument> iterator, XWPFRun run) throws Exception {\n    XWPFRun newRun = run;\n    String paragraphText = ParagraphUtils.trimLine(((XWPFParagraph) (run.getParent())));\n    boolean havePictures = ParagraphUtils.havePictures(((XWPFParagraph) (run.getParent())));\n    if ((!ParagraphUtils.trimLine(run.text()).equals(paragraphText)) || havePictures) {\n        BodyContainer container = BodyContainerFactory.getBodyContainer(run);\n        XWPFParagraph paragraph = container.insertNewParagraph(run);\n        newRun = paragraph.createRun();\n    }\n    return new XmlXWPFDocumentMerge().merge(this, iterator, newRun);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.refactorRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.text",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.refactorRun" ],
    "fullMethods" : [ "public List<XWPFRun> refactorRun() {\n    if (pairs.isEmpty())\n        return null;\n\n    List<XWPFRun> templateRuns = new ArrayList<XWPFRun>();\n    int size = pairs.size();\n    Pair<RunEdge, RunEdge> runEdgePair;\n    for (int n = size - 1; n >= 0; n--) {\n        runEdgePair = pairs.get(n);\n        RunEdge startEdge = runEdgePair.getLeft();\n        RunEdge endEdge = runEdgePair.getRight();\n        int startRunPos = startEdge.getRunPos();\n        int endRunPos = endEdge.getRunPos();\n        int startOffset = startEdge.getRunEdge();\n        int endOffset = endEdge.getRunEdge();\n        String startText = runs.get(startRunPos).text();\n        String endText = runs.get(endRunPos).text();\n        if ((endOffset + 1) >= endText.length()) {\n            // delete the redundant end Run directly\n            if (startRunPos != endRunPos)\n                runBodyContext.removeRun(endRunPos);\n\n        } else {\n            // split end run, set extra in a run\n            String extra = endText.substring(endOffset + 1, endText.length());\n            if (startRunPos == endRunPos) {\n                // create run and set extra content\n                XWPFRun extraRun = runBodyContext.insertNewRunAfter(endRunPos);\n                StyleUtils.styleRun(extraRun, runs.get(endRunPos));\n                buildExtra(extra, extraRun);\n            } else {\n                // Set the extra content to the redundant end run\n                XWPFRun extraRun = runs.get(endRunPos);\n                buildExtra(extra, extraRun);\n            }\n        }\n        // remove extra run\n        for (int m = endRunPos - 1; m > startRunPos; m--) {\n            runBodyContext.removeRun(m);\n        }\n        if (startOffset <= 0) {\n            // set the start Run directly\n            XWPFRun templateRun = runs.get(startRunPos);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos));\n        } else {\n            // split start run, set extra in a run\n            String extra = startText.substring(0, startOffset);\n            XWPFRun extraRun = runs.get(startRunPos);\n            buildExtra(extra, extraRun);\n            XWPFRun templateRun = runBodyContext.insertNewRunAfter(startRunPos);\n            StyleUtils.styleRun(templateRun, extraRun);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos + 1));\n        }\n    }\n    return templateRuns;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableRow",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTrPr.getTblHeaderArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableRow" ],
    "fullMethods" : [ "/**\n * set row style\n *\n * @param row\n * @param rowStyle\n */\npublic static void styleTableRow(XWPFTableRow row, RowStyle rowStyle) {\n    if ((null == row) || (null == rowStyle))\n        return;\n\n    int height = rowStyle.getHeight();\n    CTRow ctRow = row.getCtRow();\n    CTTrPr properties = (ctRow.isSetTrPr()) ? ctRow.getTrPr() : ctRow.addNewTrPr();\n    if (0 != height) {\n        row.setHeight(height);\n        CTHeight h = (properties.sizeOfTrHeightArray() == 0) ? properties.addNewTrHeight() : properties.getTrHeightArray(0);\n        String heightRule = rowStyle.getHeightRule();\n        if (\"exact\".equals(heightRule))\n            h.setHRule(STHeightRule.EXACT);\n        else if (\"atleast\".equals(heightRule))\n            h.setHRule(STHeightRule.AT_LEAST);\n        else\n            h.setHRule(STHeightRule.AUTO);\n\n    }\n    boolean repeated = rowStyle.isRepeated();\n    if (repeated) {\n        CTOnOff tblHeader = (properties.sizeOfTblHeaderArray() == 0) ? properties.addNewTblHeader() : properties.getTblHeaderArray(0);\n        tblHeader.setVal(XWPFOnOff.ON);\n    }\n    boolean breakAcrossPage = rowStyle.isBreakAcrossPage();\n    if (!breakAcrossPage) {\n        if (properties.sizeOfCantSplitArray() == 0) {\n            properties.addNewCantSplit();\n        } else {\n            properties.getCantSplitArray(0).setVal(XWPFOnOff.ON);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.setSpacingBefore",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>",
    "thirdPartyMethod" : "org.apache.poi.xddf.usermodel.chart.XDDFDataSourcesFactory.fromDataSource",
    "thirdPartyPackage" : "org.apache.poi.xddf.usermodel.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>", "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.<init>" ],
    "fullMethods" : [ "public XDDFOfPieChartData(XDDFChart parent, CTOfPieChart chart) {\n    super(parent);\n    this.chart = chart;\n    this.seriesNum = parent.getChartSeries().size();\n    for (CTPieSer series : chart.getSerList()) {\n        this.series.add(new Series(series, series.getCat(), series.getVal()));\n    }\n}", "protected Series(CTPieSer series, XDDFDataSource<?> category, XDDFNumericalDataSource<? extends Number> values) {\n    super(category, values);\n    this.series = series;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShowLeaderLines",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTDLbls.addNewShowLeaderLines",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShowLeaderLines" ],
    "fullMethods" : [ "@Override\npublic void setShowLeaderLines(boolean showLeaderLines) {\n    if (!series.isSetDLbls()) {\n        series.addNewDLbls();\n    }\n    if (series.getDLbls().isSetShowLeaderLines()) {\n        series.getDLbls().getShowLeaderLines().setVal(showLeaderLines);\n    } else {\n        series.getDLbls().addNewShowLeaderLines().setVal(showLeaderLines);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTLvl.getPPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId" ],
    "fullMethods" : [ "public BigInteger addNewMultiLevelNumberingId(NumberingFormat... numFmts) {\n    XWPFNumbering numbering = this.getNumbering();\n    if (null == numbering) {\n        numbering = this.createNumbering();\n    }\n    XWPFNumberingWrapper numberingWrapper = new XWPFNumberingWrapper(numbering);\n    CTAbstractNum cTAbstractNum = CTAbstractNum.Factory.newInstance();\n    // if we have an existing document, we must determine the next\n    // free number first.\n    cTAbstractNum.setAbstractNumId(numberingWrapper.getNextAbstractNumID());\n    // CTMultiLevelType addNewMultiLevelType = cTAbstractNum.addNewMultiLevelType();\n    // addNewMultiLevelType.setVal(STMultiLevelType.HYBRID_MULTILEVEL);\n    for (int i = 0; i < numFmts.length; i++) {\n        NumberingFormat numFmt = numFmts[i];\n        CTLvl cTLvl = cTAbstractNum.addNewLvl();\n        CTPPrBase ppr = (cTLvl.isSetPPr()) ? cTLvl.getPPr() : cTLvl.addNewPPr();\n        CTInd ind = (ppr.isSetInd()) ? ppr.getInd() : ppr.addNewInd();\n        ind.setLeft(BigInteger.valueOf(UnitUtils.cm2Twips(0.74F) * i));\n        Enum fmt = STNumberFormat.Enum.forInt(numFmt.getNumFmt());\n        String val = numFmt.getLvlText();\n        cTLvl.addNewNumFmt().setVal(fmt);\n        cTLvl.addNewLvlText().setVal(val);\n        cTLvl.addNewStart().setVal(BigInteger.valueOf(1));\n        cTLvl.setIlvl(BigInteger.valueOf(i));\n        if (fmt == STNumberFormat.BULLET) {\n            cTLvl.addNewLvlJc().setVal(STJc.LEFT);\n            CTRPr addNewRPr = cTLvl.addNewRPr();\n            CTFonts ctFonts = addNewRPr.addNewRFonts();\n            ctFonts.setAscii(\"Wingdings\");\n            ctFonts.setHAnsi(\"Wingdings\");\n            ctFonts.setHint(STHint.DEFAULT);\n        }\n    }\n    XWPFAbstractNum abstractNum = new XWPFAbstractNum(cTAbstractNum);\n    BigInteger abstractNumID = numbering.addAbstractNum(abstractNum);\n    return numbering.addNum(abstractNumID);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.setParagraph",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTxbxContent.setPArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.setParagraph" ],
    "fullMethods" : [ "public void setParagraph(XWPFParagraph p) {\n    if (ctTxbxContent.sizeOfPArray() == 0) {\n        ctTxbxContent.addNewP();\n    }\n    ctTxbxContent.setPArray(0, p.getCTP());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.TextBoxBodyContainer.setParagraph",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTxbxContent.setPArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.TextBoxBodyContainer.setParagraph" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setParagraph(XWPFParagraph paragraph, int pos) {\n    List<XWPFParagraph> paragraphs = ((List<XWPFParagraph>) (ReflectionUtils.getValue(\"paragraphs\", textbox)));\n    paragraphs.set(pos, paragraph);\n    CTTxbxContent ctTxbxContent = textbox.getCTTxbxContent();\n    ctTxbxContent.setPArray(pos, paragraph.getCTP());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.config.ConfigureBuilder.buidIterableLeft",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.of",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.config.ConfigureBuilder.buidIterableLeft" ],
    "fullMethods" : [ "public ConfigureBuilder buidIterableLeft(char c) {\n    config.iterable = Pair.of(c, config.iterable.getRight());\n    return this;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.config.Configure.builder",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.of",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.config.Configure.builder", "com.deepoove.poi.config.ConfigureBuilder.<init>", "com.deepoove.poi.config.Configure.<init>" ],
    "fullMethods" : [ "/**\n * Builder to build {@link Configure}\n *\n * @return  */\npublic static ConfigureBuilder builder() {\n    return new ConfigureBuilder();\n}", "ConfigureBuilder() {\n    config = new Configure();\n}", "Configure() {\n    plugin(GramerSymbol.TEXT, new TextRenderPolicy());\n    plugin(GramerSymbol.TEXT_ALIAS, new TextRenderPolicy());\n    plugin(GramerSymbol.IMAGE, new PictureRenderPolicy());\n    plugin(GramerSymbol.TABLE, new TableRenderPolicy());\n    plugin(GramerSymbol.NUMBERING, new NumberingRenderPolicy());\n    plugin(GramerSymbol.DOCX_TEMPLATE, new DocxRenderPolicy());\n    RenderPolicy multiSeriesRenderPolicy = new MultiSeriesChartTemplateRenderPolicy();\n    plugin(ChartTypes.AREA, multiSeriesRenderPolicy);\n    plugin(ChartTypes.AREA3D, multiSeriesRenderPolicy);\n    plugin(ChartTypes.BAR, multiSeriesRenderPolicy);\n    plugin(ChartTypes.BAR3D, multiSeriesRenderPolicy);\n    plugin(ChartTypes.LINE, multiSeriesRenderPolicy);\n    plugin(ChartTypes.LINE3D, multiSeriesRenderPolicy);\n    plugin(ChartTypes.RADAR, multiSeriesRenderPolicy);\n    plugin(ChartTypes.SCATTER, multiSeriesRenderPolicy);\n    RenderPolicy singleSeriesRenderPolicy = new SingleSeriesChartTemplateRenderPolicy();\n    plugin(ChartTypes.PIE, singleSeriesRenderPolicy);\n    plugin(ChartTypes.PIE3D, singleSeriesRenderPolicy);\n    plugin(ChartTypes.DOUGHNUT, singleSeriesRenderPolicy);\n    plugin(PictureTemplate.class, new DefaultPictureTemplateRenderPolicy());\n    plugin(PictImageTemplate.class, new DefaultPictImageTemplateRenderPolicy());\n    plugin(ChartTemplate.class, new DefaultChartTemplateRenderPolicy());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShowLeaderLines",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTBoolean.setVal",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShowLeaderLines" ],
    "fullMethods" : [ "@Override\npublic void setShowLeaderLines(boolean showLeaderLines) {\n    if (!series.isSetDLbls()) {\n        series.addNewDLbls();\n    }\n    if (series.getDLbls().isSetShowLeaderLines()) {\n        series.getDLbls().getShowLeaderLines().setVal(showLeaderLines);\n    } else {\n        series.getDLbls().addNewShowLeaderLines().setVal(showLeaderLines);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.EnhancedXWPFChart.setExternalId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTBoolean.setVal",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.EnhancedXWPFChart.setExternalId" ],
    "fullMethods" : [ "@Override\npublic void setExternalId(String id) {\n    CTChartSpace ctChartSpace = getCTChartSpace();\n    CTExternalData externalData = (ctChartSpace.isSetExternalData()) ? ctChartSpace.getExternalData() : ctChartSpace.addNewExternalData();\n    externalData.setId(id);\n    if (!externalData.isSetAutoUpdate()) {\n        externalData.addNewAutoUpdate().setVal(true);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.setVaryColors",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTBoolean.setVal",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.setVaryColors" ],
    "fullMethods" : [ "@Override\npublic void setVaryColors(Boolean varyColors) {\n    if (varyColors == null) {\n        if (chart.isSetVaryColors()) {\n            chart.unsetVaryColors();\n        }\n    } else if (chart.isSetVaryColors()) {\n        chart.getVaryColors().setVal(varyColors);\n    } else {\n        chart.addNewVaryColors().setVal(varyColors);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblBorders.isSetRight",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.compute.ReadMapAccessor.generateCode",
    "thirdPartyMethod" : "org.springframework.asm.MethodVisitor.visitMethodInsn",
    "thirdPartyPackage" : "org.springframework.asm",
    "path" : [ "com.deepoove.poi.render.compute.ReadMapAccessor.generateCode" ],
    "fullMethods" : [ "@Override\npublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n    String descriptor = cf.lastDescriptor();\n    if ((descriptor == null) || (!descriptor.equals(\"Ljava/util/Map\"))) {\n        if (descriptor == null) {\n            cf.loadTarget(mv);\n        }\n        CodeFlow.insertCheckCast(mv, \"Ljava/util/Map\");\n    }\n    mv.visitLdcInsn(propertyName);\n    mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", true);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.setVaryColors",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTOfPieChart.addNewVaryColors",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.setVaryColors" ],
    "fullMethods" : [ "@Override\npublic void setVaryColors(Boolean varyColors) {\n    if (varyColors == null) {\n        if (chart.isSetVaryColors()) {\n            chart.unsetVaryColors();\n        }\n    } else if (chart.isSetVaryColors()) {\n        chart.getVaryColors().setVal(varyColors);\n    } else {\n        chart.addNewVaryColors().setVal(varyColors);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblBorders.addNewInsideH",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.setTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTc.setTblArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.setTable" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setTable(int pos, XWPFTable table) {\n    // cell.getTables().set(pos, table);\n    List<XWPFTable> tables = ((List<XWPFTable>) (ReflectionUtils.getValue(\"tables\", cell)));\n    tables.set(pos, table);\n    cell.getCTTc().setTblArray(pos, table.getCTTbl());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.SDTContentContext.createRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFHyperlinkRun.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.SDTContentContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XmlObject object, IRunBody p) {\n    if (object instanceof CTHyperlink) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (object)), ((CTHyperlink) (object)).getRArray(0), p);\n    } else if (object instanceof CTSimpleField) {\n        return new XWPFFieldRun(((CTSimpleField) (object)), ((CTSimpleField) (object)).getRArray(0), p);\n    } else {\n        return new XWPFRun(((CTR) (object)), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.SDTContentContext.createRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFHyperlinkRun.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.SDTContentContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XWPFRun xwpfRun, IRunBody p) {\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink().copy())), ((CTR) (((XWPFHyperlinkRun) (xwpfRun)).getCTR().copy())), p);\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        return new XWPFFieldRun(((CTSimpleField) (((XWPFFieldRun) (xwpfRun)).getCTField().copy())), ((CTR) (((XWPFFieldRun) (xwpfRun)).getCTR().copy())), p);\n    } else {\n        return new XWPFRun(((CTR) (xwpfRun.getCTR().copy())), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.ParagraphContext.createRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFHyperlinkRun.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.ParagraphContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XmlObject object, IRunBody p) {\n    if (object instanceof CTHyperlink) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (object)), ((CTHyperlink) (object)).getRArray(0), p);\n    } else if (object instanceof CTSimpleField) {\n        return new XWPFFieldRun(((CTSimpleField) (object)), ((CTSimpleField) (object)).getRArray(0), p);\n    } else {\n        return new XWPFRun(((CTR) (object)), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.ParagraphContext.createRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFHyperlinkRun.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.ParagraphContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XWPFRun xwpfRun, IRunBody p) {\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink().copy())), ((CTR) (((XWPFHyperlinkRun) (xwpfRun)).getCTR().copy())), p);\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        return new XWPFFieldRun(((CTSimpleField) (((XWPFFieldRun) (xwpfRun)).getCTField().copy())), ((CTR) (((XWPFFieldRun) (xwpfRun)).getCTR().copy())), p);\n    } else {\n        return new XWPFRun(((CTR) (xwpfRun.getCTR().copy())), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewHyperLinkRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFHyperlinkRun.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewHyperLinkRun" ],
    "fullMethods" : [ "public XWPFHyperlinkRun insertNewHyperLinkRun(int pos, String link) {\n    if ((pos >= 0) && (pos <= paragraph.getRuns().size())) {\n        CTHyperlink hyperlink = insertNewHyperlink(pos);\n        // hyperlink.setAnchor(link.substring(\"anchor:\".length()));\n        PackageRelationship relationship = paragraph.getPart().getPackagePart().addExternalRelationship(link, XWPFRelation.HYPERLINK.getRelation());\n        hyperlink.setId(relationship.getId());\n        CTR ctr = hyperlink.addNewR();\n        XWPFHyperlinkRun newRun = new XWPFHyperlinkRun(hyperlink, ctr, ((IRunBody) (paragraph)));\n        updateRunsAndIRuns(pos, newRun);\n        return newRun;\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.STHexColorAuto.setEnumValue",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.addSeries",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.addNewCat",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.addSeries" ],
    "fullMethods" : [ "@Override\npublic XDDFChartData.Series addSeries(XDDFDataSource<?> category, XDDFNumericalDataSource<? extends Number> values) {\n    final long index = ++this.seriesNum;\n    final CTPieSer ctSer = this.chart.addNewSer();\n    ctSer.addNewCat();\n    ctSer.addNewVal();\n    ctSer.addNewIdx().setVal(index);\n    ctSer.addNewOrder().setVal(index);\n    final Series added = new Series(ctSer, category, values);\n    this.series.add(added);\n    return added;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.addSeries",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.addNewIdx",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.addSeries" ],
    "fullMethods" : [ "@Override\npublic XDDFChartData.Series addSeries(XDDFDataSource<?> category, XDDFNumericalDataSource<? extends Number> values) {\n    final long index = ++this.seriesNum;\n    final CTPieSer ctSer = this.chart.addNewSer();\n    ctSer.addNewCat();\n    ctSer.addNewVal();\n    ctSer.addNewIdx().setVal(index);\n    ctSer.addNewOrder().setVal(index);\n    final Series added = new Series(ctSer, category, values);\n    this.series.add(added);\n    return added;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTR.addNewCommentReference",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment" ],
    "fullMethods" : [ "public static void renderComment(XWPFRun run, CommentRenderData data) throws Exception {\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper parentContext = new XWPFParagraphWrapper(paragraph);\n    BigInteger cId = BigInteger.ZERO;\n    CommentContent commentContent = data.getCommentContent();\n    if (null != commentContent) {\n        XWPFComments comments = ((NiceXWPFDocument) (paragraph.getDocument())).createComments();\n        XWPFComment newComment = comments.createComment(NextIDUtils.getCommentMaxId(comments).add(BigInteger.ONE));\n        newComment.setAuthor(commentContent.getAuthor());\n        newComment.setDate(commentContent.getDate());\n        newComment.setInitials(commentContent.getInitials());\n        renderDocument(newComment.createParagraph().createRun(), commentContent.getContent());\n        cId = newComment.getCtComment().getId();\n        parentContext.insertNewCommentRangeStart(run, cId);\n    }\n    renderParagraph(run, Paragraphs.of().addList(data.getContents()).create());\n    if (null != commentContent) {\n        parentContext.insertNewCommentRangeEnd(run, cId);\n        XWPFRun newRun = parentContext.insertNewRun(ParagraphUtils.getRunPos(run));\n        newRun.getCTR().addNewCommentReference().setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.closelySectPr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.isSetPPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.closelySectPr" ],
    "fullMethods" : [ "@Override\npublic XWPFSection closelySectPr(IBodyElement element) {\n    XWPFDocument doc = headerFooter.getXWPFDocument();\n    String relationId = doc.getRelationId(this.headerFooter);\n    if (null != relationId) {\n        List<IBodyElement> bodyElements = doc.getBodyElements();\n        for (IBodyElement ele : bodyElements) {\n            if (ele instanceof XWPFParagraph) {\n                XWPFParagraph para = ((XWPFParagraph) (ele));\n                CTP ctp = para.getCTP();\n                if (!ctp.isSetPPr())\n                    continue;\n\n                CTPPr pPr = ctp.getPPr();\n                if (pPr.isSetSectPr()) {\n                    XWPFSection xwpfSection = new XWPFSection(pPr.getSectPr());\n                    if (headerFooter instanceof XWPFHeader) {\n                        if (xwpfSection.haveHeader(relationId))\n                            return xwpfSection;\n\n                    } else if (headerFooter instanceof XWPFFooter) {\n                        if (xwpfSection.haveFooter(relationId))\n                            return xwpfSection;\n\n                    }\n                }\n            }\n        }\n    }\n    CTBody body = doc.getDocument().getBody();\n    if (body.isSetSectPr()) {\n        return new XWPFSection(body.getSectPr());\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.DocumentBodyContainer.closelySectPr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.isSetPPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.DocumentBodyContainer.closelySectPr" ],
    "fullMethods" : [ "@Override\npublic XWPFSection closelySectPr(IBodyElement element) {\n    List<IBodyElement> bodyElements = doc.getBodyElements();\n    boolean isEncounter = false;\n    for (IBodyElement ele : bodyElements) {\n        if (isEncounter) {\n            if (ele instanceof XWPFParagraph) {\n                XWPFParagraph para = ((XWPFParagraph) (ele));\n                CTP ctp = para.getCTP();\n                if (!ctp.isSetPPr())\n                    continue;\n\n                CTPPr pPr = ctp.getPPr();\n                if (pPr.isSetSectPr()) {\n                    return new XWPFSection(pPr.getSectPr());\n                }\n            }\n        } else if (ele == element) {\n            isEncounter = true;\n        }\n    }\n    CTBody body = doc.getDocument().getBody();\n    if (body.isSetSectPr()) {\n        return new XWPFSection(body.getSectPr());\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.isSetPPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.isSetPPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.isSetPPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyle(XWPFParagraph paragraph) {\n    if (null == paragraph)\n        return null;\n\n    Builder builder = ParagraphStyle.builder();\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    if (paragraph.isWordWrapped()) {\n        builder.withAllowWordBreak(true);\n    }\n    if (pr.isSetPBdr()) {\n        CTPBdr ct = pr.getPBdr();\n        if (ct.isSetLeft()) {\n            builder.withLeftBorder(retriveBorderStyle(ct.getLeft()));\n        }\n        if (ct.isSetTop()) {\n            builder.withTopBorder(retriveBorderStyle(ct.getTop()));\n        }\n        if (ct.isSetRight()) {\n            builder.withRightBorder(retriveBorderStyle(ct.getRight()));\n        }\n        if (ct.isSetBottom()) {\n            builder.withBottomBorder(retriveBorderStyle(ct.getBottom()));\n        }\n    }\n    if (pr.isSetShd()) {\n        CTShd shd = pr.getShd();\n        builder.withShadingPattern(XWPFShadingPattern.valueOf(shd.getVal().intValue()));\n        if (shd.isSetFill())\n            builder.withBackgroundColor(shd.xgetFill().getStringValue());\n\n    }\n    builder.withAlign(paragraph.getAlignment());\n    int spacingBeforeLines = paragraph.getSpacingBeforeLines();\n    if ((-1) != spacingBeforeLines) {\n        builder.withSpacingBeforeLines(spacingBeforeLines / 100.0F);\n    }\n    int spacingAfterLines = paragraph.getSpacingAfterLines();\n    if ((-1) != spacingAfterLines) {\n        builder.withSpacingAfterLines(spacingAfterLines / 100.0F);\n    }\n    int spacingBefore = paragraph.getSpacingBefore();\n    if ((-1) != spacingBefore) {\n        builder.withSpacingBefore(UnitUtils.twips2Point(spacingBefore));\n    }\n    int spacingAfter = paragraph.getSpacingAfter();\n    if ((-1) != spacingAfter) {\n        builder.withSpacingAfter(UnitUtils.twips2Point(spacingAfter));\n    }\n    double spacingBetween = paragraph.getSpacingBetween();\n    if ((-1) != spacingBetween) {\n        builder.withSpacing(spacingBetween);\n        builder.withSpacingRule(paragraph.getSpacingLineRule());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTInd.unsetRight",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.addNewStrike",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toCursor",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph" ],
    "fullMethods" : [ "@Override\npublic XWPFParagraph insertNewParagraph(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTP.type.getName().getNamespaceURI();\n        /* TODO DO not use a coded constant, find the constant in the OOXML\n        classes instead, as the child of type CT_Paragraph is defined in the\n        OOXML schema as 'p'\n         */\n        String localPart = \"p\";\n        // creates a new Paragraph, cursor is positioned inside the new\n        // element\n        cursor.beginElement(localPart, uri);\n        // move the cursor to the START token to the paragraph just created\n        cursor.toParent();\n        CTP p = ((CTP) (cursor.getObject()));\n        XWPFParagraph newP = new XWPFParagraph(p, this);\n        XmlObject o = null;\n        /* move the cursor to the previous element until a) the next\n        paragraph is found or b) all elements have been passed\n         */\n        while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        /* if the object that has been found is a) not a paragraph or b) is\n        the paragraph that has just been inserted, as the cursor in the\n        while loop above was not moved as there were no other siblings,\n        then the paragraph that was just inserted is the first paragraph\n        in the body. Otherwise, take the previous paragraph and calculate\n        the new index for the new paragraph.\n         */\n        if ((!(o instanceof CTP)) || (o == p)) {\n            paragraphs.add(0, newP);\n        } else {\n            int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n            paragraphs.add(pos, newP);\n        }\n        /* create a new cursor, that points to the START token of the just\n        inserted paragraph\n         */\n        XmlCursor newParaPos = p.newCursor();\n        try {\n            /* Calculate the paragraphs index in the list of all body\n            elements\n             */\n            int i = 0;\n            cursor.toCursor(newParaPos);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newP);\n            cursor.toCursor(newParaPos);\n            cursor.toEndToken();\n            return newP;\n        } finally {\n            newParaPos.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toCursor",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph" ],
    "fullMethods" : [ "/**\n * add a new paragraph at position of the cursor\n *\n * @param cursor\n * \t\tThe XmlCursor structure created with XmlBeans\n * @return the inserted paragraph\n */\n@Override\npublic XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInTextBox(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    bodyElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toCursor",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph" ],
    "fullMethods" : [ "public XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInBlockContent(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    sdtElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewTbl",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.toCursor",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewTbl" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTbl(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTTbl.type.getName().getNamespaceURI();\n        String localPart = \"tbl\";\n        cursor.beginElement(localPart, uri);\n        cursor.toParent();\n        CTTbl t = ((CTTbl) (cursor.getObject()));\n        XWPFTable newT = new XWPFTable(t, this);\n        XmlObject o = null;\n        while ((!(o instanceof CTTbl)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        if (!(o instanceof CTTbl)) {\n            tables.add(0, newT);\n        } else {\n            int pos = tables.indexOf(getTable(((CTTbl) (o)))) + 1;\n            tables.add(pos, newT);\n        }\n        int i = 0;\n        XmlCursor tableCursor = t.newCursor();\n        try {\n            cursor.toCursor(tableCursor);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newT);\n            cursor.toCursor(tableCursor);\n            cursor.toEndToken();\n            return newT;\n        } finally {\n            tableCursor.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.addSeries",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.addNewOrder",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.addSeries" ],
    "fullMethods" : [ "@Override\npublic XDDFChartData.Series addSeries(XDDFDataSource<?> category, XDDFNumericalDataSource<? extends Number> values) {\n    final long index = ++this.seriesNum;\n    final CTPieSer ctSer = this.chart.addNewSer();\n    ctSer.addNewCat();\n    ctSer.addNewVal();\n    ctSer.addNewIdx().setVal(index);\n    ctSer.addNewOrder().setVal(index);\n    final Series added = new Series(ctSer, category, values);\n    this.series.add(added);\n    return added;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.apache.poi.ooxml.util.POIXMLUnits.parseOnOff",
    "thirdPartyPackage" : "org.apache.poi.ooxml.util",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeStyles" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "@SuppressWarnings(\"unchecked\")\nprotected Map<String, String> mergeStyles(NiceXWPFDocument source, NiceXWPFDocument merged) {\n    Map<String, String> styleIdsMap = new HashMap<String, String>();\n    XWPFStyles styles = source.getStyles();\n    if (null == styles)\n        styles = source.createStyles();\n\n    XWPFStyles stylesMerge = merged.getStyles();\n    if (null == stylesMerge)\n        return styleIdsMap;\n\n    try {\n        Field listStyleField = XWPFStyles.class.getDeclaredField(\"listStyle\");\n        listStyleField.setAccessible(true);\n        List<XWPFStyle> lists = ((List<XWPFStyle>) (listStyleField.get(stylesMerge)));\n        String defaultParaStyleId = null;\n        for (XWPFStyle xwpfStyle : lists) {\n            if (styles.styleExist(xwpfStyle.getStyleId())) {\n                if (!getRenameAndMergeExistsStyle()) {\n                    continue;\n                }\n                String id = xwpfStyle.getStyleId();\n                xwpfStyle.setStyleId(UUID.randomUUID().toString().substring(0, 8));\n                styleIdsMap.put(id, xwpfStyle.getStyleId());\n            }\n            // fix github issue 499\n            CTStyle ctStyle = xwpfStyle.getCTStyle();\n            if ((ctStyle.isSetDefault() && POIXMLUnits.parseOnOff(ctStyle.xgetDefault())) && (ctStyle.getType() == STStyleType.PARAGRAPH)) {\n                defaultParaStyleId = ctStyle.getStyleId();\n            }\n            if (ctStyle.isSetDefault()) {\n                ctStyle.unsetDefault();\n            }\n            if (ctStyle.isSetName() && StringUtils.isBlank(ctStyle.getName().getVal())) {\n                ctStyle.getName().setVal(ctStyle.getName().getVal() + xwpfStyle.getStyleId());\n            }\n            if (ctStyle.isSetBasedOn()) {\n                String newId = styleIdsMap.get(ctStyle.getBasedOn().getVal());\n                if (null != newId)\n                    ctStyle.getBasedOn().setVal(newId);\n\n            }\n            styles.addStyle(xwpfStyle);\n        }\n        if (null != defaultParaStyleId) {\n            final String dpid = defaultParaStyleId;\n            merged.getParagraphs().stream().filter(p -> null == p.getStyle()).forEach(p -> p.setStyle(dpid));\n        }\n    } catch (Exception e) {\n        // throw exception?\n        logger.error(\"merge style error\", e);\n    }\n    return styleIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.beginElement",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph" ],
    "fullMethods" : [ "@Override\npublic XWPFParagraph insertNewParagraph(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTP.type.getName().getNamespaceURI();\n        /* TODO DO not use a coded constant, find the constant in the OOXML\n        classes instead, as the child of type CT_Paragraph is defined in the\n        OOXML schema as 'p'\n         */\n        String localPart = \"p\";\n        // creates a new Paragraph, cursor is positioned inside the new\n        // element\n        cursor.beginElement(localPart, uri);\n        // move the cursor to the START token to the paragraph just created\n        cursor.toParent();\n        CTP p = ((CTP) (cursor.getObject()));\n        XWPFParagraph newP = new XWPFParagraph(p, this);\n        XmlObject o = null;\n        /* move the cursor to the previous element until a) the next\n        paragraph is found or b) all elements have been passed\n         */\n        while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        /* if the object that has been found is a) not a paragraph or b) is\n        the paragraph that has just been inserted, as the cursor in the\n        while loop above was not moved as there were no other siblings,\n        then the paragraph that was just inserted is the first paragraph\n        in the body. Otherwise, take the previous paragraph and calculate\n        the new index for the new paragraph.\n         */\n        if ((!(o instanceof CTP)) || (o == p)) {\n            paragraphs.add(0, newP);\n        } else {\n            int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n            paragraphs.add(pos, newP);\n        }\n        /* create a new cursor, that points to the START token of the just\n        inserted paragraph\n         */\n        XmlCursor newParaPos = p.newCursor();\n        try {\n            /* Calculate the paragraphs index in the list of all body\n            elements\n             */\n            int i = 0;\n            cursor.toCursor(newParaPos);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newP);\n            cursor.toCursor(newParaPos);\n            cursor.toEndToken();\n            return newP;\n        } finally {\n            newParaPos.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.beginElement",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph" ],
    "fullMethods" : [ "/**\n * add a new paragraph at position of the cursor\n *\n * @param cursor\n * \t\tThe XmlCursor structure created with XmlBeans\n * @return the inserted paragraph\n */\n@Override\npublic XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInTextBox(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    bodyElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.beginElement",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph" ],
    "fullMethods" : [ "public XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInBlockContent(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    sdtElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewRunAfter",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.beginElement",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewRunAfter" ],
    "fullMethods" : [ "public XWPFRun insertNewRunAfter(int pos) {\n    if (pos == runs.size()) {\n        return createRun();\n    }\n    if ((pos >= 0) && (pos < runs.size())) {\n        XWPFRun run = runs.get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInRunContent(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInRunContent(newCursor)) {\n            boolean nextSibling = newCursor.toNextSibling();\n            if (!nextSibling) {\n                return createRun();\n            }\n            // provide a new run\n            String uri = CTR.type.getName().getNamespaceURI();\n            String localPart = \"r\";\n            // creates a new run, cursor is positioned inside the new\n            // element\n            newCursor.beginElement(localPart, uri);\n            // move the cursor to the START token to the run just created\n            newCursor.toParent();\n            CTR r = ((CTR) (newCursor.getObject()));\n            XWPFRun newRun = new XWPFRun(r, ((IRunBody) (this)));\n            // To update the iruns, find where we're going\n            // in the normal runs, and go in there\n            int iPos = sdtElements.size();\n            int oldAt = sdtElements.indexOf(run);\n            if (oldAt != (-1)) {\n                iPos = oldAt;\n            }\n            if ((iPos + 1) >= sdtElements.size()) {\n                sdtElements.add(newRun);\n            } else {\n                sdtElements.add(iPos, newRun);\n            }\n            // Runs itself is easy to update\n            if ((pos + 1) >= runs.size()) {\n                runs.add(newRun);\n            } else {\n                runs.add(pos + 1, newRun);\n            }\n            newCursor.dispose();\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.beginElement",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter" ],
    "fullMethods" : [ "public XWPFRun insertNewRunAfter(int pos) {\n    if (pos == paragraph.getRuns().size()) {\n        return paragraph.createRun();\n    }\n    if ((pos >= 0) && (pos < paragraph.getRuns().size())) {\n        XWPFRun run = paragraph.getRuns().get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInParagraph(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInParagraph(newCursor)) {\n            boolean nextSibling = newCursor.toNextSibling();\n            if (!nextSibling) {\n                return paragraph.createRun();\n            }\n            String uri = CTR.type.getName().getNamespaceURI();\n            String localPart = \"r\";\n            newCursor.beginElement(localPart, uri);\n            newCursor.toParent();\n            CTR r = ((CTR) (newCursor.getObject()));\n            XWPFRun newRun = new XWPFRun(r, ((IRunBody) (this.paragraph)));\n            List<IRunElement> iruns = getIRuns();\n            List<XWPFRun> runs = getRuns();\n            int iPos = iruns.size();\n            if (pos < runs.size()) {\n                XWPFRun oldAtPos = runs.get(pos);\n                int oldAt = iruns.indexOf(oldAtPos);\n                if (oldAt != (-1)) {\n                    iPos = oldAt;\n                }\n            }\n            if ((iPos + 1) >= iruns.size()) {\n                iruns.add(newRun);\n            } else {\n                iruns.add(iPos + 1, newRun);\n            }\n            // Runs itself is easy to update\n            if ((pos + 1) >= runs.size()) {\n                runs.add(newRun);\n            } else {\n                runs.add(pos + 1, newRun);\n            }\n            newCursor.dispose();\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewTbl",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.beginElement",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewTbl" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTbl(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTTbl.type.getName().getNamespaceURI();\n        String localPart = \"tbl\";\n        cursor.beginElement(localPart, uri);\n        cursor.toParent();\n        CTTbl t = ((CTTbl) (cursor.getObject()));\n        XWPFTable newT = new XWPFTable(t, this);\n        XmlObject o = null;\n        while ((!(o instanceof CTTbl)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        if (!(o instanceof CTTbl)) {\n            tables.add(0, newT);\n        } else {\n            int pos = tables.indexOf(getTable(((CTTbl) (o)))) + 1;\n            tables.add(pos, newT);\n        }\n        int i = 0;\n        XmlCursor tableCursor = t.newCursor();\n        try {\n            cursor.toCursor(tableCursor);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newT);\n            cursor.toCursor(tableCursor);\n            cursor.toEndToken();\n            return newT;\n        } finally {\n            tableCursor.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveBorderStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTBorder.isSetColor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveBorderStyle" ],
    "fullMethods" : [ "public static BorderStyle retriveBorderStyle(CTBorder border) {\n    BorderStyle.Builder borderBuilder = BorderStyle.builder();\n    if (border.isSetColor())\n        borderBuilder.withColor(border.xgetColor().getStringValue());\n\n    if (border.isSetSz())\n        borderBuilder.withSize(border.getSz().intValue());\n\n    if (border.getVal() != null)\n        borderBuilder.withType(XWPFBorderType.valueOf(border.getVal().toString().toUpperCase()));\n\n    return borderBuilder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.init",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFDocument.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.init" ],
    "fullMethods" : [ "{\n    com.deepoove.poi.xwpf.NiceXWPFDocument$2 this;\n    java.io.InputStream $stack2;\n    java.lang.Object $stack3;\n    org.apache.poi.ooxml.POIXMLDocumentPart #l1;\n    org.apache.poi.openxml4j.opc.PackagePart part;\n    org.apache.poi.xwpf.usermodel.XWPFDocument #l0;\n\n\n    this := @this: com.deepoove.poi.xwpf.NiceXWPFDocument$2;\n    part := @parameter0: org.apache.poi.openxml4j.opc.PackagePart;\n    $stack3 = new org.apache.poi.xwpf.usermodel.XWPFDocument;\n    $stack2 = virtualinvoke part.<org.apache.poi.openxml4j.opc.PackagePart: java.io.InputStream getInputStream()>();\n    #l0 = (org.apache.poi.xwpf.usermodel.XWPFDocument) $stack3;\n    specialinvoke #l0.<org.apache.poi.xwpf.usermodel.XWPFDocument: void <init>(java.io.InputStream)>($stack2);\n    #l1 = (org.apache.poi.ooxml.POIXMLDocumentPart) $stack3;\n\n    return #l1;\n}\n" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFDocument.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.<init>" ],
    "fullMethods" : [ "public NiceXWPFDocument(InputStream in, boolean adjustDoc) throws IOException {\n    super(in);\n    this.adjustDoc = adjustDoc;\n    idenifierManagerWrapper = new IdenifierManagerWrapper(this);\n    niceDocumentRead();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblBorders.addNewRight",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.toc.TOCRenderPolicy.render",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTSimpleField.setInstr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.toc.TOCRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    XWPFRun run = ((RunTemplate) (eleTemplate)).getRun();\n    run.setText(\"\", 0);\n    XWPFParagraph tocPara = ((XWPFParagraph) (run.getParent()));\n    XWPFFieldRun fieldRun = tocPara.insertNewFieldRun(0);\n    CTSimpleField toc = fieldRun.getCTField();\n    toc.setInstr(\"TOC \\\\o\");\n    toc.setDirty(XWPFOnOff.ON);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTColor.isSetThemeColor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun" ],
    "fullMethods" : [ "/**\n * set run style by style\n *\n * @param run\n * @param style\n */\npublic static void styleRun(XWPFRun run, Style style) {\n    if ((null == run) || (null == style))\n        return;\n\n    CTRPr pr = getRunProperties(run);\n    String color = style.getColor();\n    if (StringUtils.isNotBlank(color)) {\n        // run.setColor(color);\n        // issue 326\n        CTColor ctColor = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        ctColor.setVal(color);\n        if (ctColor.isSetThemeColor())\n            ctColor.unsetThemeColor();\n\n    }\n    double fontSize = style.getFontSize();\n    if ((0 != fontSize) && ((-1) != fontSize)) {\n        run.setFontSize(fontSize);\n    }\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        run.setFontFamily(fontFamily, FontCharRange.eastAsia);\n        run.setFontFamily(fontFamily, FontCharRange.ascii);\n        run.setFontFamily(fontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(fontFamily, FontCharRange.cs);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        run.setFontFamily(westernFontFamily, FontCharRange.ascii);\n        run.setFontFamily(westernFontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(westernFontFamily, FontCharRange.cs);\n    }\n    XWPFHighlightColor highlightColor = style.getHighlightColor();\n    if (null != highlightColor) {\n        CTHighlight highlight = (pr.sizeOfHighlightArray() > 0) ? pr.getHighlightArray(0) : pr.addNewHighlight();\n        highlight.setVal(STHighlightColor.Enum.forInt(highlightColor.getValue()));\n    }\n    Boolean bold = style.isBold();\n    if (null != bold)\n        run.setBold(bold);\n\n    Boolean italic = style.isItalic();\n    if (null != italic)\n        run.setItalic(italic);\n\n    Boolean strike = style.isStrike();\n    if (null != strike)\n        run.setStrikeThrough(strike);\n\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        run.setUnderline(underlinePatern);\n        if (null != style.getUnderlineColor()) {\n            run.setUnderlineColor(style.getUnderlineColor());\n        }\n    }\n    int point = style.getCharacterSpacing();\n    // in twentieths of a point\n    if ((0 != point) && ((-1) != point))\n        run.setCharacterSpacing(UnitUtils.point2Twips(point));\n\n    String vertAlign = style.getVertAlign();\n    if (StringUtils.isNotBlank(vertAlign)) {\n        run.setVerticalAlignment(vertAlign);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTc.getTcPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render", "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.getColIndex" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        for (int i = rowSize - 1; i >= 0; i--) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            String text = row.getCell(actualInsertPosition).getText();\n            if (\"_delete_\".equals(text)) {\n                table.removeRow(i);\n            } else {\n                removeCell(row, actualInsertPosition);\n            }\n        }\n    } catch (Exception e) {\n    }\n}", "private int getColIndex(XWPFTableCell cell) {\n    XWPFTableRow tableRow = cell.getTableRow();\n    int orginalCol = 0;\n    for (int i = 0; i < tableRow.getTableCells().size(); i++) {\n        XWPFTableCell current = tableRow.getCell(i);\n        int intValue = 1;\n        CTTcPr tcPr = current.getCTTc().getTcPr();\n        if (null != tcPr) {\n            CTDecimalNumber gridSpan = tcPr.getGridSpan();\n            if (null != gridSpan)\n                intValue = gridSpan.getVal().intValue();\n\n        }\n        orginalCol += intValue;\n        if (current.getCTTc() == cell.getCTTc()) {\n            return orginalCol - intValue;\n        }\n    }\n    return -1;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTc.getTcPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render", "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.getActualInsertPosition" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}", "private int getActualInsertPosition(XWPFTableRow tableRow, int insertPosition) {\n    int orginalCol = 0;\n    for (int i = 0; i < tableRow.getTableCells().size(); i++) {\n        XWPFTableCell current = tableRow.getCell(i);\n        int intValue = 1;\n        CTTcPr tcPr = current.getCTTc().getTcPr();\n        if (null != tcPr) {\n            CTDecimalNumber gridSpan = tcPr.getGridSpan();\n            if (null != gridSpan)\n                intValue = gridSpan.getVal().intValue();\n\n        }\n        orginalCol += intValue;\n        if (((orginalCol - intValue) == insertPosition) && (intValue == 1)) {\n            return i;\n        }\n    }\n    return -1;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableCell",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTc.getTcPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableCell" ],
    "fullMethods" : [ "/**\n * set cell style\n *\n * @param cell\n * @param cellStyle\n */\npublic static void styleTableCell(XWPFTableCell cell, CellStyle cellStyle) {\n    if ((null == cell) || (null == cellStyle))\n        return;\n\n    if (null != cellStyle.getVertAlign()) {\n        cell.setVerticalAlignment(cellStyle.getVertAlign());\n    }\n    if (null != cellStyle.getBackgroundColor()) {\n        CTTc ctTc = cell.getCTTc();\n        CTTcPr pr = (ctTc.isSetTcPr()) ? ctTc.getTcPr() : ctTc.addNewTcPr();\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = cellStyle.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(cellStyle.getBackgroundColor());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTc.getTcPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render", "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.getActualInsertPosition" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}", "private int getActualInsertPosition(XWPFTableRow tableRow, int insertPosition) {\n    int orginalCol = 0;\n    for (int i = 0; i < tableRow.getTableCells().size(); i++) {\n        XWPFTableCell current = tableRow.getCell(i);\n        int intValue = 1;\n        CTTcPr tcPr = current.getCTTc().getTcPr();\n        if (null != tcPr) {\n            CTDecimalNumber gridSpan = tcPr.getGridSpan();\n            if (null != gridSpan)\n                intValue = gridSpan.getVal().intValue();\n\n        }\n        orginalCol += intValue;\n        if (((orginalCol - intValue) == insertPosition) && (intValue == 1)) {\n            return i;\n        }\n    }\n    return -1;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.getTcPr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTc.getTcPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.getTcPr" ],
    "fullMethods" : [ "public static CTTcPr getTcPr(XWPFTableCell cell) {\n    CTTcPr tcPr = (cell.getCTTc().isSetTcPr()) ? cell.getCTTc().getTcPr() : cell.getCTTc().addNewTcPr();\n    return tcPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTc.getTcPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render", "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.getColIndex" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        int templateColIndex = getColIndex(tagCell);\n        if ((null == data) || ((data instanceof Boolean) && (!((Boolean) (data))))) {\n            // table.removeRow(templateRowIndex);\n            // tagCell.setText(\"_delete_\");\n            run.setText(\"_delete_\", 0);\n            CTTcPr tcPr = TableTools.getTcPr(tagCell);\n            CTVMerge vMerge = tcPr.getVMerge();\n            System.out.println(null == vMerge ? null : vMerge.getVal());\n            if ((null != vMerge) && vMerge.getVal().equals(STMerge.RESTART)) {\n                XWPFTableRow row = table.getRow(templateRowIndex + 1);\n                int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n                XWPFTableCell actualCell = row.getCell(actualInsertPosition);\n                System.out.println(actualCell.getCTTc());\n                actualCell.getParagraphArray(0).createRun().setText(\"_delete_\", 0);\n            }\n        } else {\n            run.setText(\"\", 0);\n        }\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}", "private int getColIndex(XWPFTableCell cell) {\n    XWPFTableRow tableRow = cell.getTableRow();\n    int orginalCol = 0;\n    for (int i = 0; i < tableRow.getTableCells().size(); i++) {\n        XWPFTableCell current = tableRow.getCell(i);\n        int intValue = 1;\n        CTTcPr tcPr = current.getCTTc().getTcPr();\n        if (null != tcPr) {\n            CTDecimalNumber gridSpan = tcPr.getGridSpan();\n            if (null != gridSpan)\n                intValue = gridSpan.getVal().intValue();\n\n        }\n        orginalCol += intValue;\n        if (current.getCTTc() == cell.getCTTc()) {\n            return orginalCol - intValue;\n        }\n    }\n    return -1;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblBorders.addNewTop",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.getStrikeArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTTx.unsetStrRef",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setTitle", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setCTTitle" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartMultiSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    List<XDDFChartData> chartSeries = chart.getChartSeries();\n    validate(chartSeries, data);\n    int totalSeriesCount = ensureSeriesCount(chart, chartSeries);\n    int valueCol = 1;\n    List<SeriesRenderData> usedSeriesDatas = new ArrayList<>();\n    for (XDDFChartData chartData : chartSeries) {\n        int orignSize = chartData.getSeriesCount();\n        List<SeriesRenderData> currentSeriesData = null;\n        if (chartSeries.size() <= 1) {\n            // ignore combo type\n            currentSeriesData = data.getSeriesDatas();\n        } else {\n            currentSeriesData = obtainSeriesData(chartData.getClass(), data.getSeriesDatas());\n        }\n        usedSeriesDatas.addAll(currentSeriesData);\n        int currentSeriesSize = currentSeriesData.size();\n        XDDFDataSource<?> categoriesData = null;\n        if (chartData instanceof XDDFScatterChartData) {\n            categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n        } else {\n            categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n        }\n        for (int i = 0; i < currentSeriesSize; i++) {\n            XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, currentSeriesData.get(i).getValues(), valueCol);\n            XDDFChartData.Series currentSeries = null;\n            if (i < orignSize) {\n                currentSeries = chartData.getSeries(i);\n                valuesData.setFormatCode(currentSeries.getValuesData().getFormatCode());\n                currentSeries.replaceData(categoriesData, valuesData);\n            } else {\n                // add series, should copy series with style\n                currentSeries = chartData.addSeries(categoriesData, valuesData);\n                processNewSeries(chartData, currentSeries);\n            }\n            String name = currentSeriesData.get(i).getName();\n            currentSeries.setTitle(name, chart.setSheetTitle(name, valueCol));\n            valueCol++;\n        }\n        // clear extra series\n        removeExtraSeries(chartData, orignSize, currentSeriesSize);\n    }\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    updateCTTable(sheet, usedSeriesDatas);\n    removeExtraSheetCell(sheet, data.getCategories().length, totalSeriesCount, usedSeriesDatas.size());\n    for (XDDFChartData chartData : chartSeries) {\n        plot(chart, chartData);\n    }\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "protected void setTitle(XWPFChart chart, String title) {\n    if ((null == title) && chart.getCTChart().isSetTitle()) {\n        chart.getCTChart().unsetTitle();\n        return;\n    }\n    CTTitle ctTitle = chart.getCTChart().getTitle();\n    boolean isSet = setCTTitle(ctTitle, title);\n    if (!isSet) {\n        chart.setTitleText(title);\n        chart.setTitleOverlay(false);\n    }\n}", "private boolean setCTTitle(CTTitle ctTitle, String title) {\n    boolean isSet = false;\n    if (null != ctTitle) {\n        if (!ctTitle.isSetTx()) {\n            ctTitle.addNewTx();\n        }\n        CTTx tx = ctTitle.getTx();\n        if (tx.isSetStrRef()) {\n            tx.unsetStrRef();\n        }\n        if (!tx.isSetRich()) {\n            tx.addNewRich();\n        }\n        CTTextBody body = tx.getRich();\n        if (body.sizeOfPArray() > 0) {\n            // remove all but first paragraph\n            for (int i = body.sizeOfPArray() - 1; i > 0; i--) {\n                body.removeP(i);\n            }\n            CTTextParagraph pArray = body.getPArray(0);\n            if (pArray.sizeOfRArray() > 0) {\n                for (int i = pArray.sizeOfRArray() - 1; i > 0; i--) {\n                    pArray.removeR(i);\n                }\n                CTRegularTextRun rArray = pArray.getRArray(0);\n                rArray.setT(title);\n                isSet = true;\n            }\n        }\n    }\n    return isSet;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTTx.unsetStrRef",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setTitle", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setCTTitle" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartSingleSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    XDDFChartData pie = ChartUtils.getChartSeries(chart).get(0);\n    SeriesRenderData seriesDatas = data.getSeriesData();\n    XDDFDataSource<?> categoriesData = null;\n    if (pie instanceof XDDFScatterChartData) {\n        categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n    } else {\n        categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n    }\n    XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, seriesDatas.getValues(), 1);\n    XDDFChartData.Series currentSeries = pie.getSeries(0);\n    currentSeries.replaceData(categoriesData, valuesData);\n    currentSeries.setTitle(seriesDatas.getName(), chart.setSheetTitle(seriesDatas.getName(), 1));\n    updateCTTable(chart.getWorkbook().getSheetAt(0), Arrays.asList(seriesDatas));\n    plot(chart, pie);\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "protected void setTitle(XWPFChart chart, String title) {\n    if ((null == title) && chart.getCTChart().isSetTitle()) {\n        chart.getCTChart().unsetTitle();\n        return;\n    }\n    CTTitle ctTitle = chart.getCTChart().getTitle();\n    boolean isSet = setCTTitle(ctTitle, title);\n    if (!isSet) {\n        chart.setTitleText(title);\n        chart.setTitleOverlay(false);\n    }\n}", "private boolean setCTTitle(CTTitle ctTitle, String title) {\n    boolean isSet = false;\n    if (null != ctTitle) {\n        if (!ctTitle.isSetTx()) {\n            ctTitle.addNewTx();\n        }\n        CTTx tx = ctTitle.getTx();\n        if (tx.isSetStrRef()) {\n            tx.unsetStrRef();\n        }\n        if (!tx.isSetRich()) {\n            tx.addNewRich();\n        }\n        CTTextBody body = tx.getRich();\n        if (body.sizeOfPArray() > 0) {\n            // remove all but first paragraph\n            for (int i = body.sizeOfPArray() - 1; i > 0; i--) {\n                body.removeP(i);\n            }\n            CTTextParagraph pArray = body.getPArray(0);\n            if (pArray.sizeOfRArray() > 0) {\n                for (int i = pArray.sizeOfRArray() - 1; i > 0; i--) {\n                    pArray.removeR(i);\n                }\n                CTRegularTextRun rArray = pArray.getRArray(0);\n                rArray.setT(title);\n                isSet = true;\n            }\n        }\n    }\n    return isSet;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isNotEmpty",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun" ],
    "fullMethods" : [ "/**\n * set run style by other run\n *\n * @param dest\n * @param src\n */\npublic static void styleRun(XWPFRun dest, XWPFRun src) {\n    if ((null == dest) || (null == src))\n        return;\n\n    if (StringUtils.isNotEmpty(src.getStyle()))\n        dest.setStyle(src.getStyle());\n\n    if (Boolean.TRUE.equals(src.isBold()))\n        dest.setBold(src.isBold());\n\n    if (StringUtils.isNotBlank(src.getColor()))\n        dest.setColor(src.getColor());\n\n    if (0 != src.getCharacterSpacing())\n        dest.setCharacterSpacing(src.getCharacterSpacing());\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.ascii)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.ascii);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.eastAsia)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.eastAsia);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.hAnsi)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.hAnsi);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.cs)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.cs);\n\n    Double fontSize = src.getFontSizeAsDouble();\n    if (null != fontSize) {\n        dest.setFontSize(fontSize);\n    }\n    if (Boolean.TRUE.equals(src.isItalic()))\n        dest.setItalic(src.isItalic());\n\n    if (Boolean.TRUE.equals(src.isStrikeThrough()))\n        dest.setStrikeThrough(src.isStrikeThrough());\n\n    if (UnderlinePatterns.NONE != src.getUnderline())\n        dest.setUnderline(src.getUnderline());\n\n    if (null != src.getUnderlineColor())\n        dest.setUnderlineColor(src.getUnderlineColor());\n\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isNotEmpty",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements", "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveBodyElements(List<IBodyElement> bodyElements) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (null == bodyElements)\n        return metaTemplates;\n\n    // current iterable templates state\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    for (IBodyElement element : bodyElements) {\n        if (element == null)\n            continue;\n\n        if (element.getElementType() == BodyElementType.PARAGRAPH) {\n            resolveParagraph(((XWPFParagraph) (element)), metaTemplates, stack);\n        } else if (element.getElementType() == BodyElementType.TABLE) {\n            XWPFTable table = ((XWPFTable) (element));\n            List<XWPFTableRow> rows = table.getRows();\n            if (null == rows)\n                continue;\n\n            for (XWPFTableRow row : rows) {\n                resolveTableRow(row, metaTemplates, stack);\n            }\n        } else if ((element.getElementType() == BodyElementType.CONTENTCONTROL) && (element instanceof XWPFStructuredDocumentTag)) {\n            XWPFStructuredDocumentTag sdt = ((XWPFStructuredDocumentTag) (element));\n            addNewMeta(metaTemplates, stack, resolveSDTElements(sdt.getContent()));\n        }\n    }\n    checkStack(stack);\n    return metaTemplates;\n}", "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.BufferedImageUtils.getBufferByteArray",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isNotEmpty",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.util.BufferedImageUtils.getBufferByteArray" ],
    "fullMethods" : [ "/**\n * Get picture byte array of BufferedImage\n *\n * @param image\n * @param format\n * \t\tformat of the image\n * @return  */\npublic static byte[] getBufferByteArray(BufferedImage image, String format) {\n    if (null == image)\n        return null;\n\n    String formatName = (StringUtils.isNotEmpty(format) && (format.charAt(0) == '.')) ? format.substring(1) : format;\n    if (StringUtils.isEmpty(formatName))\n        formatName = \"png\";\n\n    ByteArrayOutputStream os = new ByteArrayOutputStream();\n    try {\n        ImageIO.write(image, formatName, os);\n        return os.toByteArray();\n    } catch (Exception e) {\n        logger.error(\"getBufferByteArray error\", e);\n        return null;\n    } finally {\n        IOUtils.closeQuietly(os);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isNotEmpty",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveXWPFRuns(List<XWPFRun> runs) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (runs == null)\n        return metaTemplates;\n\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    resolveXWPFRuns(runs, metaTemplates, stack);\n    checkStack(stack);\n    return metaTemplates;\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph",
    "thirdPartyMethod" : "org.apache.commons.lang3.StringUtils.isNotEmpty",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns" ],
    "fullMethods" : [ "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr.getWordWrap",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTInd.unsetFirstLine",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.PictureRenderPolicy.Helper.renderPicture",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.addPicture",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.PictureRenderPolicy.Helper.renderPicture" ],
    "fullMethods" : [ "public static void renderPicture(XWPFRun run, PictureRenderData picture) throws Exception {\n    byte[] imageBytes = picture.readPictureData();\n    if (null == imageBytes) {\n        throw new IllegalStateException(\"Can't read picture byte arrays!\");\n    }\n    PictureType pictureType = picture.getPictureType();\n    if (null == pictureType) {\n        pictureType = PictureType.suggestFileType(imageBytes);\n    }\n    if (null == pictureType) {\n        throw new RenderException(\"PictureRenderData must set picture type!\");\n    }\n    PictureStyle style = picture.getPictureStyle();\n    if (null == style)\n        style = new PictureStyle();\n\n    int width = style.getWidth();\n    int height = style.getHeight();\n    int svgScale = style.getSvgScale();\n    if (pictureType == PictureType.SVG) {\n        imageBytes = SVGConvertor.toPng(imageBytes, ((float) (width)), ((float) (height)), svgScale);\n        pictureType = PictureType.PNG;\n    }\n    if (!isSetSize(style)) {\n        BufferedImage original = BufferedImageUtils.readBufferedImage(imageBytes);\n        width = original.getWidth();\n        height = original.getHeight();\n        if (style.getScalePattern() == WidthScalePattern.FIT) {\n            BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n            int pageWidth = UnitUtils.twips2Pixel(bodyContainer.elementPageWidth(((IBodyElement) (run.getParent()))));\n            if (width > pageWidth) {\n                double ratio = pageWidth / ((double) (width));\n                width = pageWidth;\n                height = ((int) (height * ratio));\n            }\n        }\n    }\n    try (InputStream stream = new ByteArrayInputStream(imageBytes)) {\n        PictureAlign align = style.getAlign();\n        if ((null != align) && (run.getParent() instanceof XWPFParagraph)) {\n            ((XWPFParagraph) (run.getParent())).setAlignment(ParagraphAlignment.valueOf(align.ordinal() + 1));\n        }\n        run.addPicture(stream, pictureType.type(), \"Generated\", Units.pixelToEMU(width), Units.pixelToEMU(height));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.WhereDelegate.addPicture",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.addPicture",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.WhereDelegate.addPicture" ],
    "fullMethods" : [ "public void addPicture(InputStream inputStream, int type, int width, int height) throws InvalidFormatException, IOException {\n    run.addPicture(inputStream, type, \"Generated\", Units.pixelToEMU(width), Units.pixelToEMU(height));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewCommentRangeStart",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewCommentRangeStart", "com.deepoove.poi.xwpf.XWPFParagraphWrapper.getPosOfRun" ],
    "fullMethods" : [ "public void insertNewCommentRangeStart(XWPFRun run, BigInteger cId) {\n    int pos = getPosOfRun(run);\n    CTP ctp = paragraph.getCTP();\n    synchronized(ctp.monitor()) {\n        // check_orphaned();\n        CTMarkupRange mark = ((CTMarkupRange) (((CTPImpl) (ctp)).get_store().insert_element_user(RUN_QNAME_SET, COMMENT_START_QNAME, pos)));\n        mark.setId(cId);\n    }\n}", "private int getPosOfRun(XWPFRun run) {\n    int pos = -1;\n    List<XWPFRun> runs = paragraph.getRuns();\n    for (int i = 0; i < runs.size(); i++) {\n        if (run == runs.get(i)) {\n            pos = i;\n            break;\n        }\n    }\n    return pos;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewBookmark",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewBookmark", "com.deepoove.poi.xwpf.XWPFParagraphWrapper.getPosOfRun" ],
    "fullMethods" : [ "public CTBookmark insertNewBookmark(XWPFRun run) {\n    int pos = getPosOfRun(run);\n    CTMarkupRange end = insertNewBookmarkEnd(pos + 1);\n    CTBookmark start = insertNewBookmarkStart(pos);\n    start.setId(BigInteger.valueOf(500 + new Random().nextInt(50000)));\n    end.setId(start.getId());\n    return start;\n}", "private int getPosOfRun(XWPFRun run) {\n    int pos = -1;\n    List<XWPFRun> runs = paragraph.getRuns();\n    for (int i = 0; i < runs.size(); i++) {\n        if (run == runs.get(i)) {\n            pos = i;\n            break;\n        }\n    }\n    return pos;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.ParagraphContext.getRuns",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.ParagraphContext.getRuns" ],
    "fullMethods" : [ "@Override\npublic List<XWPFRun> getRuns() {\n    return paragraphWrapper.getParagraph().getRuns();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRun" ],
    "fullMethods" : [ "public XWPFRun insertNewRun(int pos) {\n    if ((pos >= 0) && (pos <= paragraph.getRuns().size())) {\n        CTR ctRun = this.insertNewR(pos);\n        XWPFRun newRun = new XWPFRun(ctRun, ((IRunBody) (paragraph)));\n        updateRunsAndIRuns(pos, newRun);\n        return newRun;\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ParagraphUtils.havePictures",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.ParagraphUtils.havePictures" ],
    "fullMethods" : [ "public static boolean havePictures(XWPFParagraph paragraph) {\n    List<XWPFRun> runs = paragraph.getRuns();\n    for (XWPFRun run : runs) {\n        if (CollectionUtils.isNotEmpty(run.getEmbeddedPictures()))\n            return true;\n\n    }\n    return false;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ParagraphUtils.haveObject",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.ParagraphUtils.haveObject" ],
    "fullMethods" : [ "public static boolean haveObject(XWPFParagraph paragraph) {\n    List<XWPFRun> runs = paragraph.getRuns();\n    for (XWPFRun run : runs) {\n        if (CollectionUtils.isNotEmpty(run.getCTR().getObjectList()))\n            return true;\n\n    }\n    return false;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewField",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewField" ],
    "fullMethods" : [ "public XWPFFieldRun insertNewField(int pos) {\n    if ((pos >= 0) && (pos <= paragraph.getRuns().size())) {\n        CTSimpleField ctSimpleField = this.insertNewFldSimple(pos);\n        CTR addNewR = ctSimpleField.addNewR();\n        XWPFFieldRun newRun = new XWPFFieldRun(ctSimpleField, addNewR, ((IRunBody) (paragraph)));\n        // To update the iruns, find where we're going\n        // in the normal runs, and go in there\n        updateRunsAndIRuns(pos, newRun);\n        return newRun;\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ParagraphUtils.havePageBreak",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.ParagraphUtils.havePageBreak" ],
    "fullMethods" : [ "public static boolean havePageBreak(XWPFParagraph paragraph) {\n    List<XWPFRun> runs = paragraph.getRuns();\n    for (XWPFRun run : runs) {\n        if (CollectionUtils.isNotEmpty(run.getCTR().getLastRenderedPageBreakList()))\n            return true;\n\n    }\n    return false;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewHyperLinkRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewHyperLinkRun", "com.deepoove.poi.xwpf.XWPFParagraphWrapper.getPosOfRun" ],
    "fullMethods" : [ "public XWPFRun insertNewHyperLinkRun(XWPFRun run, String link) {\n    if (StringUtils.isBlank(link))\n        throw new IllegalArgumentException(\"Hyperlink must not be Empty!\");\n\n    if (link.startsWith(\"anchor:\")) {\n        return insertNewAnchor(getPosOfRun(run), link.substring(\"anchor:\".length()));\n    }\n    return insertNewHyperLinkRun(getPosOfRun(run), link);\n}", "private int getPosOfRun(XWPFRun run) {\n    int pos = -1;\n    List<XWPFRun> runs = paragraph.getRuns();\n    for (int i = 0; i < runs.size(); i++) {\n        if (run == runs.get(i)) {\n            pos = i;\n            break;\n        }\n    }\n    return pos;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewHyperLinkRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewHyperLinkRun" ],
    "fullMethods" : [ "public XWPFHyperlinkRun insertNewHyperLinkRun(int pos, String link) {\n    if ((pos >= 0) && (pos <= paragraph.getRuns().size())) {\n        CTHyperlink hyperlink = insertNewHyperlink(pos);\n        // hyperlink.setAnchor(link.substring(\"anchor:\".length()));\n        PackageRelationship relationship = paragraph.getPart().getPackagePart().addExternalRelationship(link, XWPFRelation.HYPERLINK.getRelation());\n        hyperlink.setId(relationship.getId());\n        CTR ctr = hyperlink.addNewR();\n        XWPFHyperlinkRun newRun = new XWPFHyperlinkRun(hyperlink, ctr, ((IRunBody) (paragraph)));\n        updateRunsAndIRuns(pos, newRun);\n        return newRun;\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getText",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getText", "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.appendParagraph" ],
    "fullMethods" : [ "@Override\npublic String getText() {\n    StringBuilder text = new StringBuilder();\n    boolean addNewLine = false;\n    for (int i = 0; i < sdtElements.size(); i++) {\n        Object o = sdtElements.get(i);\n        if (o instanceof XWPFParagraph) {\n            appendParagraph(((XWPFParagraph) (o)), text);\n            addNewLine = true;\n        } else if (o instanceof XWPFTable) {\n            appendTable(((XWPFTable) (o)), text);\n            addNewLine = true;\n        } else if (o instanceof XWPFSDT) {\n            text.append(((XWPFSDT) (o)).getContent().getText());\n            addNewLine = true;\n        } else if (o instanceof XWPFRun) {\n            text.append(o);\n            addNewLine = false;\n        }\n        if (addNewLine && (i < (sdtElements.size() - 1))) {\n            text.append(\"\\n\");\n        }\n    }\n    return text.toString();\n}", "private void appendParagraph(XWPFParagraph paragraph, StringBuilder text) {\n    for (IRunElement run : paragraph.getRuns()) {\n        text.append(run);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.DrawingSupport.updateDocPrId",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.DrawingSupport.updateDocPrId" ],
    "fullMethods" : [ "public static void updateDocPrId(XWPFParagraph paragraph) {\n    updateDocPrId(paragraph.getRuns());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ParagraphUtils.getRunPos",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.ParagraphUtils.getRunPos", "com.deepoove.poi.util.ParagraphUtils.getRunList" ],
    "fullMethods" : [ "public static Integer getRunPos(XWPFRun run) {\n    List<XWPFRun> runs = getRunList(run);\n    for (int i = 0; i < runs.size(); i++) {\n        if (run == runs.get(i)) {\n            return i;\n        }\n    }\n    return null;\n}", "private static List<XWPFRun> getRunList(XWPFRun run) {\n    IRunBody parent = run.getParent();\n    if (parent instanceof XWPFParagraph) {\n        XWPFParagraph paragraph = ((XWPFParagraph) (parent));\n        return paragraph.getRuns();\n    } else if (parent instanceof XWPFStructuredDocumentTagContent) {\n        XWPFStructuredDocumentTagContent paragraph = ((XWPFStructuredDocumentTagContent) (parent));\n        return paragraph.getRuns();\n    }\n    return new ArrayList<>();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewCommentRangeEnd",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewCommentRangeEnd", "com.deepoove.poi.xwpf.XWPFParagraphWrapper.getPosOfRun" ],
    "fullMethods" : [ "public void insertNewCommentRangeEnd(XWPFRun run, BigInteger cId) {\n    int pos = getPosOfRun(run);\n    CTP ctp = paragraph.getCTP();\n    synchronized(ctp.monitor()) {\n        // check_orphaned();\n        CTMarkupRange mark = ((CTMarkupRange) (((CTPImpl) (ctp)).get_store().insert_element_user(RUN_QNAME_SET, COMMENT_END_QNAME, pos)));\n        mark.setId(cId);\n    }\n}", "private int getPosOfRun(XWPFRun run) {\n    int pos = -1;\n    List<XWPFRun> runs = paragraph.getRuns();\n    for (int i = 0; i < runs.size(); i++) {\n        if (run == runs.get(i)) {\n            pos = i;\n            break;\n        }\n    }\n    return pos;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.AbstractIterableProcessor.visit",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.AbstractIterableProcessor.visit", "com.deepoove.poi.render.processor.IterableProcessor.handleNever" ],
    "fullMethods" : [ "@Override\npublic void visit(IterableTemplate iterableTemplate) {\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(iterableTemplate);\n    Object compute = renderDataCompute.compute(iterableTemplate.getStartMark().getTagName());\n    if ((null == compute) || ((compute instanceof Boolean) && (!((Boolean) (compute))))) {\n        handleNever(iterableTemplate, bodyContainer);\n        afterHandle(iterableTemplate, bodyContainer, true);\n    } else if (compute instanceof Iterable) {\n        handleIterable(iterableTemplate, bodyContainer, ((Iterable<?>) (compute)));\n        afterHandle(iterableTemplate, bodyContainer, false);\n    } else {\n        if ((compute instanceof Boolean) && ((Boolean) (compute))) {\n            handleOnceWithScope(iterableTemplate, renderDataCompute);\n        } else {\n            handleOnce(iterableTemplate, compute);\n        }\n        afterHandle(iterableTemplate, bodyContainer, false);\n    }\n}", "@Override\nprotected void handleNever(IterableTemplate iterableTemplate, BodyContainer bodyContainer) {\n    XWPFParagraph startParagraph = ((XWPFParagraph) (iterableTemplate.getStartRun().getParent()));\n    XWPFParagraph endParagraph = ((XWPFParagraph) (iterableTemplate.getEndRun().getParent()));\n    int startPos = bodyContainer.getPosOfParagraphCTP(startParagraph.getCTP());\n    int endPos = bodyContainer.getPosOfParagraphCTP(endParagraph.getCTP());\n    // remove content\n    for (int i = endPos - 1; i > startPos; i--) {\n        bodyContainer.removeBodyElement(i);\n    }\n    XWPFParagraphWrapper startParagraphWrapper = new XWPFParagraphWrapper(startParagraph);\n    XWPFParagraphWrapper endParagraphWrapper = new XWPFParagraphWrapper(endParagraph);\n    Integer startRunPos = iterableTemplate.getStartMark().getRunPos();\n    Integer endRunPos = iterableTemplate.getEndMark().getRunPos();\n    // remove run content\n    List<XWPFRun> startRuns = startParagraph.getRuns();\n    int startSize = startRuns.size();\n    for (int i = startSize - 1; i > startRunPos; i--) {\n        startParagraphWrapper.removeRun(i);\n    }\n    for (int i = endRunPos - 1; i >= 0; i--) {\n        endParagraphWrapper.removeRun(i);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter" ],
    "fullMethods" : [ "public XWPFRun insertNewRunAfter(int pos) {\n    if (pos == paragraph.getRuns().size()) {\n        return paragraph.createRun();\n    }\n    if ((pos >= 0) && (pos < paragraph.getRuns().size())) {\n        XWPFRun run = paragraph.getRuns().get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInParagraph(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInParagraph(newCursor)) {\n            boolean nextSibling = newCursor.toNextSibling();\n            if (!nextSibling) {\n                return paragraph.createRun();\n            }\n            String uri = CTR.type.getName().getNamespaceURI();\n            String localPart = \"r\";\n            newCursor.beginElement(localPart, uri);\n            newCursor.toParent();\n            CTR r = ((CTR) (newCursor.getObject()));\n            XWPFRun newRun = new XWPFRun(r, ((IRunBody) (this.paragraph)));\n            List<IRunElement> iruns = getIRuns();\n            List<XWPFRun> runs = getRuns();\n            int iPos = iruns.size();\n            if (pos < runs.size()) {\n                XWPFRun oldAtPos = runs.get(pos);\n                int oldAt = iruns.indexOf(oldAtPos);\n                if (oldAt != (-1)) {\n                    iPos = oldAt;\n                }\n            }\n            if ((iPos + 1) >= iruns.size()) {\n                iruns.add(newRun);\n            } else {\n                iruns.add(iPos + 1, newRun);\n            }\n            // Runs itself is easy to update\n            if ((pos + 1) >= runs.size()) {\n                runs.add(newRun);\n            } else {\n                runs.add(pos + 1, newRun);\n            }\n            newCursor.dispose();\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewAnchor",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewAnchor" ],
    "fullMethods" : [ "public XWPFFieldRun insertNewAnchor(int pos, String anchorName) {\n    if ((pos >= 0) && (pos <= paragraph.getRuns().size())) {\n        XWPFFieldRun insertNewField = insertNewField(pos);\n        insertNewField.setFieldInstruction((\"HYPERLINK \\\\l \\\"\" + anchorName) + \"\\\"\");\n        return insertNewField;\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getRuns",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph" ],
    "fullMethods" : [ "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.EnhancedXWPFChart.setExternalId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTChartSpace.isSetExternalData",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.EnhancedXWPFChart.setExternalId" ],
    "fullMethods" : [ "@Override\npublic void setExternalId(String id) {\n    CTChartSpace ctChartSpace = getCTChartSpace();\n    CTExternalData externalData = (ctChartSpace.isSetExternalData()) ? ctChartSpace.getExternalData() : ctChartSpace.addNewExternalData();\n    externalData.setId(id);\n    if (!externalData.isSetAutoUpdate()) {\n        externalData.addNewAutoUpdate().setVal(true);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.setWidth",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTbl.getTblPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.setWidth", "com.deepoove.poi.util.TableTools.ensureTblW" ],
    "fullMethods" : [ "/**\n * set table width\n *\n * @param table\n * @param width\n * @param colWidths\n */\npublic static void setWidth(XWPFTable table, String width, int[] colWidths) {\n    ensureTblW(table);\n    table.setWidth(width);\n    if (null == colWidths) {\n        int columnSize = TableTools.obtainColumnSize(table);\n        if (table.getWidthType() == TableWidthType.DXA) {\n            colWidths = UnitUtils.average(Integer.valueOf(width), columnSize);\n        } else if (table.getWidthType() == TableWidthType.PCT) {\n            int sum = 0;\n            colWidths = new int[columnSize];\n            for (int i = 0; i < (columnSize - 1); i++) {\n                colWidths[i] = 100 / columnSize;\n                sum += colWidths[i];\n            }\n            colWidths[columnSize - 1] = 100 - sum;\n        }\n    }\n    if (null != colWidths) {\n        BigInteger[] gridCol = null;\n        String[] cellWidth = null;\n        if (table.getWidthType() == TableWidthType.DXA) {\n            cellWidth = Arrays.stream(colWidths).mapToObj(String::valueOf).toArray(String[]::new);\n            gridCol = Arrays.stream(colWidths).mapToObj(BigInteger::valueOf).toArray(BigInteger[]::new);\n        } else if (table.getWidthType() == TableWidthType.PCT) {\n            cellWidth = Arrays.stream(colWidths).mapToObj(w -> w + \"%\").toArray(String[]::new);\n            BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(table.getBody());\n            int pageWidth = bodyContainer.elementPageWidth(table);\n            int tableWidth = (pageWidth * Integer.valueOf(width.substring(0, width.length() - 1))) / 100;\n            gridCol = Arrays.stream(colWidths).mapToObj(w -> BigInteger.valueOf((w * tableWidth) / 100)).toArray(BigInteger[]::new);\n        }\n        CTTblGrid tblGrid = TableTools.getTblGrid(table);\n        CTTblLayoutType tblLayout = TableTools.getTblLayout(table);\n        tblLayout.setType(STTblLayoutType.FIXED);\n        for (int index = 0; index < colWidths.length; index++) {\n            if (null != gridCol) {\n                CTTblGridCol addNewGridCol = tblGrid.addNewGridCol();\n                addNewGridCol.setW(gridCol[index]);\n            }\n            List<XWPFTableRow> rows = table.getRows();\n            for (XWPFTableRow row : rows) {\n                row.getCell(index).setWidth(cellWidth[index]);\n            }\n        }\n    }\n}", "private static void ensureTblW(XWPFTable table) {\n    CTTbl ctTbl = table.getCTTbl();\n    CTTblPr tblPr = (ctTbl.getTblPr() != null) ? ctTbl.getTblPr() : ctTbl.addNewTblPr();\n    if (!tblPr.isSetTblW())\n        tblPr.addNewTblW();\n\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.getTblLayout",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTbl.getTblPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.getTblLayout", "com.deepoove.poi.util.TableTools.getTblPr" ],
    "fullMethods" : [ "public static CTTblLayoutType getTblLayout(XWPFTable table) {\n    CTTblPr tblPr = getTblPr(table);\n    return tblPr.isSetTblLayout() ? tblPr.getTblLayout() : tblPr.addNewTblLayout();\n}", "private static CTTblPr getTblPr(XWPFTable table) {\n    CTTblPr tblPr = table.getCTTbl().getTblPr();\n    if (null == tblPr) {\n        tblPr = table.getCTTbl().addNewTblPr();\n    }\n    return tblPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.widthTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTbl.getTblPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.widthTable", "com.deepoove.poi.util.TableTools.getTblPr" ],
    "fullMethods" : [ "@Deprecated\npublic static void widthTable(XWPFTable table, float widthCM, int cols) {\n    int width = UnitUtils.cm2Twips(widthCM);\n    CTTblPr tblPr = getTblPr(table);\n    CTTblWidth tblW = (tblPr.isSetTblW()) ? tblPr.getTblW() : tblPr.addNewTblW();\n    tblW.setType(0 == width ? STTblWidth.AUTO : STTblWidth.DXA);\n    tblW.setW(BigInteger.valueOf(width));\n    if (0 != width) {\n        CTTblGrid tblGrid = getTblGrid(table);\n        for (int j = 0; j < cols; j++) {\n            CTTblGridCol addNewGridCol = tblGrid.addNewGridCol();\n            addNewGridCol.setW(BigInteger.valueOf(width / cols));\n        }\n    }\n}", "private static CTTblPr getTblPr(XWPFTable table) {\n    CTTblPr tblPr = table.getCTTbl().getTblPr();\n    if (null == tblPr) {\n        tblPr = table.getCTTbl().addNewTblPr();\n    }\n    return tblPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.widthTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTbl.getTblPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.widthTable", "com.deepoove.poi.util.TableTools.getTblPr" ],
    "fullMethods" : [ "@Deprecated\npublic static void widthTable(XWPFTable table, float[] colWidths) {\n    float widthCM = 0;\n    for (float w : colWidths) {\n        widthCM += w;\n    }\n    int width = UnitUtils.cm2Twips(widthCM);\n    CTTblPr tblPr = getTblPr(table);\n    CTTblWidth tblW = (tblPr.isSetTblW()) ? tblPr.getTblW() : tblPr.addNewTblW();\n    tblW.setType(0 == width ? STTblWidth.AUTO : STTblWidth.DXA);\n    tblW.setW(BigInteger.valueOf(width));\n    if (0 != width) {\n        CTTblGrid tblGrid = getTblGrid(table);\n        for (float w : colWidths) {\n            CTTblGridCol addNewGridCol = tblGrid.addNewGridCol();\n            addNewGridCol.setW(BigInteger.valueOf(UnitUtils.cm2Twips(w)));\n        }\n    }\n}", "private static CTTblPr getTblPr(XWPFTable table) {\n    CTTblPr tblPr = table.getCTTbl().getTblPr();\n    if (null == tblPr) {\n        tblPr = table.getCTTbl().addNewTblPr();\n    }\n    return tblPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTbl.getTblPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable", "com.deepoove.poi.util.TableTools.getTblPr" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}", "private static CTTblPr getTblPr(XWPFTable table) {\n    CTTblPr tblPr = table.getCTTbl().getTblPr();\n    if (null == tblPr) {\n        tblPr = table.getCTTbl().addNewTblPr();\n    }\n    return tblPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTbl.getTblPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTable" ],
    "fullMethods" : [ "/**\n * set table style\n *\n * @param table\n * @param tableStyle\n */\npublic static void styleTable(XWPFTable table, TableStyle tableStyle) {\n    if ((null == table) || (null == tableStyle))\n        return;\n\n    TableTools.setWidth(table, tableStyle.getWidth(), tableStyle.getColWidths());\n    TableTools.setBorder(table::setLeftBorder, tableStyle.getLeftBorder());\n    TableTools.setBorder(table::setRightBorder, tableStyle.getRightBorder());\n    TableTools.setBorder(table::setTopBorder, tableStyle.getTopBorder());\n    TableTools.setBorder(table::setBottomBorder, tableStyle.getBottomBorder());\n    TableTools.setBorder(table::setInsideHBorder, tableStyle.getInsideHBorder());\n    TableTools.setBorder(table::setInsideVBorder, tableStyle.getInsideVBorder());\n    if (null != tableStyle.getAlign()) {\n        table.setTableAlignment(tableStyle.getAlign());\n    }\n    table.setCellMargins(tableStyle.getTopCellMargin(), tableStyle.getLeftCellMargin(), tableStyle.getBottomCellMargin(), tableStyle.getRightCellMargin());\n    if (null != tableStyle.getIndentation()) {\n        CTTbl ctTbl = table.getCTTbl();\n        CTTblPr tPr = (ctTbl.getTblPr() != null) ? ctTbl.getTblPr() : ctTbl.addNewTblPr();\n        CTTblWidth tw = (tPr.isSetTblInd()) ? tPr.getTblInd() : tPr.addNewTblInd();\n        tw.setType(STTblWidth.DXA);\n        tw.setW(BigInteger.valueOf(UnitUtils.cm2Twips(tableStyle.getIndentation())));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTColor.unsetThemeColor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun" ],
    "fullMethods" : [ "/**\n * set run style by style\n *\n * @param run\n * @param style\n */\npublic static void styleRun(XWPFRun run, Style style) {\n    if ((null == run) || (null == style))\n        return;\n\n    CTRPr pr = getRunProperties(run);\n    String color = style.getColor();\n    if (StringUtils.isNotBlank(color)) {\n        // run.setColor(color);\n        // issue 326\n        CTColor ctColor = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        ctColor.setVal(color);\n        if (ctColor.isSetThemeColor())\n            ctColor.unsetThemeColor();\n\n    }\n    double fontSize = style.getFontSize();\n    if ((0 != fontSize) && ((-1) != fontSize)) {\n        run.setFontSize(fontSize);\n    }\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        run.setFontFamily(fontFamily, FontCharRange.eastAsia);\n        run.setFontFamily(fontFamily, FontCharRange.ascii);\n        run.setFontFamily(fontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(fontFamily, FontCharRange.cs);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        run.setFontFamily(westernFontFamily, FontCharRange.ascii);\n        run.setFontFamily(westernFontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(westernFontFamily, FontCharRange.cs);\n    }\n    XWPFHighlightColor highlightColor = style.getHighlightColor();\n    if (null != highlightColor) {\n        CTHighlight highlight = (pr.sizeOfHighlightArray() > 0) ? pr.getHighlightArray(0) : pr.addNewHighlight();\n        highlight.setVal(STHighlightColor.Enum.forInt(highlightColor.getValue()));\n    }\n    Boolean bold = style.isBold();\n    if (null != bold)\n        run.setBold(bold);\n\n    Boolean italic = style.isItalic();\n    if (null != italic)\n        run.setItalic(italic);\n\n    Boolean strike = style.isStrike();\n    if (null != strike)\n        run.setStrikeThrough(strike);\n\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        run.setUnderline(underlinePatern);\n        if (null != style.getUnderlineColor()) {\n            run.setUnderlineColor(style.getUnderlineColor());\n        }\n    }\n    int point = style.getCharacterSpacing();\n    // in twentieths of a point\n    if ((0 != point) && ((-1) != point))\n        run.setCharacterSpacing(UnitUtils.point2Twips(point));\n\n    String vertAlign = style.getVertAlign();\n    if (StringUtils.isNotBlank(vertAlign)) {\n        run.setVerticalAlignment(vertAlign);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xssf.usermodel.XSSFSheet.createTable",
    "thirdPartyPackage" : "org.apache.poi.xssf.usermodel",
    "path" : [ "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.updateCTTable", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.getSheetTable" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartMultiSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    List<XDDFChartData> chartSeries = chart.getChartSeries();\n    validate(chartSeries, data);\n    int totalSeriesCount = ensureSeriesCount(chart, chartSeries);\n    int valueCol = 1;\n    List<SeriesRenderData> usedSeriesDatas = new ArrayList<>();\n    for (XDDFChartData chartData : chartSeries) {\n        int orignSize = chartData.getSeriesCount();\n        List<SeriesRenderData> currentSeriesData = null;\n        if (chartSeries.size() <= 1) {\n            // ignore combo type\n            currentSeriesData = data.getSeriesDatas();\n        } else {\n            currentSeriesData = obtainSeriesData(chartData.getClass(), data.getSeriesDatas());\n        }\n        usedSeriesDatas.addAll(currentSeriesData);\n        int currentSeriesSize = currentSeriesData.size();\n        XDDFDataSource<?> categoriesData = null;\n        if (chartData instanceof XDDFScatterChartData) {\n            categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n        } else {\n            categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n        }\n        for (int i = 0; i < currentSeriesSize; i++) {\n            XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, currentSeriesData.get(i).getValues(), valueCol);\n            XDDFChartData.Series currentSeries = null;\n            if (i < orignSize) {\n                currentSeries = chartData.getSeries(i);\n                valuesData.setFormatCode(currentSeries.getValuesData().getFormatCode());\n                currentSeries.replaceData(categoriesData, valuesData);\n            } else {\n                // add series, should copy series with style\n                currentSeries = chartData.addSeries(categoriesData, valuesData);\n                processNewSeries(chartData, currentSeries);\n            }\n            String name = currentSeriesData.get(i).getName();\n            currentSeries.setTitle(name, chart.setSheetTitle(name, valueCol));\n            valueCol++;\n        }\n        // clear extra series\n        removeExtraSeries(chartData, orignSize, currentSeriesSize);\n    }\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    updateCTTable(sheet, usedSeriesDatas);\n    removeExtraSheetCell(sheet, data.getCategories().length, totalSeriesCount, usedSeriesDatas.size());\n    for (XDDFChartData chartData : chartSeries) {\n        plot(chart, chartData);\n    }\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "protected void updateCTTable(XSSFSheet sheet, List<SeriesRenderData> seriesDatas) {\n    final int seriesSize = seriesDatas.size();\n    final int numOfPoints = seriesDatas.get(0).getValues().length;\n    CTTable ctTable = getSheetTable(sheet);\n    String prefix = (seriesSize >= 26) ? String.valueOf(((char) ('A' + ((seriesSize / 26) - 1)))) : \"\";\n    char c = ((char) ('A' + (seriesSize % 26)));\n    String ref = ((\"A1:\" + prefix) + c) + (numOfPoints + 1);\n    ctTable.setRef(ref);\n    CTTableColumns tableColumns = ctTable.getTableColumns();\n    tableColumns.setCount(seriesSize + 1);\n    int size = tableColumns.sizeOfTableColumnArray();\n    for (int i = size - 1; i >= 0; i--) {\n        tableColumns.removeTableColumn(i);\n    }\n    CTTableColumn column = tableColumns.addNewTableColumn();\n    // category\n    column.setId(1);\n    column.setName(sheet.getRow(0).getCell(0).getStringCellValue());\n    // series\n    for (int i = 0; i < seriesSize; i++) {\n        column = tableColumns.addNewTableColumn();\n        column.setId((1 + i) + 1);\n        column.setName(seriesDatas.get(i).getName());\n    }\n}", "protected CTTable getSheetTable(XSSFSheet sheet) {\n    if (sheet.getTables().size() == 0) {\n        XSSFTable newTable = sheet.createTable(null);\n        newTable.getCTTable().addNewTableColumns();\n        sheet.getTables().add(newTable);\n    }\n    return sheet.getTables().get(0).getCTTable();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xssf.usermodel.XSSFSheet.createTable",
    "thirdPartyPackage" : "org.apache.poi.xssf.usermodel",
    "path" : [ "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.updateCTTable", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.getSheetTable" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartSingleSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    XDDFChartData pie = ChartUtils.getChartSeries(chart).get(0);\n    SeriesRenderData seriesDatas = data.getSeriesData();\n    XDDFDataSource<?> categoriesData = null;\n    if (pie instanceof XDDFScatterChartData) {\n        categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n    } else {\n        categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n    }\n    XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, seriesDatas.getValues(), 1);\n    XDDFChartData.Series currentSeries = pie.getSeries(0);\n    currentSeries.replaceData(categoriesData, valuesData);\n    currentSeries.setTitle(seriesDatas.getName(), chart.setSheetTitle(seriesDatas.getName(), 1));\n    updateCTTable(chart.getWorkbook().getSheetAt(0), Arrays.asList(seriesDatas));\n    plot(chart, pie);\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "protected void updateCTTable(XSSFSheet sheet, List<SeriesRenderData> seriesDatas) {\n    final int seriesSize = seriesDatas.size();\n    final int numOfPoints = seriesDatas.get(0).getValues().length;\n    CTTable ctTable = getSheetTable(sheet);\n    String prefix = (seriesSize >= 26) ? String.valueOf(((char) ('A' + ((seriesSize / 26) - 1)))) : \"\";\n    char c = ((char) ('A' + (seriesSize % 26)));\n    String ref = ((\"A1:\" + prefix) + c) + (numOfPoints + 1);\n    ctTable.setRef(ref);\n    CTTableColumns tableColumns = ctTable.getTableColumns();\n    tableColumns.setCount(seriesSize + 1);\n    int size = tableColumns.sizeOfTableColumnArray();\n    for (int i = size - 1; i >= 0; i--) {\n        tableColumns.removeTableColumn(i);\n    }\n    CTTableColumn column = tableColumns.addNewTableColumn();\n    // category\n    column.setId(1);\n    column.setName(sheet.getRow(0).getCell(0).getStringCellValue());\n    // series\n    for (int i = 0; i < seriesSize; i++) {\n        column = tableColumns.addNewTableColumn();\n        column.setId((1 + i) + 1);\n        column.setName(seriesDatas.get(i).getName());\n    }\n}", "protected CTTable getSheetTable(XSSFSheet sheet) {\n    if (sheet.getTables().size() == 0) {\n        XSSFTable newTable = sheet.createTable(null);\n        newTable.getCTTable().addNewTableColumns();\n        sheet.getTables().add(newTable);\n    }\n    return sheet.getTables().get(0).getCTTable();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFComment.createParagraph",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment" ],
    "fullMethods" : [ "public static void renderComment(XWPFRun run, CommentRenderData data) throws Exception {\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper parentContext = new XWPFParagraphWrapper(paragraph);\n    BigInteger cId = BigInteger.ZERO;\n    CommentContent commentContent = data.getCommentContent();\n    if (null != commentContent) {\n        XWPFComments comments = ((NiceXWPFDocument) (paragraph.getDocument())).createComments();\n        XWPFComment newComment = comments.createComment(NextIDUtils.getCommentMaxId(comments).add(BigInteger.ONE));\n        newComment.setAuthor(commentContent.getAuthor());\n        newComment.setDate(commentContent.getDate());\n        newComment.setInitials(commentContent.getInitials());\n        renderDocument(newComment.createParagraph().createRun(), commentContent.getContent());\n        cId = newComment.getCtComment().getId();\n        parentContext.insertNewCommentRangeStart(run, cId);\n    }\n    renderParagraph(run, Paragraphs.of().addList(data.getContents()).create());\n    if (null != commentContent) {\n        parentContext.insertNewCommentRangeEnd(run, cId);\n        XWPFRun newRun = parentContext.insertNewRun(ParagraphUtils.getRunPos(run));\n        newRun.getCTR().addNewCommentReference().setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.<init>",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTBr.setType",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.<init>", "com.deepoove.poi.resolver.RunningRunBody.refactorBody" ],
    "fullMethods" : [ "public RunningRunBody(RunBodyContext context, Pattern pattern) {\n    this.runBodyContext = context;\n    this.runs = context.getRuns();\n    if ((null == runs) || runs.isEmpty())\n        return;\n\n    Matcher matcher = pattern.matcher(getText(context));\n    if (matcher.find()) {\n        refactorBody();\n    }\n    buildRunEdge(pattern);\n}", "private void refactorBody() {\n    for (int i = runs.size() - 1; i >= 0; i--) {\n        XWPFRun xwpfRun = runs.get(i);\n        CTR ctr = xwpfRun.getCTR();\n        CTRImpl ctrimpl = ((CTRImpl) (ctr));\n        int sizeOfBrArray = ctr.sizeOfBrArray();\n        int sizeOfCrArray = ctr.sizeOfCrArray();\n        int sizeOfTabArray = ctr.sizeOfTabArray();\n        if (((sizeOfBrArray + sizeOfCrArray) + sizeOfTabArray) > 0) {\n            synchronized(ctrimpl.monitor()) {\n                // ctrimpl.check_orphaned();\n                List<? extends XmlObject> localArrayList = new ArrayList<XmlObject>();\n                ctrimpl.get_store().find_all_element_users(qname, localArrayList);\n                int size = localArrayList.size();\n                for (int j = size - 1; j >= 0; j--) {\n                    Object obj = localArrayList.get(j);\n                    if (obj instanceof CTEmpty) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        String tagName = ((CTEmpty) (obj)).getDomNode().getNodeName();\n                        if (\"w:br\".equals(tagName) || \"br\".equals(tagName)) {\n                            insertNewRun.addBreak();\n                        }\n                        if (\"w:cr\".equals(tagName) || \"cr\".equals(tagName)) {\n                            insertNewRun.addCarriageReturn();\n                        }\n                        if (\"w:tab\".equals(tagName) || \"tab\".equals(tagName)) {\n                            insertNewRun.addTab();\n                        }\n                    } else if (obj instanceof CTBr) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        CTBr addNewBr = insertNewRun.getCTR().addNewBr();\n                        if (null != ((CTBr) (obj)).getType())\n                            addNewBr.setType(((CTBr) (obj)).getType());\n\n                        if (null != ((CTBr) (obj)).getClear())\n                            addNewBr.setClear(((CTBr) (obj)).getClear());\n\n                    } else if (obj instanceof CTText) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        StyleUtils.styleRun(insertNewRun, xwpfRun);\n                        insertNewRun.setText(((CTText) (obj)).getStringValue());\n                    }\n                }\n                runBodyContext.removeRun(i);\n            }\n        }\n    }\n    this.runs = runBodyContext.getRuns();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getRight",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements", "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph", "com.deepoove.poi.resolver.RunningRunBody.refactorRun" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveBodyElements(List<IBodyElement> bodyElements) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (null == bodyElements)\n        return metaTemplates;\n\n    // current iterable templates state\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    for (IBodyElement element : bodyElements) {\n        if (element == null)\n            continue;\n\n        if (element.getElementType() == BodyElementType.PARAGRAPH) {\n            resolveParagraph(((XWPFParagraph) (element)), metaTemplates, stack);\n        } else if (element.getElementType() == BodyElementType.TABLE) {\n            XWPFTable table = ((XWPFTable) (element));\n            List<XWPFTableRow> rows = table.getRows();\n            if (null == rows)\n                continue;\n\n            for (XWPFTableRow row : rows) {\n                resolveTableRow(row, metaTemplates, stack);\n            }\n        } else if ((element.getElementType() == BodyElementType.CONTENTCONTROL) && (element instanceof XWPFStructuredDocumentTag)) {\n            XWPFStructuredDocumentTag sdt = ((XWPFStructuredDocumentTag) (element));\n            addNewMeta(metaTemplates, stack, resolveSDTElements(sdt.getContent()));\n        }\n    }\n    checkStack(stack);\n    return metaTemplates;\n}", "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}", "public List<XWPFRun> refactorRun() {\n    if (pairs.isEmpty())\n        return null;\n\n    List<XWPFRun> templateRuns = new ArrayList<XWPFRun>();\n    int size = pairs.size();\n    Pair<RunEdge, RunEdge> runEdgePair;\n    for (int n = size - 1; n >= 0; n--) {\n        runEdgePair = pairs.get(n);\n        RunEdge startEdge = runEdgePair.getLeft();\n        RunEdge endEdge = runEdgePair.getRight();\n        int startRunPos = startEdge.getRunPos();\n        int endRunPos = endEdge.getRunPos();\n        int startOffset = startEdge.getRunEdge();\n        int endOffset = endEdge.getRunEdge();\n        String startText = runs.get(startRunPos).text();\n        String endText = runs.get(endRunPos).text();\n        if ((endOffset + 1) >= endText.length()) {\n            // delete the redundant end Run directly\n            if (startRunPos != endRunPos)\n                runBodyContext.removeRun(endRunPos);\n\n        } else {\n            // split end run, set extra in a run\n            String extra = endText.substring(endOffset + 1, endText.length());\n            if (startRunPos == endRunPos) {\n                // create run and set extra content\n                XWPFRun extraRun = runBodyContext.insertNewRunAfter(endRunPos);\n                StyleUtils.styleRun(extraRun, runs.get(endRunPos));\n                buildExtra(extra, extraRun);\n            } else {\n                // Set the extra content to the redundant end run\n                XWPFRun extraRun = runs.get(endRunPos);\n                buildExtra(extra, extraRun);\n            }\n        }\n        // remove extra run\n        for (int m = endRunPos - 1; m > startRunPos; m--) {\n            runBodyContext.removeRun(m);\n        }\n        if (startOffset <= 0) {\n            // set the start Run directly\n            XWPFRun templateRun = runs.get(startRunPos);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos));\n        } else {\n            // split start run, set extra in a run\n            String extra = startText.substring(0, startOffset);\n            XWPFRun extraRun = runs.get(startRunPos);\n            buildExtra(extra, extraRun);\n            XWPFRun templateRun = runBodyContext.insertNewRunAfter(startRunPos);\n            StyleUtils.styleRun(templateRun, extraRun);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos + 1));\n        }\n    }\n    return templateRuns;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.config.Configure.toString",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getRight",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.config.Configure.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Configure Info\").append(\":\\n\");\n    sb.append(\"  Basic gramer: \").append(gramerPrefix).append(gramerSuffix).append(\"\\n\");\n    sb.append(\"  If and foreach gramer: \").append(gramerPrefix).append(iterable.getLeft()).append(gramerSuffix);\n    sb.append(gramerPrefix).append(iterable.getRight()).append(gramerSuffix).append(\"\\n\");\n    sb.append(\"  Regex:\").append(grammerRegex).append(\"\\n\");\n    sb.append(\"  Valid Error Handler: \").append(handler.getClass().getSimpleName()).append(\"\\n\");\n    sb.append(\"  Default Plugin: \").append(\"\\n\");\n    DEFAULT_POLICYS.forEach((chara, policy) -> {\n        sb.append(\"    \").append(gramerPrefix).append(chara.charValue()).append(gramerSuffix);\n        sb.append(\"->\").append(policy.getClass().getSimpleName()).append(\"\\n\");\n    });\n    sb.append(\"  Bind Plugin: \").append(\"\\n\");\n    CUSTOM_POLICYS.forEach((str, policy) -> {\n        sb.append(\"    \").append(gramerPrefix).append(str).append(gramerSuffix);\n        sb.append(\"->\").append(policy.getClass().getSimpleName()).append(\"\\n\");\n    });\n    sb.append(\"  Chart Plugin: \").append(\"\\n\");\n    DEFAULT_CHART_POLICYS.forEach((type, policy) -> {\n        sb.append(\"    \").append(type);\n        sb.append(\"->\").append(policy.getClass().getSimpleName()).append(\"\\n\");\n    });\n    sb.append(\"  Template Plugin: \").append(\"\\n\");\n    DEFAULT_TEMPLATE_POLICYS.forEach((clazz, policy) -> {\n        sb.append(\"    \").append(clazz.getSimpleName());\n        sb.append(\"->\").append(policy.getClass().getSimpleName()).append(\"\\n\");\n    });\n    sb.append(\"  SpELFunction: \").append(\"\\n\");\n    spELFunction.forEach((str, method) -> {\n        sb.append(\"    \").append(str);\n        sb.append(\"->\").append(method.toString()).append(\"\\n\");\n    });\n    return sb.toString();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.config.ConfigureBuilder.buidIterableLeft",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getRight",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.config.ConfigureBuilder.buidIterableLeft" ],
    "fullMethods" : [ "public ConfigureBuilder buidIterableLeft(char c) {\n    config.iterable = Pair.of(c, config.iterable.getRight());\n    return this;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.loggerInfo",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getRight",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.loggerInfo" ],
    "fullMethods" : [ "public void loggerInfo() {\n    for (Pair<RunEdge, RunEdge> runEdges : pairs) {\n        LOG.debug(\"[Start]:\" + runEdges.getLeft().toString());\n        LOG.debug(\"[End]:\" + runEdges.getRight().toString());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getRight",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveXWPFRuns(List<XWPFRun> runs) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (runs == null)\n        return metaTemplates;\n\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    resolveXWPFRuns(runs, metaTemplates, stack);\n    checkStack(stack);\n    return metaTemplates;\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.<init>",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getRight",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.<init>", "com.deepoove.poi.resolver.RunningRunBody.buildRunEdge" ],
    "fullMethods" : [ "public RunningRunBody(RunBodyContext context, Pattern pattern) {\n    this.runBodyContext = context;\n    this.runs = context.getRuns();\n    if ((null == runs) || runs.isEmpty())\n        return;\n\n    Matcher matcher = pattern.matcher(getText(context));\n    if (matcher.find()) {\n        refactorBody();\n    }\n    buildRunEdge(pattern);\n}", "private void buildRunEdge(Pattern pattern) {\n    // find all templates\n    Matcher matcher = pattern.matcher(getText(runBodyContext));\n    while (matcher.find()) {\n        pairs.add(ImmutablePair.of(new RunEdge(matcher.start(), matcher.group()), new RunEdge(matcher.end(), matcher.group())));\n    } \n    if (pairs.isEmpty())\n        return;\n\n    boolean endflag = false;\n    int size = runs.size();\n    int cursor = 0;\n    int pos = 0;\n    // find the run where all templates are located\n    Pair<RunEdge, RunEdge> pair = pairs.get(pos);\n    RunEdge startEdge = pair.getLeft();\n    RunEdge endEdge = pair.getRight();\n    int start = startEdge.getAllEdge();\n    int end = endEdge.getAllEdge();\n    for (int i = 0; i < size; i++) {\n        XWPFRun run = runs.get(i);\n        String text = run.text();\n        // empty run\n        if (null == text) {\n            LOG.warn(\"found the empty text run,may be produce bug:\" + run);\n            cursor += run.toString().length();\n            continue;\n        }\n        LOG.debug(text);\n        // The starting position is not enough, the cursor points to the next run\n        if ((text.length() + cursor) < start) {\n            cursor += text.length();\n            continue;\n        }\n        // index text\n        for (int offset = 0; offset < text.length(); offset++) {\n            if ((cursor + offset) == start) {\n                startEdge.setRunPos(i);\n                startEdge.setRunEdge(offset);\n                startEdge.setText(text);\n            }\n            if ((cursor + offset) == (end - 1)) {\n                endEdge.setRunPos(i);\n                endEdge.setRunEdge(offset);\n                endEdge.setText(text);\n                if (pos == (pairs.size() - 1)) {\n                    endflag = true;\n                    break;\n                }\n                // Continue to calculate the next template\n                pair = pairs.get(++pos);\n                startEdge = pair.getLeft();\n                endEdge = pair.getRight();\n                start = startEdge.getAllEdge();\n                end = endEdge.getAllEdge();\n            }\n        }\n        if (endflag)\n            break;\n\n        // the cursor points to the next run\n        cursor += text.length();\n    }\n    loggerInfo();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getRight",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph", "com.deepoove.poi.resolver.RunningRunBody.refactorRun" ],
    "fullMethods" : [ "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}", "public List<XWPFRun> refactorRun() {\n    if (pairs.isEmpty())\n        return null;\n\n    List<XWPFRun> templateRuns = new ArrayList<XWPFRun>();\n    int size = pairs.size();\n    Pair<RunEdge, RunEdge> runEdgePair;\n    for (int n = size - 1; n >= 0; n--) {\n        runEdgePair = pairs.get(n);\n        RunEdge startEdge = runEdgePair.getLeft();\n        RunEdge endEdge = runEdgePair.getRight();\n        int startRunPos = startEdge.getRunPos();\n        int endRunPos = endEdge.getRunPos();\n        int startOffset = startEdge.getRunEdge();\n        int endOffset = endEdge.getRunEdge();\n        String startText = runs.get(startRunPos).text();\n        String endText = runs.get(endRunPos).text();\n        if ((endOffset + 1) >= endText.length()) {\n            // delete the redundant end Run directly\n            if (startRunPos != endRunPos)\n                runBodyContext.removeRun(endRunPos);\n\n        } else {\n            // split end run, set extra in a run\n            String extra = endText.substring(endOffset + 1, endText.length());\n            if (startRunPos == endRunPos) {\n                // create run and set extra content\n                XWPFRun extraRun = runBodyContext.insertNewRunAfter(endRunPos);\n                StyleUtils.styleRun(extraRun, runs.get(endRunPos));\n                buildExtra(extra, extraRun);\n            } else {\n                // Set the extra content to the redundant end run\n                XWPFRun extraRun = runs.get(endRunPos);\n                buildExtra(extra, extraRun);\n            }\n        }\n        // remove extra run\n        for (int m = endRunPos - 1; m > startRunPos; m--) {\n            runBodyContext.removeRun(m);\n        }\n        if (startOffset <= 0) {\n            // set the start Run directly\n            XWPFRun templateRun = runs.get(startRunPos);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos));\n        } else {\n            // split start run, set extra in a run\n            String extra = startText.substring(0, startOffset);\n            XWPFRun extraRun = runs.get(startRunPos);\n            buildExtra(extra, extraRun);\n            XWPFRun templateRun = runBodyContext.insertNewRunAfter(startRunPos);\n            StyleUtils.styleRun(templateRun, extraRun);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos + 1));\n        }\n    }\n    return templateRuns;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.refactorRun",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getRight",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.refactorRun" ],
    "fullMethods" : [ "public List<XWPFRun> refactorRun() {\n    if (pairs.isEmpty())\n        return null;\n\n    List<XWPFRun> templateRuns = new ArrayList<XWPFRun>();\n    int size = pairs.size();\n    Pair<RunEdge, RunEdge> runEdgePair;\n    for (int n = size - 1; n >= 0; n--) {\n        runEdgePair = pairs.get(n);\n        RunEdge startEdge = runEdgePair.getLeft();\n        RunEdge endEdge = runEdgePair.getRight();\n        int startRunPos = startEdge.getRunPos();\n        int endRunPos = endEdge.getRunPos();\n        int startOffset = startEdge.getRunEdge();\n        int endOffset = endEdge.getRunEdge();\n        String startText = runs.get(startRunPos).text();\n        String endText = runs.get(endRunPos).text();\n        if ((endOffset + 1) >= endText.length()) {\n            // delete the redundant end Run directly\n            if (startRunPos != endRunPos)\n                runBodyContext.removeRun(endRunPos);\n\n        } else {\n            // split end run, set extra in a run\n            String extra = endText.substring(endOffset + 1, endText.length());\n            if (startRunPos == endRunPos) {\n                // create run and set extra content\n                XWPFRun extraRun = runBodyContext.insertNewRunAfter(endRunPos);\n                StyleUtils.styleRun(extraRun, runs.get(endRunPos));\n                buildExtra(extra, extraRun);\n            } else {\n                // Set the extra content to the redundant end run\n                XWPFRun extraRun = runs.get(endRunPos);\n                buildExtra(extra, extraRun);\n            }\n        }\n        // remove extra run\n        for (int m = endRunPos - 1; m > startRunPos; m--) {\n            runBodyContext.removeRun(m);\n        }\n        if (startOffset <= 0) {\n            // set the start Run directly\n            XWPFRun templateRun = runs.get(startRunPos);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos));\n        } else {\n            // split start run, set extra in a run\n            String extra = startText.substring(0, startOffset);\n            XWPFRun extraRun = runs.get(startRunPos);\n            buildExtra(extra, extraRun);\n            XWPFRun templateRun = runBodyContext.insertNewRunAfter(startRunPos);\n            StyleUtils.styleRun(templateRun, extraRun);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos + 1));\n        }\n    }\n    return templateRuns;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.init",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFDocument.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.init" ],
    "fullMethods" : [ "{\n    com.deepoove.poi.xwpf.NiceXWPFDocument$1 this;\n    java.lang.Object $stack1;\n    org.apache.poi.ooxml.POIXMLDocumentPart #l1;\n    org.apache.poi.xwpf.usermodel.XWPFDocument #l0;\n\n\n    this := @this: com.deepoove.poi.xwpf.NiceXWPFDocument$1;\n    $stack1 = new org.apache.poi.xwpf.usermodel.XWPFDocument;\n    #l0 = (org.apache.poi.xwpf.usermodel.XWPFDocument) $stack1;\n    specialinvoke #l0.<org.apache.poi.xwpf.usermodel.XWPFDocument: void <init>()>();\n    #l1 = (org.apache.poi.ooxml.POIXMLDocumentPart) $stack1;\n\n    return #l1;\n}\n" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFDocument.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.<init>" ],
    "fullMethods" : [ "1() {\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCtRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render", "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.removeCell" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        for (int i = rowSize - 1; i >= 0; i--) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            String text = row.getCell(actualInsertPosition).getText();\n            if (\"_delete_\".equals(text)) {\n                table.removeRow(i);\n            } else {\n                removeCell(row, actualInsertPosition);\n            }\n        }\n    } catch (Exception e) {\n    }\n}", "@SuppressWarnings(\"unchecked\")\nprivate void removeCell(XWPFTableRow row, int actualInsertPosition) {\n    List<XWPFTableCell> cells = ((List<XWPFTableCell>) (ReflectionUtils.getValue(\"tableCells\", row)));\n    cells.remove(actualInsertPosition);\n    row.getCtRow().removeTc(actualInsertPosition);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTableRowWrapper.getTableICells",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCtRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTableRowWrapper.getTableICells" ],
    "fullMethods" : [ "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic List<ICell> getTableICells() {\n    boolean haveSdt = false;\n    List<ICell> cells = new ArrayList<>();\n    XmlCursor cursor = row.getCtRow().newCursor();\n    try {\n        cursor.selectPath(\"./*\");\n        while (cursor.toNextSelection()) {\n            XmlObject o = cursor.getObject();\n            if (o instanceof CTTc) {\n                cells.add(new XWPFTableCell(((CTTc) (o)), row, row.getTable().getBody()));\n            } else if (o instanceof CTSdtCell) {\n                haveSdt = true;\n                cells.add(new XWPFStructuredDocumentTag(((CTSdtCell) (o)), row, row.getTable().getBody()));\n            }\n        } \n    } finally {\n        cursor.dispose();\n    }\n    return haveSdt ? cells : ((List) (row.getTableCells()));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCtRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render", "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.insertCell" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}", "@SuppressWarnings(\"unchecked\")\nprivate XWPFTableCell insertCell(XWPFTableRow tableRow, int actualInsertPosition) {\n    CTRow row = tableRow.getCtRow();\n    CTTc newTc = row.insertNewTc(actualInsertPosition);\n    XWPFTableCell cell = new XWPFTableCell(newTc, tableRow, tableRow.getTable().getBody());\n    List<XWPFTableCell> cells = ((List<XWPFTableCell>) (ReflectionUtils.getValue(\"tableCells\", tableRow)));\n    cells.add(actualInsertPosition, cell);\n    return cell;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.mergeCellsHorizonal",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCtRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.mergeCellsHorizonal" ],
    "fullMethods" : [ "/**\n * merge several columns of cells in the same row\n *\n * @param table\n * \t\ttable\n * @param row\n * \t\tindex of the row\n * @param fromCol\n * \t\tfrom column to be merged\n * @param toCol\n * \t\tto column to be merged\n */\npublic static void mergeCellsHorizonal(XWPFTable table, int row, int fromCol, int toCol) {\n    Preconditions.requireGreaterThan(toCol, fromCol, \"To column to be merged must greater than from column.\");\n    mergeCellsHorizontalWithoutRemove(table, row, fromCol, toCol);\n    XWPFTableRow rowTable = table.getRow(row);\n    for (int colIndex = fromCol + 1; colIndex <= toCol; colIndex++) {\n        rowTable.removeCell(fromCol + 1);\n        if (rowTable.getTableCells().size() != rowTable.getCtRow().sizeOfTcArray()) {\n            rowTable.getCtRow().removeTc(fromCol + 1);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCtRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderTable", "com.deepoove.poi.policy.TableRenderPolicy.Helper.applyMergeRule" ],
    "fullMethods" : [ "public static XWPFTable renderTable(XWPFRun run, TableRenderData data) throws Exception {\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    XWPFTable table = bodyContainer.insertNewTable(run, data.obtainRowSize(), data.obtainColSize());\n    StyleUtils.styleTable(table, data.getTableStyle());\n    int size = table.getRows().size();\n    for (int i = 0; i < size; i++) {\n        RowRenderData rowRenderData = data.getRows().get(i);\n        renderRow(table.getRows().get(i), rowRenderData, StyleUtils.retriveStyle(run));\n    }\n    applyMergeRule(table, data.getMergeRule());\n    return table;\n}", "private static void applyMergeRule(XWPFTable table, MergeCellRule mergeRule) {\n    if (null == mergeRule)\n        return;\n\n    byte[][] markRemovedCell = new byte[TableTools.obtainRowSize(table)][TableTools.obtainColumnSize(table)];\n    Iterator<Entry<Grid, Grid>> iterator = mergeRule.mappingIterator();\n    while (iterator.hasNext()) {\n        Entry<Grid, Grid> next = iterator.next();\n        Grid key = next.getKey();\n        Grid value = next.getValue();\n        int startI = (key.getI() > value.getI()) ? value.getI() : key.getI();\n        int startJ = (key.getJ() > value.getJ()) ? value.getJ() : key.getJ();\n        int endI = (key.getI() > value.getI()) ? key.getI() : value.getI();\n        int endJ = (key.getJ() > value.getJ()) ? key.getJ() : value.getJ();\n        // merge(VMerge mark) vertical\n        if (startI != endI) {\n            for (int j = startJ; j <= endJ; j++) {\n                TableTools.mergeCellsVertically(table, j, startI, endI);\n            }\n        }\n        // merge horizontal cells without remove cells\n        if (startJ != endJ) {\n            for (int i = startI; i <= endI; i++) {\n                TableTools.mergeCellsHorizontalWithoutRemove(table, i, startJ, endJ);\n                for (int removedCol = startJ + 1; removedCol <= endJ; removedCol++) {\n                    markRemovedCell[i][removedCol] = 1;\n                }\n            }\n        }\n    } \n    // remove marked cell safely\n    for (int i = 0; i < markRemovedCell.length; i++) {\n        for (int j = markRemovedCell[i].length - 1; j >= 0; j--) {\n            if (markRemovedCell[i][j] >= 1) {\n                table.getRow(i).removeCell(j);\n                if (table.getRow(i).getTableCells().size() != table.getRow(i).getCtRow().sizeOfTcArray()) {\n                    table.getRow(i).getCtRow().removeTc(j);\n                }\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCtRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render", "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.insertCell" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}", "@SuppressWarnings(\"unchecked\")\nprivate XWPFTableCell insertCell(XWPFTableRow tableRow, int actualInsertPosition) {\n    CTRow row = tableRow.getCtRow();\n    CTTc newTc = row.insertNewTc(actualInsertPosition);\n    XWPFTableCell cell = new XWPFTableCell(newTc, tableRow, tableRow.getTable().getBody());\n    List<XWPFTableCell> cells = ((List<XWPFTableCell>) (ReflectionUtils.getValue(\"tableCells\", tableRow)));\n    cells.add(actualInsertPosition, cell);\n    return cell;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCtRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        if ((null != data) && (data instanceof Iterable)) {\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            XWPFTableRow templateRow = table.getRow(templateRowIndex);\n            int insertPosition = templateRowIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            boolean firstFlag = true;\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateRowIndex++;\n                XWPFTableRow nextRow = table.insertNewTableRow(insertPosition);\n                setTableRow(table, templateRow, insertPosition);\n                // double set row\n                XmlCursor newCursor = templateRow.getCtRow().newCursor();\n                newCursor.toPrevSibling();\n                XmlObject object = newCursor.getObject();\n                nextRow = new XWPFTableRow(((CTRow) (object)), table);\n                if (!firstFlag) {\n                    // update VMerge cells for non-first row\n                    List<XWPFTableCell> tableCells = nextRow.getTableCells();\n                    for (XWPFTableCell cell : tableCells) {\n                        CTTcPr tcPr = TableTools.getTcPr(cell);\n                        CTVMerge vMerge = tcPr.getVMerge();\n                        if (null == vMerge)\n                            continue;\n\n                        if (STMerge.RESTART == vMerge.getVal()) {\n                            vMerge.setVal(STMerge.CONTINUE);\n                        }\n                    }\n                } else {\n                    firstFlag = false;\n                }\n                setTableRow(table, nextRow, insertPosition);\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                List<XWPFTableCell> cells = nextRow.getTableCells();\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        table.removeRow(templateRowIndex);\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \" error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableRow",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCtRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableRow" ],
    "fullMethods" : [ "/**\n * set row style\n *\n * @param row\n * @param rowStyle\n */\npublic static void styleTableRow(XWPFTableRow row, RowStyle rowStyle) {\n    if ((null == row) || (null == rowStyle))\n        return;\n\n    int height = rowStyle.getHeight();\n    CTRow ctRow = row.getCtRow();\n    CTTrPr properties = (ctRow.isSetTrPr()) ? ctRow.getTrPr() : ctRow.addNewTrPr();\n    if (0 != height) {\n        row.setHeight(height);\n        CTHeight h = (properties.sizeOfTrHeightArray() == 0) ? properties.addNewTrHeight() : properties.getTrHeightArray(0);\n        String heightRule = rowStyle.getHeightRule();\n        if (\"exact\".equals(heightRule))\n            h.setHRule(STHeightRule.EXACT);\n        else if (\"atleast\".equals(heightRule))\n            h.setHRule(STHeightRule.AT_LEAST);\n        else\n            h.setHRule(STHeightRule.AUTO);\n\n    }\n    boolean repeated = rowStyle.isRepeated();\n    if (repeated) {\n        CTOnOff tblHeader = (properties.sizeOfTblHeaderArray() == 0) ? properties.addNewTblHeader() : properties.getTblHeaderArray(0);\n        tblHeader.setVal(XWPFOnOff.ON);\n    }\n    boolean breakAcrossPage = rowStyle.isBreakAcrossPage();\n    if (!breakAcrossPage) {\n        if (properties.sizeOfCantSplitArray() == 0) {\n            properties.addNewCantSplit();\n        } else {\n            properties.getCantSplitArray(0).setVal(XWPFOnOff.ON);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCtRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    try {\n        RunTemplate runTemplate = cast2runTemplate(eleTemplate);\n        XWPFRun run = runTemplate.getRun();\n        checkTargetIsTable(run, (\"Processing [\" + runTemplate.getTagName()) + \"] failed, the target content is not a table\");\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        final XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n        // \n        int position = getRowIndex(tagCell.getTableRow());\n        List<XWPFTableRow> tempRows = getAllTemplateRow(table, position);\n        if ((null != data) && (data instanceof Iterable)) {\n            // \n            final XWPFTableRow firstTempRow = tempRows.get(0);\n            Iterator<?> dataIt = ((Iterable<?>) (data)).iterator();\n            boolean hasNextData = dataIt.hasNext();\n            int index = 0;\n            while (hasNextData) {\n                Object dt = dataIt.next();\n                hasNextData = dataIt.hasNext();\n                Iterator<XWPFTableRow> rowTempIt = tempRows.iterator();\n                boolean hasNextTempRow = rowTempIt.hasNext();\n                while (hasNextTempRow) {\n                    XWPFTableRow tempRow = rowTempIt.next();\n                    hasNextTempRow = rowTempIt.hasNext();\n                    if (!table.addRow(tempRow, position)) {\n                        throw new RenderException(\"\");\n                    }\n                    // \n                    XmlCursor newCursor = firstTempRow.getCtRow().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    XWPFTableRow newRow = new XWPFTableRow(((CTRow) (object)), table);\n                    newRow.getCtRow().set(object);\n                    setTableRow(table, newRow, position);\n                    List<XWPFTableCell> cells = newRow.getTableCells();\n                    RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(dt, EnvIterator.makeEnv(index, hasNextData || hasNextTempRow)));\n                    cells.forEach(tableCell -> {\n                        List<MetaTemplate> metaTemplates = resolver.resolveBodyElements(tableCell.getBodyElements());\n                        new DocumentProcessor(template, resolver, dataCompute).process(metaTemplates);\n                    });\n                    ++position;\n                } \n                ++index;\n            } \n        }\n        removeTableRow(table, position, tempRows.size());\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-row template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr.isSetWordWrap",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTShd.isSetFill",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyle(XWPFParagraph paragraph) {\n    if (null == paragraph)\n        return null;\n\n    Builder builder = ParagraphStyle.builder();\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    if (paragraph.isWordWrapped()) {\n        builder.withAllowWordBreak(true);\n    }\n    if (pr.isSetPBdr()) {\n        CTPBdr ct = pr.getPBdr();\n        if (ct.isSetLeft()) {\n            builder.withLeftBorder(retriveBorderStyle(ct.getLeft()));\n        }\n        if (ct.isSetTop()) {\n            builder.withTopBorder(retriveBorderStyle(ct.getTop()));\n        }\n        if (ct.isSetRight()) {\n            builder.withRightBorder(retriveBorderStyle(ct.getRight()));\n        }\n        if (ct.isSetBottom()) {\n            builder.withBottomBorder(retriveBorderStyle(ct.getBottom()));\n        }\n    }\n    if (pr.isSetShd()) {\n        CTShd shd = pr.getShd();\n        builder.withShadingPattern(XWPFShadingPattern.valueOf(shd.getVal().intValue()));\n        if (shd.isSetFill())\n            builder.withBackgroundColor(shd.xgetFill().getStringValue());\n\n    }\n    builder.withAlign(paragraph.getAlignment());\n    int spacingBeforeLines = paragraph.getSpacingBeforeLines();\n    if ((-1) != spacingBeforeLines) {\n        builder.withSpacingBeforeLines(spacingBeforeLines / 100.0F);\n    }\n    int spacingAfterLines = paragraph.getSpacingAfterLines();\n    if ((-1) != spacingAfterLines) {\n        builder.withSpacingAfterLines(spacingAfterLines / 100.0F);\n    }\n    int spacingBefore = paragraph.getSpacingBefore();\n    if ((-1) != spacingBefore) {\n        builder.withSpacingBefore(UnitUtils.twips2Point(spacingBefore));\n    }\n    int spacingAfter = paragraph.getSpacingAfter();\n    if ((-1) != spacingAfter) {\n        builder.withSpacingAfter(UnitUtils.twips2Point(spacingAfter));\n    }\n    double spacingBetween = paragraph.getSpacingBetween();\n    if ((-1) != spacingBetween) {\n        builder.withSpacing(spacingBetween);\n        builder.withSpacingRule(paragraph.getSpacingLineRule());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRPr.addNewHighlight",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun" ],
    "fullMethods" : [ "/**\n * set run style by style\n *\n * @param run\n * @param style\n */\npublic static void styleRun(XWPFRun run, Style style) {\n    if ((null == run) || (null == style))\n        return;\n\n    CTRPr pr = getRunProperties(run);\n    String color = style.getColor();\n    if (StringUtils.isNotBlank(color)) {\n        // run.setColor(color);\n        // issue 326\n        CTColor ctColor = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        ctColor.setVal(color);\n        if (ctColor.isSetThemeColor())\n            ctColor.unsetThemeColor();\n\n    }\n    double fontSize = style.getFontSize();\n    if ((0 != fontSize) && ((-1) != fontSize)) {\n        run.setFontSize(fontSize);\n    }\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        run.setFontFamily(fontFamily, FontCharRange.eastAsia);\n        run.setFontFamily(fontFamily, FontCharRange.ascii);\n        run.setFontFamily(fontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(fontFamily, FontCharRange.cs);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        run.setFontFamily(westernFontFamily, FontCharRange.ascii);\n        run.setFontFamily(westernFontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(westernFontFamily, FontCharRange.cs);\n    }\n    XWPFHighlightColor highlightColor = style.getHighlightColor();\n    if (null != highlightColor) {\n        CTHighlight highlight = (pr.sizeOfHighlightArray() > 0) ? pr.getHighlightArray(0) : pr.addNewHighlight();\n        highlight.setVal(STHighlightColor.Enum.forInt(highlightColor.getValue()));\n    }\n    Boolean bold = style.isBold();\n    if (null != bold)\n        run.setBold(bold);\n\n    Boolean italic = style.isItalic();\n    if (null != italic)\n        run.setItalic(italic);\n\n    Boolean strike = style.isStrike();\n    if (null != strike)\n        run.setStrikeThrough(strike);\n\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        run.setUnderline(underlinePatern);\n        if (null != style.getUnderlineColor()) {\n            run.setUnderlineColor(style.getUnderlineColor());\n        }\n    }\n    int point = style.getCharacterSpacing();\n    // in twentieths of a point\n    if ((0 != point) && ((-1) != point))\n        run.setCharacterSpacing(UnitUtils.point2Twips(point));\n\n    String vertAlign = style.getVertAlign();\n    if (StringUtils.isNotBlank(vertAlign)) {\n        run.setVerticalAlignment(vertAlign);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableRow",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTrPr.sizeOfTrHeightArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableRow" ],
    "fullMethods" : [ "/**\n * set row style\n *\n * @param row\n * @param rowStyle\n */\npublic static void styleTableRow(XWPFTableRow row, RowStyle rowStyle) {\n    if ((null == row) || (null == rowStyle))\n        return;\n\n    int height = rowStyle.getHeight();\n    CTRow ctRow = row.getCtRow();\n    CTTrPr properties = (ctRow.isSetTrPr()) ? ctRow.getTrPr() : ctRow.addNewTrPr();\n    if (0 != height) {\n        row.setHeight(height);\n        CTHeight h = (properties.sizeOfTrHeightArray() == 0) ? properties.addNewTrHeight() : properties.getTrHeightArray(0);\n        String heightRule = rowStyle.getHeightRule();\n        if (\"exact\".equals(heightRule))\n            h.setHRule(STHeightRule.EXACT);\n        else if (\"atleast\".equals(heightRule))\n            h.setHRule(STHeightRule.AT_LEAST);\n        else\n            h.setHRule(STHeightRule.AUTO);\n\n    }\n    boolean repeated = rowStyle.isRepeated();\n    if (repeated) {\n        CTOnOff tblHeader = (properties.sizeOfTblHeaderArray() == 0) ? properties.addNewTblHeader() : properties.getTblHeaderArray(0);\n        tblHeader.setVal(XWPFOnOff.ON);\n    }\n    boolean breakAcrossPage = rowStyle.isBreakAcrossPage();\n    if (!breakAcrossPage) {\n        if (properties.sizeOfCantSplitArray() == 0) {\n            properties.addNewCantSplit();\n        } else {\n            properties.getCantSplitArray(0).setVal(XWPFOnOff.ON);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFFootnote.getCTFtnEdn",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableString", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeFootnote" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "protected String createMergeableString(NiceXWPFDocument source, NiceXWPFDocument merged, Map<String, String> styleIdsMap) throws InvalidFormatException, IOException {\n    CTBody mergedBody = merged.getDocument().getBody();\n    // TODO For the same style, reduce the number of merges\n    // Map<String, String> styleIdsMap = mergeStyles(docMerge);\n    Map<String, String> numIdsMap = mergeNumbering(source, merged);\n    Map<String, String> blipIdsMap = mergePicture(source, merged);\n    Map<String, String> externalBlipIdsMap = mergeExternalPicture(source, merged);\n    Map<String, String> hyperlinkMap = mergeHyperlink(source, merged);\n    Map<String, String> chartIdsMap = mergeChart(source, merged);\n    Map<String, String> attachmentIdsMap = mergeAttachment(source, merged);\n    Map<String, String> footnoteIdsMap = mergeFootnote(source, merged);\n    Map<String, String> endnoteIdsMap = mergeEndnote(source, merged);\n    String appendString = mergedBody.xmlText(DefaultXmlOptions.OPTIONS_OUTER);\n    String addPart = ridSectPr(appendString);\n    // style\n    for (String styleId : styleIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:pStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:pStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:tblStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:tblStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:rStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:rStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\");\n    }\n    // picture id\n    Map<String, String> placeHolderblipIdsMap = new HashMap<String, String>();\n    for (String relaId : blipIdsMap.keySet()) {\n        placeHolderblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:embed=\\\"\" + relaId) + \"\\\"\", (\"r:embed=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n        // w:pict v:shape v:imagedata\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    Map<String, String> placeHolderExternalblipIdsMap = new HashMap<String, String>();\n    for (String relaId : externalBlipIdsMap.keySet()) {\n        placeHolderExternalblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderExternalblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:link=\\\"\" + relaId) + \"\\\"\", (\"r:link=\\\"\" + placeHolderExternalblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // hyperlink id\n    for (String relaId : hyperlinkMap.keySet()) {\n        hyperlinkMap.put(relaId, hyperlinkMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : hyperlinkMap.keySet()) {\n        // w:hyperlink r:id\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + hyperlinkMap.get(relaId)) + \"\\\"\");\n    }\n    // chart id\n    for (String relaId : chartIdsMap.keySet()) {\n        chartIdsMap.put(relaId, chartIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : chartIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + chartIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // attachment id\n    for (String relaId : attachmentIdsMap.keySet()) {\n        attachmentIdsMap.put(relaId, attachmentIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : attachmentIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + attachmentIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // footnote id\n    for (String relaId : footnoteIdsMap.keySet()) {\n        footnoteIdsMap.put(relaId, footnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : footnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"footnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"footnoteReference w:id=\\\"\" + footnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // endnote id\n    for (String relaId : endnoteIdsMap.keySet()) {\n        endnoteIdsMap.put(relaId, endnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : endnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"endnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"endnoteReference w:id=\\\"\" + endnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // numbering numId\n    for (String relaId : numIdsMap.keySet()) {\n        numIdsMap.put(relaId, numIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String numId : numIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:numId\\\\sw:val=\\\"\" + numId) + \"\\\"\", (\"<w:numId w:val=\\\"\" + numIdsMap.get(numId)) + \"\\\"\");\n    }\n    return addPart.replaceAll(CROSS_REPLACE_STRING, \"\");\n}", "protected Map<String, String> mergeFootnote(NiceXWPFDocument source, NiceXWPFDocument merged) {\n    Map<String, String> blipIdsMap = new HashMap<>();\n    FootnoteEndnoteIdManager footnoteEndnoteIdManager = new FootnoteEndnoteIdManager(source);\n    List<XWPFFootnote> footnotes = merged.getFootnotes();\n    if (!footnotes.isEmpty()) {\n        XWPFFootnotes sourceFootnotes = source.createFootnotes();\n        for (XWPFFootnote footnote : footnotes) {\n            String relationId = footnote.getId().toString();\n            footnote.getCTFtnEdn().setId(footnoteEndnoteIdManager.nextId());\n            sourceFootnotes.addFootnote(footnote);\n            String blidId = footnote.getId().toString();\n            blipIdsMap.put(relationId, blidId);\n        }\n    }\n    return blipIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.<init>", "com.deepoove.poi.resolver.RunningRunBody.refactorBody" ],
    "fullMethods" : [ "public RunningRunBody(RunBodyContext context, Pattern pattern) {\n    this.runBodyContext = context;\n    this.runs = context.getRuns();\n    if ((null == runs) || runs.isEmpty())\n        return;\n\n    Matcher matcher = pattern.matcher(getText(context));\n    if (matcher.find()) {\n        refactorBody();\n    }\n    buildRunEdge(pattern);\n}", "private void refactorBody() {\n    for (int i = runs.size() - 1; i >= 0; i--) {\n        XWPFRun xwpfRun = runs.get(i);\n        CTR ctr = xwpfRun.getCTR();\n        CTRImpl ctrimpl = ((CTRImpl) (ctr));\n        int sizeOfBrArray = ctr.sizeOfBrArray();\n        int sizeOfCrArray = ctr.sizeOfCrArray();\n        int sizeOfTabArray = ctr.sizeOfTabArray();\n        if (((sizeOfBrArray + sizeOfCrArray) + sizeOfTabArray) > 0) {\n            synchronized(ctrimpl.monitor()) {\n                // ctrimpl.check_orphaned();\n                List<? extends XmlObject> localArrayList = new ArrayList<XmlObject>();\n                ctrimpl.get_store().find_all_element_users(qname, localArrayList);\n                int size = localArrayList.size();\n                for (int j = size - 1; j >= 0; j--) {\n                    Object obj = localArrayList.get(j);\n                    if (obj instanceof CTEmpty) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        String tagName = ((CTEmpty) (obj)).getDomNode().getNodeName();\n                        if (\"w:br\".equals(tagName) || \"br\".equals(tagName)) {\n                            insertNewRun.addBreak();\n                        }\n                        if (\"w:cr\".equals(tagName) || \"cr\".equals(tagName)) {\n                            insertNewRun.addCarriageReturn();\n                        }\n                        if (\"w:tab\".equals(tagName) || \"tab\".equals(tagName)) {\n                            insertNewRun.addTab();\n                        }\n                    } else if (obj instanceof CTBr) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        CTBr addNewBr = insertNewRun.getCTR().addNewBr();\n                        if (null != ((CTBr) (obj)).getType())\n                            addNewBr.setType(((CTBr) (obj)).getType());\n\n                        if (null != ((CTBr) (obj)).getClear())\n                            addNewBr.setClear(((CTBr) (obj)).getClear());\n\n                    } else if (obj instanceof CTText) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        StyleUtils.styleRun(insertNewRun, xwpfRun);\n                        insertNewRun.setText(((CTText) (obj)).getStringValue());\n                    }\n                }\n                runBodyContext.removeRun(i);\n            }\n        }\n    }\n    this.runs = runBodyContext.getRuns();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TextRenderPolicy.Helper.renderTextRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TextRenderPolicy.Helper.renderTextRun" ],
    "fullMethods" : [ "public static void renderTextRun(XWPFRun run, TextRenderData data) {\n    XWPFRun textRun = run;\n    if (data instanceof HyperlinkTextRenderData) {\n        textRun = createHyperlink(run, ((HyperlinkTextRenderData) (data)).getUrl());\n    }\n    StyleUtils.styleRun(textRun, data.getStyle());\n    String text = Optional.ofNullable(data.getText()).orElse(\"\");\n    String[] fragment = text.split(REGEX_LINE_CHARACTOR, -1);\n    if (fragment.length > 0) {\n        textRun.setText(fragment[0], 0);\n        boolean lineAtTable = ((fragment.length > 1) && (!(data instanceof HyperlinkTextRenderData))) && TableTools.isInsideTable(run);\n        for (int i = 1; i < fragment.length; i++) {\n            if (lineAtTable) {\n                textRun.addBreak(BreakType.TEXT_WRAPPING);\n            } else {\n                textRun.addCarriageReturn();\n            }\n            textRun.setText(fragment[i]);\n        }\n    }\n    if (data instanceof BookmarkTextRenderData) {\n        createBookmark(textRun, ((BookmarkTextRenderData) (data)).getBookmark());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.XWPFTemplate.create",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.setText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.XWPFTemplate.create" ],
    "fullMethods" : [ "/**\n * Create new document with styled tag\n *\n * @return template\n * @since 1.10.0\n */\npublic static XWPFTemplate create(DocumentRenderData data, Style templateTagStyle) {\n    Configure configure = Configure.builder().bind(TEMPLATE_TAG_NAME, new DocumentRenderPolicy()).build();\n    XWPFDocument document = new NiceXWPFDocument();\n    XWPFRun run = document.createParagraph().createRun();\n    run.setText((configure.getGramerPrefix() + TEMPLATE_TAG_NAME) + configure.getGramerSuffix());\n    StyleUtils.styleRun(run, templateTagStyle);\n    return compile(document, configure).render(Collections.singletonMap(TEMPLATE_TAG_NAME, data));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.mergeCellsVertically",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCell",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.mergeCellsVertically" ],
    "fullMethods" : [ "/**\n * merge several rows of cells in the same column\n *\n * @param table\n * \t\ttable\n * @param col\n * \t\tindex of the column\n * @param fromRow\n * \t\tfrom row to be merged\n * @param toRow\n * \t\tend row to be merged\n */\npublic static void mergeCellsVertically(XWPFTable table, int col, int fromRow, int toRow) {\n    Preconditions.requireGreaterThan(toRow, fromRow, \"To row to be merged must greater than from row.\");\n    for (int rowIndex = fromRow; rowIndex <= toRow; rowIndex++) {\n        XWPFTableCell cell = table.getRow(rowIndex).getCell(col);\n        CTTcPr tcPr = getTcPr(cell);\n        CTVMerge vMerge = tcPr.addNewVMerge();\n        if (rowIndex == fromRow) {\n            // The first merged cell is set with RESTART merge value\n            vMerge.setVal(STMerge.RESTART);\n        } else {\n            // Cells which join (merge) the first one, are set with CONTINUE\n            vMerge.setVal(STMerge.CONTINUE);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCell",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        for (int i = rowSize - 1; i >= 0; i--) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            String text = row.getCell(actualInsertPosition).getText();\n            if (\"_delete_\".equals(text)) {\n                table.removeRow(i);\n            } else {\n                removeCell(row, actualInsertPosition);\n            }\n        }\n    } catch (Exception e) {\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCell",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CommentBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCell",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CommentBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFHeaderFooter\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCell",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFTableCell\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.DocumentBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCell",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.DocumentBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.setWidth",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCell",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.setWidth" ],
    "fullMethods" : [ "/**\n * set table width\n *\n * @param table\n * @param width\n * @param colWidths\n */\npublic static void setWidth(XWPFTable table, String width, int[] colWidths) {\n    ensureTblW(table);\n    table.setWidth(width);\n    if (null == colWidths) {\n        int columnSize = TableTools.obtainColumnSize(table);\n        if (table.getWidthType() == TableWidthType.DXA) {\n            colWidths = UnitUtils.average(Integer.valueOf(width), columnSize);\n        } else if (table.getWidthType() == TableWidthType.PCT) {\n            int sum = 0;\n            colWidths = new int[columnSize];\n            for (int i = 0; i < (columnSize - 1); i++) {\n                colWidths[i] = 100 / columnSize;\n                sum += colWidths[i];\n            }\n            colWidths[columnSize - 1] = 100 - sum;\n        }\n    }\n    if (null != colWidths) {\n        BigInteger[] gridCol = null;\n        String[] cellWidth = null;\n        if (table.getWidthType() == TableWidthType.DXA) {\n            cellWidth = Arrays.stream(colWidths).mapToObj(String::valueOf).toArray(String[]::new);\n            gridCol = Arrays.stream(colWidths).mapToObj(BigInteger::valueOf).toArray(BigInteger[]::new);\n        } else if (table.getWidthType() == TableWidthType.PCT) {\n            cellWidth = Arrays.stream(colWidths).mapToObj(w -> w + \"%\").toArray(String[]::new);\n            BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(table.getBody());\n            int pageWidth = bodyContainer.elementPageWidth(table);\n            int tableWidth = (pageWidth * Integer.valueOf(width.substring(0, width.length() - 1))) / 100;\n            gridCol = Arrays.stream(colWidths).mapToObj(w -> BigInteger.valueOf((w * tableWidth) / 100)).toArray(BigInteger[]::new);\n        }\n        CTTblGrid tblGrid = TableTools.getTblGrid(table);\n        CTTblLayoutType tblLayout = TableTools.getTblLayout(table);\n        tblLayout.setType(STTblLayoutType.FIXED);\n        for (int index = 0; index < colWidths.length; index++) {\n            if (null != gridCol) {\n                CTTblGridCol addNewGridCol = tblGrid.addNewGridCol();\n                addNewGridCol.setW(gridCol[index]);\n            }\n            List<XWPFTableRow> rows = table.getRows();\n            for (XWPFTableRow row : rows) {\n                row.getCell(index).setWidth(cellWidth[index]);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderRow",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCell",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderRow" ],
    "fullMethods" : [ "public static void renderRow(XWPFTableRow row, RowRenderData data, Style defaultTextStyle) throws Exception {\n    if (null == data)\n        return;\n\n    int size = row.getTableCells().size();\n    if (size != data.obtainColSize()) {\n        throw new IllegalArgumentException(\"Number of cells and render data should be the same!\");\n    }\n    StyleUtils.styleTableRow(row, data.getRowStyle());\n    CellStyle defaultCellStyle = (null == data.getRowStyle()) ? null : data.getRowStyle().getDefaultCellStyle();\n    for (int i = 0; i < size; i++) {\n        renderCell(row.getCell(i), data.getCells().get(i), defaultCellStyle, defaultTextStyle);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.mergeCellsHorizontalWithoutRemove",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCell",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.mergeCellsHorizontalWithoutRemove" ],
    "fullMethods" : [ "/**\n * merge several columns of cells in the same row, but do'not remove extra cells\n *\n * @param table\n * \t\ttable\n * @param row\n * \t\tindex of the row\n * @param fromCol\n * \t\tfrom column to be merged\n * @param toCol\n * \t\tto column to be merged\n */\npublic static void mergeCellsHorizontalWithoutRemove(XWPFTable table, int row, int fromCol, int toCol) {\n    Preconditions.requireGreaterThan(toCol, fromCol, \"To column to be merged must greater than from column.\");\n    XWPFTableCell cell = table.getRow(row).getCell(fromCol);\n    CTTcPr tcPr = getTcPr(cell);\n    tcPr.addNewGridSpan();\n    tcPr.getGridSpan().setVal(BigInteger.valueOf(((long) ((toCol - fromCol) + 1))));\n    int tcw = 0;\n    for (int colIndex = fromCol; colIndex <= toCol; colIndex++) {\n        XWPFTableCell tableCell = table.getRow(row).getCell(colIndex);\n        // TODO pct, auto\n        if (TableWidthType.DXA == tableCell.getWidthType()) {\n            if ((-1) == tableCell.getWidth())\n                return;\n\n            tcw += tableCell.getWidth();\n        } else {\n            return;\n        }\n    }\n    if (0 != tcw)\n        cell.setWidth(tcw + \"\");\n\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCell",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFHeaderFooter\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCell",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getCell",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        int templateColIndex = getColIndex(tagCell);\n        if ((null == data) || ((data instanceof Boolean) && (!((Boolean) (data))))) {\n            // table.removeRow(templateRowIndex);\n            // tagCell.setText(\"_delete_\");\n            run.setText(\"_delete_\", 0);\n            CTTcPr tcPr = TableTools.getTcPr(tagCell);\n            CTVMerge vMerge = tcPr.getVMerge();\n            System.out.println(null == vMerge ? null : vMerge.getVal());\n            if ((null != vMerge) && vMerge.getVal().equals(STMerge.RESTART)) {\n                XWPFTableRow row = table.getRow(templateRowIndex + 1);\n                int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n                XWPFTableCell actualCell = row.getCell(actualInsertPosition);\n                System.out.println(actualCell.getCTTc());\n                actualCell.getParagraphArray(0).createRun().setText(\"_delete_\", 0);\n            }\n        } else {\n            run.setText(\"\", 0);\n        }\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.setTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTHdrFtr.setTblArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.setTable" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setTable(int pos, XWPFTable table) {\n    // cell.getTables().set(pos, table);\n    List<XWPFTable> tables = ((List<XWPFTable>) (ReflectionUtils.getValue(\"tables\", headerFooter)));\n    tables.set(pos, table);\n    headerFooter._getHdrFtr().setTblArray(pos, table.getCTTbl());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr.addNewKeepLines",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.getShapeProperties",
    "thirdPartyMethod" : "org.apache.poi.xddf.usermodel.XDDFShapeProperties.<init>",
    "thirdPartyPackage" : "org.apache.poi.xddf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.getShapeProperties" ],
    "fullMethods" : [ "@Override\npublic XDDFShapeProperties getShapeProperties() {\n    if (series.isSetSpPr()) {\n        return new XDDFShapeProperties(series.getSpPr());\n    } else {\n        return null;\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.STHexColorAuto.Enum.forString",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.STHexColorAuto",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.setVaryColors",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTOfPieChart.unsetVaryColors",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.setVaryColors" ],
    "fullMethods" : [ "@Override\npublic void setVaryColors(Boolean varyColors) {\n    if (varyColors == null) {\n        if (chart.isSetVaryColors()) {\n            chart.unsetVaryColors();\n        }\n    } else if (chart.isSetVaryColors()) {\n        chart.getVaryColors().setVal(varyColors);\n    } else {\n        chart.addNewVaryColors().setVal(varyColors);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.setParagraph",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTxbxContent.addNewP",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.setParagraph" ],
    "fullMethods" : [ "public void setParagraph(XWPFParagraph p) {\n    if (ctTxbxContent.sizeOfPArray() == 0) {\n        ctTxbxContent.addNewP();\n    }\n    ctTxbxContent.setPArray(0, p.getCTP());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.addParagraph",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTxbxContent.addNewP",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.addParagraph" ],
    "fullMethods" : [ "/**\n * Add a Paragraph to this textbox\n *\n * @return The paragraph which was added\n */\npublic XWPFParagraph addParagraph() {\n    XWPFParagraph p = new XWPFParagraph(ctTxbxContent.addNewP(), this);\n    addParagraph(p);\n    return p;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.STShd.Enum.intValue",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.STShd",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyle(XWPFParagraph paragraph) {\n    if (null == paragraph)\n        return null;\n\n    Builder builder = ParagraphStyle.builder();\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    if (paragraph.isWordWrapped()) {\n        builder.withAllowWordBreak(true);\n    }\n    if (pr.isSetPBdr()) {\n        CTPBdr ct = pr.getPBdr();\n        if (ct.isSetLeft()) {\n            builder.withLeftBorder(retriveBorderStyle(ct.getLeft()));\n        }\n        if (ct.isSetTop()) {\n            builder.withTopBorder(retriveBorderStyle(ct.getTop()));\n        }\n        if (ct.isSetRight()) {\n            builder.withRightBorder(retriveBorderStyle(ct.getRight()));\n        }\n        if (ct.isSetBottom()) {\n            builder.withBottomBorder(retriveBorderStyle(ct.getBottom()));\n        }\n    }\n    if (pr.isSetShd()) {\n        CTShd shd = pr.getShd();\n        builder.withShadingPattern(XWPFShadingPattern.valueOf(shd.getVal().intValue()));\n        if (shd.isSetFill())\n            builder.withBackgroundColor(shd.xgetFill().getStringValue());\n\n    }\n    builder.withAlign(paragraph.getAlignment());\n    int spacingBeforeLines = paragraph.getSpacingBeforeLines();\n    if ((-1) != spacingBeforeLines) {\n        builder.withSpacingBeforeLines(spacingBeforeLines / 100.0F);\n    }\n    int spacingAfterLines = paragraph.getSpacingAfterLines();\n    if ((-1) != spacingAfterLines) {\n        builder.withSpacingAfterLines(spacingAfterLines / 100.0F);\n    }\n    int spacingBefore = paragraph.getSpacingBefore();\n    if ((-1) != spacingBefore) {\n        builder.withSpacingBefore(UnitUtils.twips2Point(spacingBefore));\n    }\n    int spacingAfter = paragraph.getSpacingAfter();\n    if ((-1) != spacingAfter) {\n        builder.withSpacingAfter(UnitUtils.twips2Point(spacingAfter));\n    }\n    double spacingBetween = paragraph.getSpacingBetween();\n    if ((-1) != spacingBetween) {\n        builder.withSpacing(spacingBetween);\n        builder.withSpacingRule(paragraph.getSpacingLineRule());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.setSpacingAfter",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFonts.setHAnsi",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId" ],
    "fullMethods" : [ "public BigInteger addNewMultiLevelNumberingId(NumberingFormat... numFmts) {\n    XWPFNumbering numbering = this.getNumbering();\n    if (null == numbering) {\n        numbering = this.createNumbering();\n    }\n    XWPFNumberingWrapper numberingWrapper = new XWPFNumberingWrapper(numbering);\n    CTAbstractNum cTAbstractNum = CTAbstractNum.Factory.newInstance();\n    // if we have an existing document, we must determine the next\n    // free number first.\n    cTAbstractNum.setAbstractNumId(numberingWrapper.getNextAbstractNumID());\n    // CTMultiLevelType addNewMultiLevelType = cTAbstractNum.addNewMultiLevelType();\n    // addNewMultiLevelType.setVal(STMultiLevelType.HYBRID_MULTILEVEL);\n    for (int i = 0; i < numFmts.length; i++) {\n        NumberingFormat numFmt = numFmts[i];\n        CTLvl cTLvl = cTAbstractNum.addNewLvl();\n        CTPPrBase ppr = (cTLvl.isSetPPr()) ? cTLvl.getPPr() : cTLvl.addNewPPr();\n        CTInd ind = (ppr.isSetInd()) ? ppr.getInd() : ppr.addNewInd();\n        ind.setLeft(BigInteger.valueOf(UnitUtils.cm2Twips(0.74F) * i));\n        Enum fmt = STNumberFormat.Enum.forInt(numFmt.getNumFmt());\n        String val = numFmt.getLvlText();\n        cTLvl.addNewNumFmt().setVal(fmt);\n        cTLvl.addNewLvlText().setVal(val);\n        cTLvl.addNewStart().setVal(BigInteger.valueOf(1));\n        cTLvl.setIlvl(BigInteger.valueOf(i));\n        if (fmt == STNumberFormat.BULLET) {\n            cTLvl.addNewLvlJc().setVal(STJc.LEFT);\n            CTRPr addNewRPr = cTLvl.addNewRPr();\n            CTFonts ctFonts = addNewRPr.addNewRFonts();\n            ctFonts.setAscii(\"Wingdings\");\n            ctFonts.setHAnsi(\"Wingdings\");\n            ctFonts.setHint(STHint.DEFAULT);\n        }\n    }\n    XWPFAbstractNum abstractNum = new XWPFAbstractNum(cTAbstractNum);\n    BigInteger abstractNumID = numbering.addAbstractNum(abstractNum);\n    return numbering.addNum(abstractNumID);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFonts.setHAnsi",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.NumberingContinue.updateNumbering",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTAbstractNum.unsetNsid",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.render.processor.NumberingContinue.updateNumbering" ],
    "fullMethods" : [ "public void updateNumbering(XWPFParagraph source, XWPFParagraph target) {\n    XWPFDocument document = source.getDocument();\n    XWPFNumbering numbering = document.getNumbering();\n    if (null == numbering)\n        return;\n\n    BigInteger numID = source.getNumID();\n    if (numID == null)\n        return;\n\n    if ((null != continueNumID) && numID.equals(continueNumID)) {\n        return;\n    }\n    if (consistCache.get(numID) != null) {\n        target.setNumID(consistCache.get(numID));\n        return;\n    }\n    XWPFNumberingWrapper wrapper = new XWPFNumberingWrapper(numbering);\n    XWPFNum num = numbering.getNum(numID);\n    if (null == num)\n        return;\n\n    XWPFAbstractNum abstractNum = numbering.getAbstractNum(num.getCTNum().getAbstractNumId().getVal());\n    CTAbstractNum ctAbstractNum = ((CTAbstractNum) (abstractNum.getAbstractNum().copy()));\n    ctAbstractNum.setAbstractNumId(wrapper.getNextAbstractNumID());\n    // clear continues list\n    // (related to tracking numbering definitions when documents are\n    // repurposed and\n    // changed\n    if (ctAbstractNum.isSetNsid())\n        ctAbstractNum.unsetNsid();\n\n    // related to where the definition can be displayed in the user\n    // interface\n    if (ctAbstractNum.isSetTmpl())\n        ctAbstractNum.unsetTmpl();\n\n    BigInteger abstractNumID = numbering.addAbstractNum(new XWPFAbstractNum(ctAbstractNum));\n    BigInteger newNumId = numbering.addNum(abstractNumID);\n    target.setNumID(newNumId);\n    consistCache.put(numID, newNumId);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTAbstractNum.unsetNsid",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableString", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeNumbering" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "protected String createMergeableString(NiceXWPFDocument source, NiceXWPFDocument merged, Map<String, String> styleIdsMap) throws InvalidFormatException, IOException {\n    CTBody mergedBody = merged.getDocument().getBody();\n    // TODO For the same style, reduce the number of merges\n    // Map<String, String> styleIdsMap = mergeStyles(docMerge);\n    Map<String, String> numIdsMap = mergeNumbering(source, merged);\n    Map<String, String> blipIdsMap = mergePicture(source, merged);\n    Map<String, String> externalBlipIdsMap = mergeExternalPicture(source, merged);\n    Map<String, String> hyperlinkMap = mergeHyperlink(source, merged);\n    Map<String, String> chartIdsMap = mergeChart(source, merged);\n    Map<String, String> attachmentIdsMap = mergeAttachment(source, merged);\n    Map<String, String> footnoteIdsMap = mergeFootnote(source, merged);\n    Map<String, String> endnoteIdsMap = mergeEndnote(source, merged);\n    String appendString = mergedBody.xmlText(DefaultXmlOptions.OPTIONS_OUTER);\n    String addPart = ridSectPr(appendString);\n    // style\n    for (String styleId : styleIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:pStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:pStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:tblStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:tblStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:rStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:rStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\");\n    }\n    // picture id\n    Map<String, String> placeHolderblipIdsMap = new HashMap<String, String>();\n    for (String relaId : blipIdsMap.keySet()) {\n        placeHolderblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:embed=\\\"\" + relaId) + \"\\\"\", (\"r:embed=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n        // w:pict v:shape v:imagedata\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    Map<String, String> placeHolderExternalblipIdsMap = new HashMap<String, String>();\n    for (String relaId : externalBlipIdsMap.keySet()) {\n        placeHolderExternalblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderExternalblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:link=\\\"\" + relaId) + \"\\\"\", (\"r:link=\\\"\" + placeHolderExternalblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // hyperlink id\n    for (String relaId : hyperlinkMap.keySet()) {\n        hyperlinkMap.put(relaId, hyperlinkMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : hyperlinkMap.keySet()) {\n        // w:hyperlink r:id\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + hyperlinkMap.get(relaId)) + \"\\\"\");\n    }\n    // chart id\n    for (String relaId : chartIdsMap.keySet()) {\n        chartIdsMap.put(relaId, chartIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : chartIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + chartIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // attachment id\n    for (String relaId : attachmentIdsMap.keySet()) {\n        attachmentIdsMap.put(relaId, attachmentIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : attachmentIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + attachmentIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // footnote id\n    for (String relaId : footnoteIdsMap.keySet()) {\n        footnoteIdsMap.put(relaId, footnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : footnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"footnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"footnoteReference w:id=\\\"\" + footnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // endnote id\n    for (String relaId : endnoteIdsMap.keySet()) {\n        endnoteIdsMap.put(relaId, endnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : endnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"endnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"endnoteReference w:id=\\\"\" + endnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // numbering numId\n    for (String relaId : numIdsMap.keySet()) {\n        numIdsMap.put(relaId, numIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String numId : numIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:numId\\\\sw:val=\\\"\" + numId) + \"\\\"\", (\"<w:numId w:val=\\\"\" + numIdsMap.get(numId)) + \"\\\"\");\n    }\n    return addPart.replaceAll(CROSS_REPLACE_STRING, \"\");\n}", "protected Map<String, String> mergeNumbering(NiceXWPFDocument source, NiceXWPFDocument merged) {\n    Map<String, String> numIdsMap = new HashMap<String, String>();\n    XWPFNumbering numberingMerge = merged.getNumbering();\n    if (null == numberingMerge)\n        return numIdsMap;\n\n    XWPFNumberingWrapper wrapperMerge = new XWPFNumberingWrapper(numberingMerge);\n    List<XWPFNum> nums = wrapperMerge.getNums();\n    if (null == nums)\n        return numIdsMap;\n\n    XWPFNumbering numbering = source.getNumbering();\n    if (null == numbering)\n        numbering = source.createNumbering();\n\n    XWPFNumberingWrapper wrapper = new XWPFNumberingWrapper(numbering);\n    XWPFAbstractNum xwpfAbstractNum;\n    CTAbstractNum cTAbstractNum;\n    Map<BigInteger, CTAbstractNum> cache = new HashMap<BigInteger, CTAbstractNum>();\n    Map<BigInteger, CTAbstractNum> ret = new HashMap<BigInteger, CTAbstractNum>();\n    for (XWPFNum xwpfNum : nums) {\n        BigInteger mergeNumId = xwpfNum.getCTNum().getNumId();\n        cTAbstractNum = cache.get(xwpfNum.getCTNum().getAbstractNumId().getVal());\n        if (null == cTAbstractNum) {\n            xwpfAbstractNum = numberingMerge.getAbstractNum(xwpfNum.getCTNum().getAbstractNumId().getVal());\n            if (null == xwpfAbstractNum) {\n                logger.warn(\"cannot find cTAbstractNum by XWPFNum.\");\n                continue;\n            }\n            cTAbstractNum = xwpfAbstractNum.getCTAbstractNum();\n            // cTAbstractNum.setAbstractNumId(wrapper.getNextAbstractNumID());\n            if (cTAbstractNum.isSetNsid())\n                cTAbstractNum.unsetNsid();\n\n            if (cTAbstractNum.isSetTmpl())\n                cTAbstractNum.unsetTmpl();\n\n            cache.put(xwpfNum.getCTNum().getAbstractNumId().getVal(), cTAbstractNum);\n        }\n        ret.put(mergeNumId, cTAbstractNum);\n    }\n    long nextId = wrapper.getNextAbstractNumID().longValue();\n    Set<CTAbstractNum> hashSet = new HashSet<>(ret.values());\n    for (CTAbstractNum abnum : hashSet) {\n        abnum.setAbstractNumId(BigInteger.valueOf(nextId++));\n    }\n    final XWPFNumbering finalNumbering = numbering;\n    ret.forEach((mergeNumId, abnum) -> {\n        BigInteger numID = finalNumbering.addNum(finalNumbering.addAbstractNum(new XWPFAbstractNum(abnum)));\n        numIdsMap.put(mergeNumId.toString(), numID.toString());\n    });\n    return numIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderCell",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getParagraphArray",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderCell" ],
    "fullMethods" : [ "public static void renderCell(XWPFTableCell cell, CellRenderData data, CellStyle defaultCellStyle, Style defaultTextStyle) throws Exception {\n    if (null == data)\n        return;\n\n    StyleUtils.styleTableCell(cell, defaultCellStyle);\n    StyleUtils.styleTableCell(cell, data.getCellStyle());\n    List<ParagraphStyle> defaultParaStyles = new ArrayList<>();\n    if (null != defaultTextStyle) {\n        defaultParaStyles.add(ParagraphStyle.builder().withDefaultTextStyle(defaultTextStyle).build());\n    }\n    if (null != defaultCellStyle) {\n        defaultParaStyles.add(defaultCellStyle.getDefaultParagraphStyle());\n    }\n    if (null != data.getCellStyle()) {\n        defaultParaStyles.add(data.getCellStyle().getDefaultParagraphStyle());\n    }\n    List<ParagraphRenderData> contents = data.getParagraphs();\n    if ((null != contents) && (!contents.isEmpty())) {\n        BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(cell);\n        XWPFParagraph placeHolder = cell.getParagraphArray(0);\n        if (null == placeHolder)\n            placeHolder = cell.addParagraph();\n\n        for (ParagraphRenderData item : contents) {\n            XWPFParagraph paragraph = bodyContainer.insertNewParagraph(placeHolder.getCTP().newCursor());\n            ParagraphRenderPolicy.Helper.renderParagraph(paragraph.createRun(), item, defaultParaStyles);\n        }\n        List<XWPFParagraph> paragraphs = cell.getParagraphs();\n        int pos = paragraphs.indexOf(placeHolder);\n        if ((-1) != pos)\n            cell.removeParagraph(pos);\n\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getParagraphArray",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        int templateColIndex = getColIndex(tagCell);\n        if ((null == data) || ((data instanceof Boolean) && (!((Boolean) (data))))) {\n            // table.removeRow(templateRowIndex);\n            // tagCell.setText(\"_delete_\");\n            run.setText(\"_delete_\", 0);\n            CTTcPr tcPr = TableTools.getTcPr(tagCell);\n            CTVMerge vMerge = tcPr.getVMerge();\n            System.out.println(null == vMerge ? null : vMerge.getVal());\n            if ((null != vMerge) && vMerge.getVal().equals(STMerge.RESTART)) {\n                XWPFTableRow row = table.getRow(templateRowIndex + 1);\n                int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n                XWPFTableCell actualCell = row.getCell(actualInsertPosition);\n                System.out.println(actualCell.getCTTc());\n                actualCell.getParagraphArray(0).createRun().setText(\"_delete_\", 0);\n            }\n        } else {\n            run.setText(\"\", 0);\n        }\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.SVGConvertor.warning",
    "thirdPartyMethod" : "org.apache.batik.transcoder.TranscoderException.getMessage",
    "thirdPartyPackage" : "org.apache.batik.transcoder",
    "path" : [ "com.deepoove.poi.util.SVGConvertor.warning" ],
    "fullMethods" : [ "@Override\npublic void warning(TranscoderException ex) throws TranscoderException {\n    logger.warn(\"WARNING: \" + ex.getMessage());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.addSeries",
    "thirdPartyMethod" : "org.apache.poi.xddf.usermodel.chart.XDDFChartData.Series.<init>",
    "thirdPartyPackage" : "org.apache.poi.xddf.usermodel.chart.XDDFChartData",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.addSeries", "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.<init>" ],
    "fullMethods" : [ "@Override\npublic XDDFChartData.Series addSeries(XDDFDataSource<?> category, XDDFNumericalDataSource<? extends Number> values) {\n    final long index = ++this.seriesNum;\n    final CTPieSer ctSer = this.chart.addNewSer();\n    ctSer.addNewCat();\n    ctSer.addNewVal();\n    ctSer.addNewIdx().setVal(index);\n    ctSer.addNewOrder().setVal(index);\n    final Series added = new Series(ctSer, category, values);\n    this.series.add(added);\n    return added;\n}", "protected Series(CTPieSer series, XDDFDataSource<?> category, XDDFNumericalDataSource<? extends Number> values) {\n    super(category, values);\n    this.series = series;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>",
    "thirdPartyMethod" : "org.apache.poi.xddf.usermodel.chart.XDDFChartData.Series.<init>",
    "thirdPartyPackage" : "org.apache.poi.xddf.usermodel.chart.XDDFChartData",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>", "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.<init>" ],
    "fullMethods" : [ "public XDDFOfPieChartData(XDDFChart parent, CTOfPieChart chart) {\n    super(parent);\n    this.chart = chart;\n    this.seriesNum = parent.getChartSeries().size();\n    for (CTPieSer series : chart.getSerList()) {\n        this.series.add(new Series(series, series.getCat(), series.getVal()));\n    }\n}", "protected Series(CTPieSer series, XDDFDataSource<?> category, XDDFNumericalDataSource<? extends Number> values) {\n    super(category, values);\n    this.series = series;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblBorders.addNewLeft",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements",
    "thirdPartyMethod" : "org.apache.commons.lang3.ClassUtils.getShortClassName",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements", "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns", "com.deepoove.poi.resolver.TemplateResolver.parseTemplateFactory" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveBodyElements(List<IBodyElement> bodyElements) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (null == bodyElements)\n        return metaTemplates;\n\n    // current iterable templates state\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    for (IBodyElement element : bodyElements) {\n        if (element == null)\n            continue;\n\n        if (element.getElementType() == BodyElementType.PARAGRAPH) {\n            resolveParagraph(((XWPFParagraph) (element)), metaTemplates, stack);\n        } else if (element.getElementType() == BodyElementType.TABLE) {\n            XWPFTable table = ((XWPFTable) (element));\n            List<XWPFTableRow> rows = table.getRows();\n            if (null == rows)\n                continue;\n\n            for (XWPFTableRow row : rows) {\n                resolveTableRow(row, metaTemplates, stack);\n            }\n        } else if ((element.getElementType() == BodyElementType.CONTENTCONTROL) && (element instanceof XWPFStructuredDocumentTag)) {\n            XWPFStructuredDocumentTag sdt = ((XWPFStructuredDocumentTag) (element));\n            addNewMeta(metaTemplates, stack, resolveSDTElements(sdt.getContent()));\n        }\n    }\n    checkStack(stack);\n    return metaTemplates;\n}", "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}", "ElementTemplate parseTemplateFactory(String text, Object obj, XWPFRun run) {\n    if (null == text)\n        return null;\n\n    ElementTemplate elementTemplate = null;\n    if (templatePattern.matcher(text).matches()) {\n        String shortClassName = ClassUtils.getShortClassName(obj.getClass());\n        String tag = gramerPattern.matcher(text).replaceAll(\"\").trim();\n        if (obj.getClass() == XWPFRun.class) {\n            elementTemplate = ((RunTemplate) (elementTemplateFactory.createRunTemplate(config, tag, ((XWPFRun) (obj)))));\n        } else if (obj.getClass() == XWPFPicture.class) {\n            elementTemplate = ((PictureTemplate) (elementTemplateFactory.createPicureTemplate(config, tag, ((XWPFPicture) (obj)))));\n        } else if (obj.getClass() == CTPictWrapper.class) {\n            elementTemplate = ((PictImageTemplate) (elementTemplateFactory.createPictImageTemplate(config, tag, ((CTPictWrapper) (obj)), run)));\n        } else if (obj instanceof XWPFChart) {\n            elementTemplate = ((ChartTemplate) (elementTemplateFactory.createChartTemplate(config, tag, ((XWPFChart) (obj)), run)));\n        }\n        if (null != elementTemplate) {\n            logger.debug(\"Resolve where text: {}, and create {} for {}\", text, ClassUtils.getShortClassName(elementTemplate.getClass()), shortClassName);\n        }\n    }\n    return elementTemplate;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns",
    "thirdPartyMethod" : "org.apache.commons.lang3.ClassUtils.getShortClassName",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns", "com.deepoove.poi.resolver.TemplateResolver.parseTemplateFactory" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveXWPFRuns(List<XWPFRun> runs) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (runs == null)\n        return metaTemplates;\n\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    resolveXWPFRuns(runs, metaTemplates, stack);\n    checkStack(stack);\n    return metaTemplates;\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}", "ElementTemplate parseTemplateFactory(String text, Object obj, XWPFRun run) {\n    if (null == text)\n        return null;\n\n    ElementTemplate elementTemplate = null;\n    if (templatePattern.matcher(text).matches()) {\n        String shortClassName = ClassUtils.getShortClassName(obj.getClass());\n        String tag = gramerPattern.matcher(text).replaceAll(\"\").trim();\n        if (obj.getClass() == XWPFRun.class) {\n            elementTemplate = ((RunTemplate) (elementTemplateFactory.createRunTemplate(config, tag, ((XWPFRun) (obj)))));\n        } else if (obj.getClass() == XWPFPicture.class) {\n            elementTemplate = ((PictureTemplate) (elementTemplateFactory.createPicureTemplate(config, tag, ((XWPFPicture) (obj)))));\n        } else if (obj.getClass() == CTPictWrapper.class) {\n            elementTemplate = ((PictImageTemplate) (elementTemplateFactory.createPictImageTemplate(config, tag, ((CTPictWrapper) (obj)), run)));\n        } else if (obj instanceof XWPFChart) {\n            elementTemplate = ((ChartTemplate) (elementTemplateFactory.createChartTemplate(config, tag, ((XWPFChart) (obj)), run)));\n        }\n        if (null != elementTemplate) {\n            logger.debug(\"Resolve where text: {}, and create {} for {}\", text, ClassUtils.getShortClassName(elementTemplate.getClass()), shortClassName);\n        }\n    }\n    return elementTemplate;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.DelegatePolicy.invoke",
    "thirdPartyMethod" : "org.apache.commons.lang3.ClassUtils.getShortClassName",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.render.processor.DelegatePolicy.invoke" ],
    "fullMethods" : [ "public static void invoke(RenderPolicy policy, ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    Objects.requireNonNull(policy, (\"Cannot find render policy: [\" + eleTemplate.getTagName()) + \"]\");\n    Object model = data;\n    List<PreRenderDataCastor> preRenderDataCastors = template.getConfig().getPreRenderDataCastors();\n    if (null != preRenderDataCastors) {\n        for (PreRenderDataCastor preRenderDataCastor : preRenderDataCastors) {\n            model = preRenderDataCastor.preCast(policy, model);\n        }\n    }\n    LOGGER.info(\"Start render Template {}, Sign:{}, policy:{}\", eleTemplate, logChar(eleTemplate.getSign()), ClassUtils.getShortClassName(policy.getClass()));\n    policy.render(eleTemplate, model, template);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph",
    "thirdPartyMethod" : "org.apache.commons.lang3.ClassUtils.getShortClassName",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns", "com.deepoove.poi.resolver.TemplateResolver.parseTemplateFactory" ],
    "fullMethods" : [ "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}", "ElementTemplate parseTemplateFactory(String text, Object obj, XWPFRun run) {\n    if (null == text)\n        return null;\n\n    ElementTemplate elementTemplate = null;\n    if (templatePattern.matcher(text).matches()) {\n        String shortClassName = ClassUtils.getShortClassName(obj.getClass());\n        String tag = gramerPattern.matcher(text).replaceAll(\"\").trim();\n        if (obj.getClass() == XWPFRun.class) {\n            elementTemplate = ((RunTemplate) (elementTemplateFactory.createRunTemplate(config, tag, ((XWPFRun) (obj)))));\n        } else if (obj.getClass() == XWPFPicture.class) {\n            elementTemplate = ((PictureTemplate) (elementTemplateFactory.createPicureTemplate(config, tag, ((XWPFPicture) (obj)))));\n        } else if (obj.getClass() == CTPictWrapper.class) {\n            elementTemplate = ((PictImageTemplate) (elementTemplateFactory.createPictImageTemplate(config, tag, ((CTPictWrapper) (obj)), run)));\n        } else if (obj instanceof XWPFChart) {\n            elementTemplate = ((ChartTemplate) (elementTemplateFactory.createChartTemplate(config, tag, ((XWPFChart) (obj)), run)));\n        }\n        if (null != elementTemplate) {\n            logger.debug(\"Resolve where text: {}, and create {} for {}\", text, ClassUtils.getShortClassName(elementTemplate.getClass()), shortClassName);\n        }\n    }\n    return elementTemplate;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.exception.ReflectionException.<init>",
    "thirdPartyMethod" : "org.apache.commons.lang3.ClassUtils.getShortClassName",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.exception.ReflectionException.<init>" ],
    "fullMethods" : [ "public ReflectionException(String name, Class<?> clazz, Exception e) {\n    this(((\"Error Reflect \" + name) + \"from class \") + ClassUtils.getShortClassName(clazz), e);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ReflectionUtils.getValue",
    "thirdPartyMethod" : "org.apache.commons.lang3.ClassUtils.getShortClassName",
    "thirdPartyPackage" : "org.apache.commons.lang3",
    "path" : [ "com.deepoove.poi.util.ReflectionUtils.getValue" ],
    "fullMethods" : [ "public static Object getValue(String fieldName, Object obj) {\n    Objects.requireNonNull(obj, \"Class must not be null\");\n    Objects.requireNonNull(fieldName, \"Name must not be null\");\n    Field field = findField(obj.getClass(), fieldName);\n    if (null == field) {\n        throw new ReflectionException(((\"No Such field \" + fieldName) + \" from class\") + ClassUtils.getShortClassName(obj.getClass()));\n    }\n    try {\n        field.setAccessible(true);\n        return field.get(obj);\n    } catch (Exception e) {\n        throw new ReflectionException(fieldName, obj.getClass(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFonts.setAscii",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId" ],
    "fullMethods" : [ "public BigInteger addNewMultiLevelNumberingId(NumberingFormat... numFmts) {\n    XWPFNumbering numbering = this.getNumbering();\n    if (null == numbering) {\n        numbering = this.createNumbering();\n    }\n    XWPFNumberingWrapper numberingWrapper = new XWPFNumberingWrapper(numbering);\n    CTAbstractNum cTAbstractNum = CTAbstractNum.Factory.newInstance();\n    // if we have an existing document, we must determine the next\n    // free number first.\n    cTAbstractNum.setAbstractNumId(numberingWrapper.getNextAbstractNumID());\n    // CTMultiLevelType addNewMultiLevelType = cTAbstractNum.addNewMultiLevelType();\n    // addNewMultiLevelType.setVal(STMultiLevelType.HYBRID_MULTILEVEL);\n    for (int i = 0; i < numFmts.length; i++) {\n        NumberingFormat numFmt = numFmts[i];\n        CTLvl cTLvl = cTAbstractNum.addNewLvl();\n        CTPPrBase ppr = (cTLvl.isSetPPr()) ? cTLvl.getPPr() : cTLvl.addNewPPr();\n        CTInd ind = (ppr.isSetInd()) ? ppr.getInd() : ppr.addNewInd();\n        ind.setLeft(BigInteger.valueOf(UnitUtils.cm2Twips(0.74F) * i));\n        Enum fmt = STNumberFormat.Enum.forInt(numFmt.getNumFmt());\n        String val = numFmt.getLvlText();\n        cTLvl.addNewNumFmt().setVal(fmt);\n        cTLvl.addNewLvlText().setVal(val);\n        cTLvl.addNewStart().setVal(BigInteger.valueOf(1));\n        cTLvl.setIlvl(BigInteger.valueOf(i));\n        if (fmt == STNumberFormat.BULLET) {\n            cTLvl.addNewLvlJc().setVal(STJc.LEFT);\n            CTRPr addNewRPr = cTLvl.addNewRPr();\n            CTFonts ctFonts = addNewRPr.addNewRFonts();\n            ctFonts.setAscii(\"Wingdings\");\n            ctFonts.setHAnsi(\"Wingdings\");\n            ctFonts.setHint(STHint.DEFAULT);\n        }\n    }\n    XWPFAbstractNum abstractNum = new XWPFAbstractNum(cTAbstractNum);\n    BigInteger abstractNumID = numbering.addAbstractNum(abstractNum);\n    return numbering.addNum(abstractNumID);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFonts.setAscii",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.removeBodyElement",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTBody.removeSdt",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.removeBodyElement" ],
    "fullMethods" : [ "@Override\npublic boolean removeBodyElement(int pos) {\n    if ((pos >= 0) && (pos < this.bodyElements.size())) {\n        BodyElementType type = ((IBodyElement) (this.bodyElements.get(pos))).getElementType();\n        int paraPos;\n        if (type == BodyElementType.TABLE) {\n            paraPos = this.getTablePos(pos);\n            this.tables.remove(paraPos);\n            this.getDocument().getBody().removeTbl(paraPos);\n        }\n        if (type == BodyElementType.PARAGRAPH) {\n            paraPos = this.getParagraphPos(pos);\n            this.paragraphs.remove(paraPos);\n            this.getDocument().getBody().removeP(paraPos);\n        }\n        if (type == BodyElementType.CONTENTCONTROL) {\n            paraPos = getBodyElementSpecificPos(pos, contentControls);\n            this.contentControls.remove(paraPos);\n            this.getDocument().getBody().removeSdt(paraPos);\n        }\n        this.bodyElements.remove(pos);\n        return true;\n    } else {\n        return false;\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.SDTContentContext.createRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFHyperlinkRun.getCTHyperlink",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.SDTContentContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XWPFRun xwpfRun, IRunBody p) {\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink().copy())), ((CTR) (((XWPFHyperlinkRun) (xwpfRun)).getCTR().copy())), p);\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        return new XWPFFieldRun(((CTSimpleField) (((XWPFFieldRun) (xwpfRun)).getCTField().copy())), ((CTR) (((XWPFFieldRun) (xwpfRun)).getCTR().copy())), p);\n    } else {\n        return new XWPFRun(((CTR) (xwpfRun.getCTR().copy())), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.setAndUpdateRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFHyperlinkRun.getCTHyperlink",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.setAndUpdateRun" ],
    "fullMethods" : [ "public void setAndUpdateRun(XWPFRun xwpfRun, XWPFRun source, int insertPostionCursor) {\n    // body\n    // maybe need find correct position:rPos;\n    int rPos = 0;\n    List<XWPFRun> runs = getRuns();\n    if ((insertPostionCursor >= 0) && (insertPostionCursor <= runs.size())) {\n        // calculate the correct pos as our run/irun list contains\n        // hyperlinks\n        // and fields so it is different to the paragraph R array.\n        for (int i = 0; i < insertPostionCursor; i++) {\n            XWPFRun currRun = runs.get(i);\n            if (xwpfRun instanceof XWPFHyperlinkRun) {\n                if (currRun instanceof XWPFHyperlinkRun) {\n                    rPos++;\n                }\n            } else if (xwpfRun instanceof XWPFFieldRun) {\n                if (currRun instanceof XWPFFieldRun) {\n                    rPos++;\n                }\n            } else if (!((currRun instanceof XWPFHyperlinkRun) || (currRun instanceof XWPFFieldRun))) {\n                rPos++;\n            }\n        }\n    }\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        paragraph.getCTP().setHyperlinkArray(rPos, ((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink());\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        paragraph.getCTP().setFldSimpleArray(rPos, ((XWPFFieldRun) (xwpfRun)).getCTField());\n    } else {\n        paragraph.getCTP().setRArray(rPos, xwpfRun.getCTR());\n    }\n    // runs\n    for (int i = 0; i < runs.size(); i++) {\n        XWPFRun ele = runs.get(i);\n        if (ele == source) {\n            runs.set(i, xwpfRun);\n        }\n    }\n    // iruns\n    List<IRunElement> iruns = getIRuns();\n    for (int i = 0; i < iruns.size(); i++) {\n        IRunElement ele = iruns.get(i);\n        if (ele == source) {\n            iruns.set(i, xwpfRun);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.ParagraphContext.createRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFHyperlinkRun.getCTHyperlink",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.ParagraphContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XWPFRun xwpfRun, IRunBody p) {\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink().copy())), ((CTR) (((XWPFHyperlinkRun) (xwpfRun)).getCTR().copy())), p);\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        return new XWPFFieldRun(((CTSimpleField) (((XWPFFieldRun) (xwpfRun)).getCTField().copy())), ((CTR) (((XWPFFieldRun) (xwpfRun)).getCTR().copy())), p);\n    } else {\n        return new XWPFRun(((CTR) (xwpfRun.getCTR().copy())), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFHyperlinkRun.getCTHyperlink",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.<init>" ],
    "fullMethods" : [ "public XWPFParagraphWrapper(XWPFParagraph paragraph) {\n    this.paragraph = paragraph;\n    // clean structure when have duplicate XWPFHyperlinkRun\n    // because wrong structure lead to wrong position\n    List<XWPFRun> runs = getRuns();\n    List<IRunElement> iRuns = getIRuns();\n    List<CTHyperlink> caches = new ArrayList<>();\n    Iterator<XWPFRun> iterator = runs.iterator();\n    while (iterator.hasNext()) {\n        XWPFRun next = iterator.next();\n        if (next instanceof XWPFHyperlinkRun) {\n            CTHyperlink ctHyperlink = ((XWPFHyperlinkRun) (next)).getCTHyperlink();\n            if (caches.contains(ctHyperlink)) {\n                iterator.remove();\n                iRuns.remove(next);\n            } else {\n                caches.add(ctHyperlink);\n            }\n        }\n    } \n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.toc.TOCRenderPolicy.render",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTSimpleField.setDirty",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.toc.TOCRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    XWPFRun run = ((RunTemplate) (eleTemplate)).getRun();\n    run.setText(\"\", 0);\n    XWPFParagraph tocPara = ((XWPFParagraph) (run.getParent()));\n    XWPFFieldRun fieldRun = tocPara.insertNewFieldRun(0);\n    CTSimpleField toc = fieldRun.getCTField();\n    toc.setInstr(\"TOC \\\\o\");\n    toc.setDirty(XWPFOnOff.ON);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPBdr.isSetTop",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPBdr.isSetTop",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyle(XWPFParagraph paragraph) {\n    if (null == paragraph)\n        return null;\n\n    Builder builder = ParagraphStyle.builder();\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    if (paragraph.isWordWrapped()) {\n        builder.withAllowWordBreak(true);\n    }\n    if (pr.isSetPBdr()) {\n        CTPBdr ct = pr.getPBdr();\n        if (ct.isSetLeft()) {\n            builder.withLeftBorder(retriveBorderStyle(ct.getLeft()));\n        }\n        if (ct.isSetTop()) {\n            builder.withTopBorder(retriveBorderStyle(ct.getTop()));\n        }\n        if (ct.isSetRight()) {\n            builder.withRightBorder(retriveBorderStyle(ct.getRight()));\n        }\n        if (ct.isSetBottom()) {\n            builder.withBottomBorder(retriveBorderStyle(ct.getBottom()));\n        }\n    }\n    if (pr.isSetShd()) {\n        CTShd shd = pr.getShd();\n        builder.withShadingPattern(XWPFShadingPattern.valueOf(shd.getVal().intValue()));\n        if (shd.isSetFill())\n            builder.withBackgroundColor(shd.xgetFill().getStringValue());\n\n    }\n    builder.withAlign(paragraph.getAlignment());\n    int spacingBeforeLines = paragraph.getSpacingBeforeLines();\n    if ((-1) != spacingBeforeLines) {\n        builder.withSpacingBeforeLines(spacingBeforeLines / 100.0F);\n    }\n    int spacingAfterLines = paragraph.getSpacingAfterLines();\n    if ((-1) != spacingAfterLines) {\n        builder.withSpacingAfterLines(spacingAfterLines / 100.0F);\n    }\n    int spacingBefore = paragraph.getSpacingBefore();\n    if ((-1) != spacingBefore) {\n        builder.withSpacingBefore(UnitUtils.twips2Point(spacingBefore));\n    }\n    int spacingAfter = paragraph.getSpacingAfter();\n    if ((-1) != spacingAfter) {\n        builder.withSpacingAfter(UnitUtils.twips2Point(spacingAfter));\n    }\n    double spacingBetween = paragraph.getSpacingBetween();\n    if ((-1) != spacingBetween) {\n        builder.withSpacing(spacingBetween);\n        builder.withSpacingRule(paragraph.getSpacingLineRule());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTTx.isSetStrRef",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setTitle", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setCTTitle" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartMultiSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    List<XDDFChartData> chartSeries = chart.getChartSeries();\n    validate(chartSeries, data);\n    int totalSeriesCount = ensureSeriesCount(chart, chartSeries);\n    int valueCol = 1;\n    List<SeriesRenderData> usedSeriesDatas = new ArrayList<>();\n    for (XDDFChartData chartData : chartSeries) {\n        int orignSize = chartData.getSeriesCount();\n        List<SeriesRenderData> currentSeriesData = null;\n        if (chartSeries.size() <= 1) {\n            // ignore combo type\n            currentSeriesData = data.getSeriesDatas();\n        } else {\n            currentSeriesData = obtainSeriesData(chartData.getClass(), data.getSeriesDatas());\n        }\n        usedSeriesDatas.addAll(currentSeriesData);\n        int currentSeriesSize = currentSeriesData.size();\n        XDDFDataSource<?> categoriesData = null;\n        if (chartData instanceof XDDFScatterChartData) {\n            categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n        } else {\n            categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n        }\n        for (int i = 0; i < currentSeriesSize; i++) {\n            XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, currentSeriesData.get(i).getValues(), valueCol);\n            XDDFChartData.Series currentSeries = null;\n            if (i < orignSize) {\n                currentSeries = chartData.getSeries(i);\n                valuesData.setFormatCode(currentSeries.getValuesData().getFormatCode());\n                currentSeries.replaceData(categoriesData, valuesData);\n            } else {\n                // add series, should copy series with style\n                currentSeries = chartData.addSeries(categoriesData, valuesData);\n                processNewSeries(chartData, currentSeries);\n            }\n            String name = currentSeriesData.get(i).getName();\n            currentSeries.setTitle(name, chart.setSheetTitle(name, valueCol));\n            valueCol++;\n        }\n        // clear extra series\n        removeExtraSeries(chartData, orignSize, currentSeriesSize);\n    }\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    updateCTTable(sheet, usedSeriesDatas);\n    removeExtraSheetCell(sheet, data.getCategories().length, totalSeriesCount, usedSeriesDatas.size());\n    for (XDDFChartData chartData : chartSeries) {\n        plot(chart, chartData);\n    }\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "protected void setTitle(XWPFChart chart, String title) {\n    if ((null == title) && chart.getCTChart().isSetTitle()) {\n        chart.getCTChart().unsetTitle();\n        return;\n    }\n    CTTitle ctTitle = chart.getCTChart().getTitle();\n    boolean isSet = setCTTitle(ctTitle, title);\n    if (!isSet) {\n        chart.setTitleText(title);\n        chart.setTitleOverlay(false);\n    }\n}", "private boolean setCTTitle(CTTitle ctTitle, String title) {\n    boolean isSet = false;\n    if (null != ctTitle) {\n        if (!ctTitle.isSetTx()) {\n            ctTitle.addNewTx();\n        }\n        CTTx tx = ctTitle.getTx();\n        if (tx.isSetStrRef()) {\n            tx.unsetStrRef();\n        }\n        if (!tx.isSetRich()) {\n            tx.addNewRich();\n        }\n        CTTextBody body = tx.getRich();\n        if (body.sizeOfPArray() > 0) {\n            // remove all but first paragraph\n            for (int i = body.sizeOfPArray() - 1; i > 0; i--) {\n                body.removeP(i);\n            }\n            CTTextParagraph pArray = body.getPArray(0);\n            if (pArray.sizeOfRArray() > 0) {\n                for (int i = pArray.sizeOfRArray() - 1; i > 0; i--) {\n                    pArray.removeR(i);\n                }\n                CTRegularTextRun rArray = pArray.getRArray(0);\n                rArray.setT(title);\n                isSet = true;\n            }\n        }\n    }\n    return isSet;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTTx.isSetStrRef",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setTitle", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setCTTitle" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartSingleSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    XDDFChartData pie = ChartUtils.getChartSeries(chart).get(0);\n    SeriesRenderData seriesDatas = data.getSeriesData();\n    XDDFDataSource<?> categoriesData = null;\n    if (pie instanceof XDDFScatterChartData) {\n        categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n    } else {\n        categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n    }\n    XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, seriesDatas.getValues(), 1);\n    XDDFChartData.Series currentSeries = pie.getSeries(0);\n    currentSeries.replaceData(categoriesData, valuesData);\n    currentSeries.setTitle(seriesDatas.getName(), chart.setSheetTitle(seriesDatas.getName(), 1));\n    updateCTTable(chart.getWorkbook().getSheetAt(0), Arrays.asList(seriesDatas));\n    plot(chart, pie);\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "protected void setTitle(XWPFChart chart, String title) {\n    if ((null == title) && chart.getCTChart().isSetTitle()) {\n        chart.getCTChart().unsetTitle();\n        return;\n    }\n    CTTitle ctTitle = chart.getCTChart().getTitle();\n    boolean isSet = setCTTitle(ctTitle, title);\n    if (!isSet) {\n        chart.setTitleText(title);\n        chart.setTitleOverlay(false);\n    }\n}", "private boolean setCTTitle(CTTitle ctTitle, String title) {\n    boolean isSet = false;\n    if (null != ctTitle) {\n        if (!ctTitle.isSetTx()) {\n            ctTitle.addNewTx();\n        }\n        CTTx tx = ctTitle.getTx();\n        if (tx.isSetStrRef()) {\n            tx.unsetStrRef();\n        }\n        if (!tx.isSetRich()) {\n            tx.addNewRich();\n        }\n        CTTextBody body = tx.getRich();\n        if (body.sizeOfPArray() > 0) {\n            // remove all but first paragraph\n            for (int i = body.sizeOfPArray() - 1; i > 0; i--) {\n                body.removeP(i);\n            }\n            CTTextParagraph pArray = body.getPArray(0);\n            if (pArray.sizeOfRArray() > 0) {\n                for (int i = pArray.sizeOfRArray() - 1; i > 0; i--) {\n                    pArray.removeR(i);\n                }\n                CTRegularTextRun rArray = pArray.getRArray(0);\n                rArray.setT(title);\n                isSet = true;\n            }\n        }\n    }\n    return isSet;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableCell",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTcPr.getShd",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableCell" ],
    "fullMethods" : [ "/**\n * set cell style\n *\n * @param cell\n * @param cellStyle\n */\npublic static void styleTableCell(XWPFTableCell cell, CellStyle cellStyle) {\n    if ((null == cell) || (null == cellStyle))\n        return;\n\n    if (null != cellStyle.getVertAlign()) {\n        cell.setVerticalAlignment(cellStyle.getVertAlign());\n    }\n    if (null != cellStyle.getBackgroundColor()) {\n        CTTc ctTc = cell.getCTTc();\n        CTTcPr pr = (ctTc.isSetTcPr()) ? ctTc.getTcPr() : ctTc.addNewTcPr();\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = cellStyle.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(cellStyle.getBackgroundColor());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderCell",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.removeParagraph",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderCell" ],
    "fullMethods" : [ "public static void renderCell(XWPFTableCell cell, CellRenderData data, CellStyle defaultCellStyle, Style defaultTextStyle) throws Exception {\n    if (null == data)\n        return;\n\n    StyleUtils.styleTableCell(cell, defaultCellStyle);\n    StyleUtils.styleTableCell(cell, data.getCellStyle());\n    List<ParagraphStyle> defaultParaStyles = new ArrayList<>();\n    if (null != defaultTextStyle) {\n        defaultParaStyles.add(ParagraphStyle.builder().withDefaultTextStyle(defaultTextStyle).build());\n    }\n    if (null != defaultCellStyle) {\n        defaultParaStyles.add(defaultCellStyle.getDefaultParagraphStyle());\n    }\n    if (null != data.getCellStyle()) {\n        defaultParaStyles.add(data.getCellStyle().getDefaultParagraphStyle());\n    }\n    List<ParagraphRenderData> contents = data.getParagraphs();\n    if ((null != contents) && (!contents.isEmpty())) {\n        BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(cell);\n        XWPFParagraph placeHolder = cell.getParagraphArray(0);\n        if (null == placeHolder)\n            placeHolder = cell.addParagraph();\n\n        for (ParagraphRenderData item : contents) {\n            XWPFParagraph paragraph = bodyContainer.insertNewParagraph(placeHolder.getCTP().newCursor());\n            ParagraphRenderPolicy.Helper.renderParagraph(paragraph.createRun(), item, defaultParaStyles);\n        }\n        List<XWPFParagraph> paragraphs = cell.getParagraphs();\n        int pos = paragraphs.indexOf(placeHolder);\n        if ((-1) != pos)\n            cell.removeParagraph(pos);\n\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTag.getPart",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.IBody.getPart",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTag.getPart" ],
    "fullMethods" : [ "/**\n *\n * @return document part\n */\npublic POIXMLDocumentPart getPart() {\n    return part.getPart();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.isStrikeThrough",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun" ],
    "fullMethods" : [ "/**\n * set run style by other run\n *\n * @param dest\n * @param src\n */\npublic static void styleRun(XWPFRun dest, XWPFRun src) {\n    if ((null == dest) || (null == src))\n        return;\n\n    if (StringUtils.isNotEmpty(src.getStyle()))\n        dest.setStyle(src.getStyle());\n\n    if (Boolean.TRUE.equals(src.isBold()))\n        dest.setBold(src.isBold());\n\n    if (StringUtils.isNotBlank(src.getColor()))\n        dest.setColor(src.getColor());\n\n    if (0 != src.getCharacterSpacing())\n        dest.setCharacterSpacing(src.getCharacterSpacing());\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.ascii)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.ascii);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.eastAsia)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.eastAsia);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.hAnsi)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.hAnsi);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.cs)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.cs);\n\n    Double fontSize = src.getFontSizeAsDouble();\n    if (null != fontSize) {\n        dest.setFontSize(fontSize);\n    }\n    if (Boolean.TRUE.equals(src.isItalic()))\n        dest.setItalic(src.isItalic());\n\n    if (Boolean.TRUE.equals(src.isStrikeThrough()))\n        dest.setStrikeThrough(src.isStrikeThrough());\n\n    if (UnderlinePatterns.NONE != src.getUnderline())\n        dest.setUnderline(src.getUnderline());\n\n    if (null != src.getUnderlineColor())\n        dest.setUnderlineColor(src.getUnderlineColor());\n\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveStyle",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.isStrikeThrough",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveStyle" ],
    "fullMethods" : [ "public static Style retriveStyle(XWPFRun run) {\n    if (null == run)\n        return null;\n\n    StyleBuilder builder = Style.builder().buildColor(run.getColor()).buildFontFamily(run.getFontFamily(FontCharRange.eastAsia)).buildWesternFontFamily(run.getFontFamily(FontCharRange.ascii));\n    if (null != run.getFontSizeAsDouble())\n        builder.buildFontSize(run.getFontSizeAsDouble());\n\n    if (run.isBold())\n        builder.buildBold();\n\n    if (run.isItalic())\n        builder.buildItalic();\n\n    if (run.isStrikeThrough())\n        builder.buildStrike();\n\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFComment.setDate",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment" ],
    "fullMethods" : [ "public static void renderComment(XWPFRun run, CommentRenderData data) throws Exception {\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper parentContext = new XWPFParagraphWrapper(paragraph);\n    BigInteger cId = BigInteger.ZERO;\n    CommentContent commentContent = data.getCommentContent();\n    if (null != commentContent) {\n        XWPFComments comments = ((NiceXWPFDocument) (paragraph.getDocument())).createComments();\n        XWPFComment newComment = comments.createComment(NextIDUtils.getCommentMaxId(comments).add(BigInteger.ONE));\n        newComment.setAuthor(commentContent.getAuthor());\n        newComment.setDate(commentContent.getDate());\n        newComment.setInitials(commentContent.getInitials());\n        renderDocument(newComment.createParagraph().createRun(), commentContent.getContent());\n        cId = newComment.getCtComment().getId();\n        parentContext.insertNewCommentRangeStart(run, cId);\n    }\n    renderParagraph(run, Paragraphs.of().addList(data.getContents()).create());\n    if (null != commentContent) {\n        parentContext.insertNewCommentRangeEnd(run, cId);\n        XWPFRun newRun = parentContext.insertNewRun(ParagraphUtils.getRunPos(run));\n        newRun.getCTR().addNewCommentReference().setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.apache.xmlbeans.XmlCursor.hasNextToken",
    "thirdPartyPackage" : "org.apache.xmlbeans",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeNamespaces", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.toStartCursor" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "protected void mergeNamespaces(NiceXWPFDocument source, NiceXWPFDocument docMerge) {\n    CTDocument1 document = source.getDocument();\n    XmlCursor newCursor = document.newCursor();\n    if (toStartCursor(newCursor)) {\n        CTDocument1 documentMerge = docMerge.getDocument();\n        XmlCursor mergeCursor = documentMerge.newCursor();\n        if (toStartCursor(mergeCursor)) {\n            Map<String, String> addToThis = new HashMap<>();\n            mergeCursor.getAllNamespaces(addToThis);\n            addToThis.forEach(newCursor::insertNamespace);\n        }\n        mergeCursor.dispose();\n    }\n    newCursor.dispose();\n}", "protected boolean toStartCursor(XmlCursor newCursor) {\n    do {\n        if (newCursor.currentTokenType().isStart()) {\n            return true;\n        } else if (newCursor.hasNextToken()) {\n            newCursor.toNextToken();\n        } else\n            return false;\n\n    } while (true );\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getBody",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        for (int i = rowSize - 1; i >= 0; i--) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            String text = row.getCell(actualInsertPosition).getText();\n            if (\"_delete_\".equals(text)) {\n                table.removeRow(i);\n            } else {\n                removeCell(row, actualInsertPosition);\n            }\n        }\n    } catch (Exception e) {\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFRunWrapper.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getBody",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFRunWrapper.<init>" ],
    "fullMethods" : [ "@SuppressWarnings(\"deprecation\")\npublic XWPFRunWrapper(XWPFRun run, boolean isParse) {\n    this.run = run;\n    if (!isParse)\n        return;\n\n    CTR r = run.getCTR();\n    XmlObject[] xmlObjects = r.selectPath(XPATH_TXBX_TXBXCONTENT);\n    if ((xmlObjects != null) && (xmlObjects.length >= 1)) {\n        try {\n            CTTxbxContent ctTxbxContent = CTTxbxContent.Factory.parse(xmlObjects[0].xmlText());\n            wpstxbx = new XWPFTextboxContent(ctTxbxContent, run, run.getParagraph().getBody(), xmlObjects[0]);\n        } catch (XmlException e) {\n            // no-op\n        }\n    }\n    xmlObjects = r.selectPath(XPATH_TEXTBOX_TXBXCONTENT);\n    if ((xmlObjects != null) && (xmlObjects.length >= 1)) {\n        try {\n            CTTxbxContent ctTxbxContent = CTTxbxContent.Factory.parse(xmlObjects[0].xmlText());\n            vtextbox = new XWPFTextboxContent(ctTxbxContent, run, run.getParagraph().getBody(), xmlObjects[0]);\n        } catch (XmlException e) {\n            // no-op\n        }\n    }\n    CTPicture ctPicture = (CollectionUtils.isNotEmpty(r.getPictList())) ? r.getPictArray(0) : null;\n    if (null != ctPicture) {\n        xmlObjects = ctPicture.selectPath(XPATH_PICT_TEXTBOX_TXBXCONTENT);\n        if ((xmlObjects != null) && (xmlObjects.length >= 1)) {\n            try {\n                CTTxbxContent ctTxbxContent = null;\n                if (xmlObjects[0] instanceof CTTxbxContent) {\n                    ctTxbxContent = ((CTTxbxContent) (xmlObjects[0]));\n                } else {\n                    ctTxbxContent = CTTxbxContent.Factory.parse(xmlObjects[0].xmlText());\n                }\n                shapetxbx = new XWPFTextboxContent(ctTxbxContent, run, run.getParagraph().getBody(), xmlObjects[0]);\n            } catch (XmlException e) {\n                // no-op\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getBody",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.getSDTs",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getBody",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.getSDTs" ],
    "fullMethods" : [ "public List<XWPFStructuredDocumentTag> getSDTs() {\n    if (null != sdts)\n        return sdts;\n\n    sdts = new ArrayList<>();\n    long count = paragraph.getIRuns().stream().filter(r -> r instanceof XWPFSDT).count();\n    if (0 == count)\n        return sdts;\n\n    CTP ctp = paragraph.getCTP();\n    XmlCursor c = ctp.newCursor();\n    try {\n        c.selectPath(\"child::*\");\n        while (c.toNextSelection()) {\n            XmlObject o = c.getObject();\n            if (o instanceof CTSdtBlock) {\n                XWPFStructuredDocumentTag cc = new XWPFStructuredDocumentTag(((CTSdtBlock) (o)), paragraph.getBody());\n                sdts.add(cc);\n            }\n            if (o instanceof CTSdtRun) {\n                XWPFStructuredDocumentTag cc = new XWPFStructuredDocumentTag(((CTSdtRun) (o)), paragraph.getBody());\n                sdts.add(cc);\n            }\n        } \n    } finally {\n        c.dispose();\n    }\n    return sdts;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.RenderContext.getContainer",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getBody",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.RenderContext.getContainer" ],
    "fullMethods" : [ "public IBody getContainer() {\n    // XWPFTableCellXWPFDocumentXWPFHeaderFooterXWPFAbstractFootnoteEndnote\n    return ((XWPFParagraph) (getRun().getParent())).getBody();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.DynamicTableRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getBody",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.DynamicTableRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(RenderContext<Object> context) throws Exception {\n    RunTemplate runTemplate = ((RunTemplate) (context.getEleTemplate()));\n    XWPFRun run = runTemplate.getRun();\n    run.setText(\"\", 0);\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell cell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = cell.getTableRow().getTable();\n        render(table, context.getData());\n    } catch (Exception e) {\n        throw new RenderException(\"Dynamic render table error:\" + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getBody",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getBody",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        if ((null != data) && (data instanceof Iterable)) {\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            XWPFTableRow templateRow = table.getRow(templateRowIndex);\n            int insertPosition = templateRowIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            boolean firstFlag = true;\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateRowIndex++;\n                XWPFTableRow nextRow = table.insertNewTableRow(insertPosition);\n                setTableRow(table, templateRow, insertPosition);\n                // double set row\n                XmlCursor newCursor = templateRow.getCtRow().newCursor();\n                newCursor.toPrevSibling();\n                XmlObject object = newCursor.getObject();\n                nextRow = new XWPFTableRow(((CTRow) (object)), table);\n                if (!firstFlag) {\n                    // update VMerge cells for non-first row\n                    List<XWPFTableCell> tableCells = nextRow.getTableCells();\n                    for (XWPFTableCell cell : tableCells) {\n                        CTTcPr tcPr = TableTools.getTcPr(cell);\n                        CTVMerge vMerge = tcPr.getVMerge();\n                        if (null == vMerge)\n                            continue;\n\n                        if (STMerge.RESTART == vMerge.getVal()) {\n                            vMerge.setVal(STMerge.CONTINUE);\n                        }\n                    }\n                } else {\n                    firstFlag = false;\n                }\n                setTableRow(table, nextRow, insertPosition);\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                List<XWPFTableCell> cells = nextRow.getTableCells();\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        table.removeRow(templateRowIndex);\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \" error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getBody",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    try {\n        RunTemplate runTemplate = cast2runTemplate(eleTemplate);\n        XWPFRun run = runTemplate.getRun();\n        checkTargetIsTable(run, (\"Processing [\" + runTemplate.getTagName()) + \"] failed, the target content is not a table\");\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        final XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n        // \n        int position = getRowIndex(tagCell.getTableRow());\n        List<XWPFTableRow> tempRows = getAllTemplateRow(table, position);\n        if ((null != data) && (data instanceof Iterable)) {\n            // \n            final XWPFTableRow firstTempRow = tempRows.get(0);\n            Iterator<?> dataIt = ((Iterable<?>) (data)).iterator();\n            boolean hasNextData = dataIt.hasNext();\n            int index = 0;\n            while (hasNextData) {\n                Object dt = dataIt.next();\n                hasNextData = dataIt.hasNext();\n                Iterator<XWPFTableRow> rowTempIt = tempRows.iterator();\n                boolean hasNextTempRow = rowTempIt.hasNext();\n                while (hasNextTempRow) {\n                    XWPFTableRow tempRow = rowTempIt.next();\n                    hasNextTempRow = rowTempIt.hasNext();\n                    if (!table.addRow(tempRow, position)) {\n                        throw new RenderException(\"\");\n                    }\n                    // \n                    XmlCursor newCursor = firstTempRow.getCtRow().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    XWPFTableRow newRow = new XWPFTableRow(((CTRow) (object)), table);\n                    newRow.getCtRow().set(object);\n                    setTableRow(table, newRow, position);\n                    List<XWPFTableCell> cells = newRow.getTableCells();\n                    RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(dt, EnvIterator.makeEnv(index, hasNextData || hasNextTempRow)));\n                    cells.forEach(tableCell -> {\n                        List<MetaTemplate> metaTemplates = resolver.resolveBodyElements(tableCell.getBodyElements());\n                        new DocumentProcessor(template, resolver, dataCompute).process(metaTemplates);\n                    });\n                    ++position;\n                } \n                ++index;\n            } \n        }\n        removeTableRow(table, position, tempRows.size());\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-row template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getBody",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        int templateColIndex = getColIndex(tagCell);\n        if ((null == data) || ((data instanceof Boolean) && (!((Boolean) (data))))) {\n            // table.removeRow(templateRowIndex);\n            // tagCell.setText(\"_delete_\");\n            run.setText(\"_delete_\", 0);\n            CTTcPr tcPr = TableTools.getTcPr(tagCell);\n            CTVMerge vMerge = tcPr.getVMerge();\n            System.out.println(null == vMerge ? null : vMerge.getVal());\n            if ((null != vMerge) && vMerge.getVal().equals(STMerge.RESTART)) {\n                XWPFTableRow row = table.getRow(templateRowIndex + 1);\n                int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n                XWPFTableCell actualCell = row.getCell(actualInsertPosition);\n                System.out.println(actualCell.getCTTc());\n                actualCell.getParagraphArray(0).createRun().setText(\"_delete_\", 0);\n            }\n        } else {\n            run.setText(\"\", 0);\n        }\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getSpacingLineRule",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyle(XWPFParagraph paragraph) {\n    if (null == paragraph)\n        return null;\n\n    Builder builder = ParagraphStyle.builder();\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    if (paragraph.isWordWrapped()) {\n        builder.withAllowWordBreak(true);\n    }\n    if (pr.isSetPBdr()) {\n        CTPBdr ct = pr.getPBdr();\n        if (ct.isSetLeft()) {\n            builder.withLeftBorder(retriveBorderStyle(ct.getLeft()));\n        }\n        if (ct.isSetTop()) {\n            builder.withTopBorder(retriveBorderStyle(ct.getTop()));\n        }\n        if (ct.isSetRight()) {\n            builder.withRightBorder(retriveBorderStyle(ct.getRight()));\n        }\n        if (ct.isSetBottom()) {\n            builder.withBottomBorder(retriveBorderStyle(ct.getBottom()));\n        }\n    }\n    if (pr.isSetShd()) {\n        CTShd shd = pr.getShd();\n        builder.withShadingPattern(XWPFShadingPattern.valueOf(shd.getVal().intValue()));\n        if (shd.isSetFill())\n            builder.withBackgroundColor(shd.xgetFill().getStringValue());\n\n    }\n    builder.withAlign(paragraph.getAlignment());\n    int spacingBeforeLines = paragraph.getSpacingBeforeLines();\n    if ((-1) != spacingBeforeLines) {\n        builder.withSpacingBeforeLines(spacingBeforeLines / 100.0F);\n    }\n    int spacingAfterLines = paragraph.getSpacingAfterLines();\n    if ((-1) != spacingAfterLines) {\n        builder.withSpacingAfterLines(spacingAfterLines / 100.0F);\n    }\n    int spacingBefore = paragraph.getSpacingBefore();\n    if ((-1) != spacingBefore) {\n        builder.withSpacingBefore(UnitUtils.twips2Point(spacingBefore));\n    }\n    int spacingAfter = paragraph.getSpacingAfter();\n    if ((-1) != spacingAfter) {\n        builder.withSpacingAfter(UnitUtils.twips2Point(spacingAfter));\n    }\n    double spacingBetween = paragraph.getSpacingBetween();\n    if ((-1) != spacingBetween) {\n        builder.withSpacing(spacingBetween);\n        builder.withSpacingRule(paragraph.getSpacingLineRule());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPBdr.addNewBottom",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTLvl.isSetPPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId" ],
    "fullMethods" : [ "public BigInteger addNewMultiLevelNumberingId(NumberingFormat... numFmts) {\n    XWPFNumbering numbering = this.getNumbering();\n    if (null == numbering) {\n        numbering = this.createNumbering();\n    }\n    XWPFNumberingWrapper numberingWrapper = new XWPFNumberingWrapper(numbering);\n    CTAbstractNum cTAbstractNum = CTAbstractNum.Factory.newInstance();\n    // if we have an existing document, we must determine the next\n    // free number first.\n    cTAbstractNum.setAbstractNumId(numberingWrapper.getNextAbstractNumID());\n    // CTMultiLevelType addNewMultiLevelType = cTAbstractNum.addNewMultiLevelType();\n    // addNewMultiLevelType.setVal(STMultiLevelType.HYBRID_MULTILEVEL);\n    for (int i = 0; i < numFmts.length; i++) {\n        NumberingFormat numFmt = numFmts[i];\n        CTLvl cTLvl = cTAbstractNum.addNewLvl();\n        CTPPrBase ppr = (cTLvl.isSetPPr()) ? cTLvl.getPPr() : cTLvl.addNewPPr();\n        CTInd ind = (ppr.isSetInd()) ? ppr.getInd() : ppr.addNewInd();\n        ind.setLeft(BigInteger.valueOf(UnitUtils.cm2Twips(0.74F) * i));\n        Enum fmt = STNumberFormat.Enum.forInt(numFmt.getNumFmt());\n        String val = numFmt.getLvlText();\n        cTLvl.addNewNumFmt().setVal(fmt);\n        cTLvl.addNewLvlText().setVal(val);\n        cTLvl.addNewStart().setVal(BigInteger.valueOf(1));\n        cTLvl.setIlvl(BigInteger.valueOf(i));\n        if (fmt == STNumberFormat.BULLET) {\n            cTLvl.addNewLvlJc().setVal(STJc.LEFT);\n            CTRPr addNewRPr = cTLvl.addNewRPr();\n            CTFonts ctFonts = addNewRPr.addNewRFonts();\n            ctFonts.setAscii(\"Wingdings\");\n            ctFonts.setHAnsi(\"Wingdings\");\n            ctFonts.setHint(STHint.DEFAULT);\n        }\n    }\n    XWPFAbstractNum abstractNum = new XWPFAbstractNum(cTAbstractNum);\n    BigInteger abstractNumID = numbering.addAbstractNum(abstractNum);\n    return numbering.addNum(abstractNumID);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CommentBodyContainer.setTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTComment.setTblArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.CommentBodyContainer.setTable" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setTable(int pos, XWPFTable table) {\n    // cell.getTables().set(pos, table);\n    List<XWPFTable> tables = ((List<XWPFTable>) (ReflectionUtils.getValue(\"tables\", comment)));\n    tables.set(pos, table);\n    comment.getCtComment().setTblArray(pos, table.getCTTbl());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderCell",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.addParagraph",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderCell" ],
    "fullMethods" : [ "public static void renderCell(XWPFTableCell cell, CellRenderData data, CellStyle defaultCellStyle, Style defaultTextStyle) throws Exception {\n    if (null == data)\n        return;\n\n    StyleUtils.styleTableCell(cell, defaultCellStyle);\n    StyleUtils.styleTableCell(cell, data.getCellStyle());\n    List<ParagraphStyle> defaultParaStyles = new ArrayList<>();\n    if (null != defaultTextStyle) {\n        defaultParaStyles.add(ParagraphStyle.builder().withDefaultTextStyle(defaultTextStyle).build());\n    }\n    if (null != defaultCellStyle) {\n        defaultParaStyles.add(defaultCellStyle.getDefaultParagraphStyle());\n    }\n    if (null != data.getCellStyle()) {\n        defaultParaStyles.add(data.getCellStyle().getDefaultParagraphStyle());\n    }\n    List<ParagraphRenderData> contents = data.getParagraphs();\n    if ((null != contents) && (!contents.isEmpty())) {\n        BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(cell);\n        XWPFParagraph placeHolder = cell.getParagraphArray(0);\n        if (null == placeHolder)\n            placeHolder = cell.addParagraph();\n\n        for (ParagraphRenderData item : contents) {\n            XWPFParagraph paragraph = bodyContainer.insertNewParagraph(placeHolder.getCTP().newCursor());\n            ParagraphRenderPolicy.Helper.renderParagraph(paragraph.createRun(), item, defaultParaStyles);\n        }\n        List<XWPFParagraph> paragraphs = cell.getParagraphs();\n        int pos = paragraphs.indexOf(placeHolder);\n        if ((-1) != pos)\n            cell.removeParagraph(pos);\n\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CTPictWrapper.setImageData",
    "thirdPartyMethod" : "com.microsoft.schemas.vml.CTShape.getImagedataList",
    "thirdPartyPackage" : "com.microsoft.schemas.vml",
    "path" : [ "com.deepoove.poi.xwpf.CTPictWrapper.setImageData" ],
    "fullMethods" : [ "public void setImageData(String rid) {\n    if (CollectionUtils.isNotEmpty(ctShape.getImagedataList())) {\n        CTImageData imageData = ctShape.getImagedataArray(0);\n        imageData.setId2(rid);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr.addNewWordWrap",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ResourceLoader.loadContent",
    "thirdPartyMethod" : "org.apache.commons.compress.utils.IOUtils.toByteArray",
    "thirdPartyPackage" : "org.apache.commons.compress.utils",
    "path" : [ "com.deepoove.poi.util.ResourceLoader.loadContent" ],
    "fullMethods" : [ "public static String loadContent(String url) throws IOException {\n    ClassLoader cl = getDefaultClassLoader();\n    InputStream stream = (null != cl) ? cl.getResourceAsStream(url) : ClassLoader.getSystemResourceAsStream(url);\n    try {\n        return new String(IOUtils.toByteArray(stream));\n    } finally {\n        IOUtils.closeQuietly(stream);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.compute.ReadMapAccessor.generateCode",
    "thirdPartyMethod" : "org.springframework.expression.spel.CodeFlow.insertCheckCast",
    "thirdPartyPackage" : "org.springframework.expression.spel",
    "path" : [ "com.deepoove.poi.render.compute.ReadMapAccessor.generateCode" ],
    "fullMethods" : [ "@Override\npublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n    String descriptor = cf.lastDescriptor();\n    if ((descriptor == null) || (!descriptor.equals(\"Ljava/util/Map\"))) {\n        if (descriptor == null) {\n            cf.loadTarget(mv);\n        }\n        CodeFlow.insertCheckCast(mv, \"Ljava/util/Map\");\n    }\n    mv.visitLdcInsn(propertyName);\n    mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", true);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.getShapeProperties",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.getSpPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.getShapeProperties" ],
    "fullMethods" : [ "@Override\npublic XDDFShapeProperties getShapeProperties() {\n    if (series.isSetSpPr()) {\n        return new XDDFShapeProperties(series.getSpPr());\n    } else {\n        return null;\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblBorders.isSetLeft",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTChart.unsetTitle",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setTitle" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartMultiSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    List<XDDFChartData> chartSeries = chart.getChartSeries();\n    validate(chartSeries, data);\n    int totalSeriesCount = ensureSeriesCount(chart, chartSeries);\n    int valueCol = 1;\n    List<SeriesRenderData> usedSeriesDatas = new ArrayList<>();\n    for (XDDFChartData chartData : chartSeries) {\n        int orignSize = chartData.getSeriesCount();\n        List<SeriesRenderData> currentSeriesData = null;\n        if (chartSeries.size() <= 1) {\n            // ignore combo type\n            currentSeriesData = data.getSeriesDatas();\n        } else {\n            currentSeriesData = obtainSeriesData(chartData.getClass(), data.getSeriesDatas());\n        }\n        usedSeriesDatas.addAll(currentSeriesData);\n        int currentSeriesSize = currentSeriesData.size();\n        XDDFDataSource<?> categoriesData = null;\n        if (chartData instanceof XDDFScatterChartData) {\n            categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n        } else {\n            categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n        }\n        for (int i = 0; i < currentSeriesSize; i++) {\n            XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, currentSeriesData.get(i).getValues(), valueCol);\n            XDDFChartData.Series currentSeries = null;\n            if (i < orignSize) {\n                currentSeries = chartData.getSeries(i);\n                valuesData.setFormatCode(currentSeries.getValuesData().getFormatCode());\n                currentSeries.replaceData(categoriesData, valuesData);\n            } else {\n                // add series, should copy series with style\n                currentSeries = chartData.addSeries(categoriesData, valuesData);\n                processNewSeries(chartData, currentSeries);\n            }\n            String name = currentSeriesData.get(i).getName();\n            currentSeries.setTitle(name, chart.setSheetTitle(name, valueCol));\n            valueCol++;\n        }\n        // clear extra series\n        removeExtraSeries(chartData, orignSize, currentSeriesSize);\n    }\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    updateCTTable(sheet, usedSeriesDatas);\n    removeExtraSheetCell(sheet, data.getCategories().length, totalSeriesCount, usedSeriesDatas.size());\n    for (XDDFChartData chartData : chartSeries) {\n        plot(chart, chartData);\n    }\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "protected void setTitle(XWPFChart chart, String title) {\n    if ((null == title) && chart.getCTChart().isSetTitle()) {\n        chart.getCTChart().unsetTitle();\n        return;\n    }\n    CTTitle ctTitle = chart.getCTChart().getTitle();\n    boolean isSet = setCTTitle(ctTitle, title);\n    if (!isSet) {\n        chart.setTitleText(title);\n        chart.setTitleOverlay(false);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTChart.unsetTitle",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setTitle" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartSingleSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    XDDFChartData pie = ChartUtils.getChartSeries(chart).get(0);\n    SeriesRenderData seriesDatas = data.getSeriesData();\n    XDDFDataSource<?> categoriesData = null;\n    if (pie instanceof XDDFScatterChartData) {\n        categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n    } else {\n        categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n    }\n    XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, seriesDatas.getValues(), 1);\n    XDDFChartData.Series currentSeries = pie.getSeries(0);\n    currentSeries.replaceData(categoriesData, valuesData);\n    currentSeries.setTitle(seriesDatas.getName(), chart.setSheetTitle(seriesDatas.getName(), 1));\n    updateCTTable(chart.getWorkbook().getSheetAt(0), Arrays.asList(seriesDatas));\n    plot(chart, pie);\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "protected void setTitle(XWPFChart chart, String title) {\n    if ((null == title) && chart.getCTChart().isSetTitle()) {\n        chart.getCTChart().unsetTitle();\n        return;\n    }\n    CTTitle ctTitle = chart.getCTChart().getTitle();\n    boolean isSet = setCTTitle(ctTitle, title);\n    if (!isSet) {\n        chart.setTitleText(title);\n        chart.setTitleOverlay(false);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableCell",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTcPr.addNewShd",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableCell" ],
    "fullMethods" : [ "/**\n * set cell style\n *\n * @param cell\n * @param cellStyle\n */\npublic static void styleTableCell(XWPFTableCell cell, CellStyle cellStyle) {\n    if ((null == cell) || (null == cellStyle))\n        return;\n\n    if (null != cellStyle.getVertAlign()) {\n        cell.setVerticalAlignment(cellStyle.getVertAlign());\n    }\n    if (null != cellStyle.getBackgroundColor()) {\n        CTTc ctTc = cell.getCTTc();\n        CTTcPr pr = (ctTc.isSetTcPr()) ? ctTc.getTcPr() : ctTc.addNewTcPr();\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = cellStyle.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(cellStyle.getBackgroundColor());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.addRow",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    try {\n        RunTemplate runTemplate = cast2runTemplate(eleTemplate);\n        XWPFRun run = runTemplate.getRun();\n        checkTargetIsTable(run, (\"Processing [\" + runTemplate.getTagName()) + \"] failed, the target content is not a table\");\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        final XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n        // \n        int position = getRowIndex(tagCell.getTableRow());\n        List<XWPFTableRow> tempRows = getAllTemplateRow(table, position);\n        if ((null != data) && (data instanceof Iterable)) {\n            // \n            final XWPFTableRow firstTempRow = tempRows.get(0);\n            Iterator<?> dataIt = ((Iterable<?>) (data)).iterator();\n            boolean hasNextData = dataIt.hasNext();\n            int index = 0;\n            while (hasNextData) {\n                Object dt = dataIt.next();\n                hasNextData = dataIt.hasNext();\n                Iterator<XWPFTableRow> rowTempIt = tempRows.iterator();\n                boolean hasNextTempRow = rowTempIt.hasNext();\n                while (hasNextTempRow) {\n                    XWPFTableRow tempRow = rowTempIt.next();\n                    hasNextTempRow = rowTempIt.hasNext();\n                    if (!table.addRow(tempRow, position)) {\n                        throw new RenderException(\"\");\n                    }\n                    // \n                    XmlCursor newCursor = firstTempRow.getCtRow().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    XWPFTableRow newRow = new XWPFTableRow(((CTRow) (object)), table);\n                    newRow.getCtRow().set(object);\n                    setTableRow(table, newRow, position);\n                    List<XWPFTableCell> cells = newRow.getTableCells();\n                    RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(dt, EnvIterator.makeEnv(index, hasNextData || hasNextTempRow)));\n                    cells.forEach(tableCell -> {\n                        List<MetaTemplate> metaTemplates = resolver.resolveBodyElements(tableCell.getBodyElements());\n                        new DocumentProcessor(template, resolver, dataCompute).process(metaTemplates);\n                    });\n                    ++position;\n                } \n                ++index;\n            } \n        }\n        removeTableRow(table, position, tempRows.size());\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-row template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.newCursor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.insertNewParagraph" ],
    "fullMethods" : [ "@Override\npublic XWPFParagraph insertNewParagraph(XmlCursor cursor) {\n    if (isCursorInBody(cursor)) {\n        String uri = CTP.type.getName().getNamespaceURI();\n        /* TODO DO not use a coded constant, find the constant in the OOXML\n        classes instead, as the child of type CT_Paragraph is defined in the\n        OOXML schema as 'p'\n         */\n        String localPart = \"p\";\n        // creates a new Paragraph, cursor is positioned inside the new\n        // element\n        cursor.beginElement(localPart, uri);\n        // move the cursor to the START token to the paragraph just created\n        cursor.toParent();\n        CTP p = ((CTP) (cursor.getObject()));\n        XWPFParagraph newP = new XWPFParagraph(p, this);\n        XmlObject o = null;\n        /* move the cursor to the previous element until a) the next\n        paragraph is found or b) all elements have been passed\n         */\n        while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n            o = cursor.getObject();\n        } \n        /* if the object that has been found is a) not a paragraph or b) is\n        the paragraph that has just been inserted, as the cursor in the\n        while loop above was not moved as there were no other siblings,\n        then the paragraph that was just inserted is the first paragraph\n        in the body. Otherwise, take the previous paragraph and calculate\n        the new index for the new paragraph.\n         */\n        if ((!(o instanceof CTP)) || (o == p)) {\n            paragraphs.add(0, newP);\n        } else {\n            int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n            paragraphs.add(pos, newP);\n        }\n        /* create a new cursor, that points to the START token of the just\n        inserted paragraph\n         */\n        XmlCursor newParaPos = p.newCursor();\n        try {\n            /* Calculate the paragraphs index in the list of all body\n            elements\n             */\n            int i = 0;\n            cursor.toCursor(newParaPos);\n            while (cursor.toPrevSibling()) {\n                o = cursor.getObject();\n                if (((o instanceof CTP) || (o instanceof CTTbl)) || (o instanceof CTSdtBlock)) {\n                    i++;\n                }\n            } \n            bodyElements.add(i, newP);\n            cursor.toCursor(newParaPos);\n            cursor.toEndToken();\n            return newP;\n        } finally {\n            newParaPos.dispose();\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.removeParagraph",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.newCursor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.removeParagraph" ],
    "fullMethods" : [ "/**\n * Removes a specific paragraph from this textbox\n *\n * @param paragraph\n * \t\t- {@link XWPFParagraph} object to remove\n */\npublic void removeParagraph(XWPFParagraph paragraph) {\n    if (paragraphs.contains(paragraph)) {\n        CTP ctP = paragraph.getCTP();\n        XmlCursor c = ctP.newCursor();\n        c.removeXml();\n        c.dispose();\n        paragraphs.remove(paragraph);\n        bodyElements.remove(paragraph);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CommentBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.newCursor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.CommentBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFHeaderFooter\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.getSDTs",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.newCursor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.getSDTs" ],
    "fullMethods" : [ "public List<XWPFStructuredDocumentTag> getSDTs() {\n    if (null != sdts)\n        return sdts;\n\n    sdts = new ArrayList<>();\n    long count = paragraph.getIRuns().stream().filter(r -> r instanceof XWPFSDT).count();\n    if (0 == count)\n        return sdts;\n\n    CTP ctp = paragraph.getCTP();\n    XmlCursor c = ctp.newCursor();\n    try {\n        c.selectPath(\"child::*\");\n        while (c.toNextSelection()) {\n            XmlObject o = c.getObject();\n            if (o instanceof CTSdtBlock) {\n                XWPFStructuredDocumentTag cc = new XWPFStructuredDocumentTag(((CTSdtBlock) (o)), paragraph.getBody());\n                sdts.add(cc);\n            }\n            if (o instanceof CTSdtRun) {\n                XWPFStructuredDocumentTag cc = new XWPFStructuredDocumentTag(((CTSdtRun) (o)), paragraph.getBody());\n                sdts.add(cc);\n            }\n        } \n    } finally {\n        c.dispose();\n    }\n    return sdts;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.BodyContainer.insertNewParagraph",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.newCursor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.BodyContainer.insertNewParagraph" ],
    "fullMethods" : [ "/**\n * insert paragraph at position of run\n *\n * @param run\n * @return the inserted paragraph\n */\ndefault XWPFParagraph insertNewParagraph(XWPFRun run) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    return insertNewParagraph(cursor);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.newCursor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFHeaderFooter\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.newCursor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.insertNewParagraph" ],
    "fullMethods" : [ "/**\n * add a new paragraph at position of the cursor\n *\n * @param cursor\n * \t\tThe XmlCursor structure created with XmlBeans\n * @return the inserted paragraph\n */\n@Override\npublic XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInTextBox(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    bodyElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.newCursor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFTableCell\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.DocumentBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.newCursor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.DocumentBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.IterableProcessor.next",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.newCursor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.render.processor.IterableProcessor.next" ],
    "fullMethods" : [ "@Override\npublic void next(IterableTemplate iterable, ParentContext parentContext, IterableContext context, Object model) {\n    BodyContainer bodyContainer = ((BodyContainer) (parentContext));\n    XWPFParagraph endParagraph = ((XWPFParagraph) (iterable.getEndRun().getParent()));\n    CTP endCtp = endParagraph.getCTP();\n    int start = context.getStart();\n    int end = context.getEnd();\n    context.getNumberingContinue().resetCache();\n    // copy positon cursor\n    XmlCursor insertPostionCursor = endCtp.newCursor();\n    // copy content\n    List<IBodyElement> bodyElements = bodyContainer.getBodyElements();\n    List<IBodyElement> copies = new ArrayList<IBodyElement>();\n    for (int i = start + 1; i < end; i++) {\n        IBodyElement iBodyElement = bodyElements.get(i);\n        if (iBodyElement.getElementType() == BodyElementType.PARAGRAPH) {\n            insertPostionCursor = endCtp.newCursor();\n            XWPFParagraph insertNewParagraph = bodyContainer.insertNewParagraph(insertPostionCursor);\n            // find insert paragraph pos\n            int paraPos = bodyContainer.getParaPos(insertNewParagraph);\n            bodyContainer.setParagraph(((XWPFParagraph) (iBodyElement)), paraPos);\n            // re-update ctp reference\n            insertPostionCursor = endCtp.newCursor();\n            insertPostionCursor.toPrevSibling();\n            XmlObject object = insertPostionCursor.getObject();\n            XWPFParagraph copy = new XWPFParagraph(((CTP) (object)), bodyContainer.getTarget());\n            // update docpr\n            DrawingSupport.updateDocPrId(copy);\n            // update numbering\n            context.getNumberingContinue().updateNumbering(((XWPFParagraph) (iBodyElement)), copy);\n            copies.add(copy);\n            bodyContainer.updateBodyElements(insertNewParagraph, copy);\n            bodyContainer.setParagraph(copy, paraPos);\n        } else if (iBodyElement.getElementType() == BodyElementType.TABLE) {\n            insertPostionCursor = endCtp.newCursor();\n            XWPFTable insertNewTbl = bodyContainer.insertNewTbl(insertPostionCursor);\n            // find insert table pos\n            int tablePos = bodyContainer.getTablePos(insertNewTbl);\n            bodyContainer.setTable(tablePos, ((XWPFTable) (iBodyElement)));\n            insertPostionCursor = endCtp.newCursor();\n            insertPostionCursor.toPrevSibling();\n            XmlObject object = insertPostionCursor.getObject();\n            XWPFTable copy = new XWPFTable(((CTTbl) (object)), bodyContainer.getTarget());\n            DrawingSupport.updateDocPrId(copy);\n            copies.add(copy);\n            bodyContainer.updateBodyElements(insertNewTbl, copy);\n            bodyContainer.setTable(tablePos, copy);\n        }\n    }\n    // re-parse\n    List<MetaTemplate> templates = this.resolver.resolveBodyElements(copies);\n    // render\n    process(templates, model);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.newCursor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.insertNewParagraph" ],
    "fullMethods" : [ "public XWPFParagraph insertNewParagraph(final XmlCursor cursor) {\n    if (!isCursorInBlockContent(cursor)) {\n        return null;\n    }\n    String uri = CTP.type.getName().getNamespaceURI();\n    String localPart = \"p\";\n    cursor.beginElement(localPart, uri);\n    cursor.toParent();\n    CTP p = ((CTP) (cursor.getObject()));\n    XWPFParagraph newP = new XWPFParagraph(p, this);\n    XmlObject o = null;\n    while ((!(o instanceof CTP)) && cursor.toPrevSibling()) {\n        o = cursor.getObject();\n    } \n    if ((!(o instanceof CTP)) || (o == p)) {\n        paragraphs.add(0, newP);\n    } else {\n        int pos = paragraphs.indexOf(getParagraph(((CTP) (o)))) + 1;\n        paragraphs.add(pos, newP);\n    }\n    int i = 0;\n    XmlCursor p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    while (cursor.toPrevSibling()) {\n        o = cursor.getObject();\n        if ((o instanceof CTP) || (o instanceof CTTbl)) {\n            i++;\n        }\n    } \n    sdtElements.add(i, newP);\n    p2 = p.newCursor();\n    cursor.toCursor(p2);\n    p2.dispose();\n    cursor.toEndToken();\n    return newP;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.removeParagraph",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.newCursor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.removeParagraph" ],
    "fullMethods" : [ "/**\n * Removes a specific paragraph from this textbox\n *\n * @param paragraph\n * \t\t- {@link XWPFParagraph} object to remove\n */\npublic void removeParagraph(XWPFParagraph paragraph) {\n    if (paragraphs.contains(paragraph)) {\n        CTP ctP = paragraph.getCTP();\n        XmlCursor c = ctP.newCursor();\n        c.removeXml();\n        c.dispose();\n        paragraphs.remove(paragraph);\n        sdtElements.remove(paragraph);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderCell",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.newCursor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderCell" ],
    "fullMethods" : [ "public static void renderCell(XWPFTableCell cell, CellRenderData data, CellStyle defaultCellStyle, Style defaultTextStyle) throws Exception {\n    if (null == data)\n        return;\n\n    StyleUtils.styleTableCell(cell, defaultCellStyle);\n    StyleUtils.styleTableCell(cell, data.getCellStyle());\n    List<ParagraphStyle> defaultParaStyles = new ArrayList<>();\n    if (null != defaultTextStyle) {\n        defaultParaStyles.add(ParagraphStyle.builder().withDefaultTextStyle(defaultTextStyle).build());\n    }\n    if (null != defaultCellStyle) {\n        defaultParaStyles.add(defaultCellStyle.getDefaultParagraphStyle());\n    }\n    if (null != data.getCellStyle()) {\n        defaultParaStyles.add(data.getCellStyle().getDefaultParagraphStyle());\n    }\n    List<ParagraphRenderData> contents = data.getParagraphs();\n    if ((null != contents) && (!contents.isEmpty())) {\n        BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(cell);\n        XWPFParagraph placeHolder = cell.getParagraphArray(0);\n        if (null == placeHolder)\n            placeHolder = cell.addParagraph();\n\n        for (ParagraphRenderData item : contents) {\n            XWPFParagraph paragraph = bodyContainer.insertNewParagraph(placeHolder.getCTP().newCursor());\n            ParagraphRenderPolicy.Helper.renderParagraph(paragraph.createRun(), item, defaultParaStyles);\n        }\n        List<XWPFParagraph> paragraphs = cell.getParagraphs();\n        int pos = paragraphs.indexOf(placeHolder);\n        if ((-1) != pos)\n            cell.removeParagraph(pos);\n\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getText",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.ISDTContent.getText",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getText" ],
    "fullMethods" : [ "@Override\npublic String getText() {\n    StringBuilder text = new StringBuilder();\n    boolean addNewLine = false;\n    for (int i = 0; i < sdtElements.size(); i++) {\n        Object o = sdtElements.get(i);\n        if (o instanceof XWPFParagraph) {\n            appendParagraph(((XWPFParagraph) (o)), text);\n            addNewLine = true;\n        } else if (o instanceof XWPFTable) {\n            appendTable(((XWPFTable) (o)), text);\n            addNewLine = true;\n        } else if (o instanceof XWPFSDT) {\n            text.append(((XWPFSDT) (o)).getContent().getText());\n            addNewLine = true;\n        } else if (o instanceof XWPFRun) {\n            text.append(o);\n            addNewLine = false;\n        }\n        if (addNewLine && (i < (sdtElements.size() - 1))) {\n            text.append(\"\\n\");\n        }\n    }\n    return text.toString();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableRow",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTrPr.addNewTrHeight",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableRow" ],
    "fullMethods" : [ "/**\n * set row style\n *\n * @param row\n * @param rowStyle\n */\npublic static void styleTableRow(XWPFTableRow row, RowStyle rowStyle) {\n    if ((null == row) || (null == rowStyle))\n        return;\n\n    int height = rowStyle.getHeight();\n    CTRow ctRow = row.getCtRow();\n    CTTrPr properties = (ctRow.isSetTrPr()) ? ctRow.getTrPr() : ctRow.addNewTrPr();\n    if (0 != height) {\n        row.setHeight(height);\n        CTHeight h = (properties.sizeOfTrHeightArray() == 0) ? properties.addNewTrHeight() : properties.getTrHeightArray(0);\n        String heightRule = rowStyle.getHeightRule();\n        if (\"exact\".equals(heightRule))\n            h.setHRule(STHeightRule.EXACT);\n        else if (\"atleast\".equals(heightRule))\n            h.setHRule(STHeightRule.AT_LEAST);\n        else\n            h.setHRule(STHeightRule.AUTO);\n\n    }\n    boolean repeated = rowStyle.isRepeated();\n    if (repeated) {\n        CTOnOff tblHeader = (properties.sizeOfTblHeaderArray() == 0) ? properties.addNewTblHeader() : properties.getTblHeaderArray(0);\n        tblHeader.setVal(XWPFOnOff.ON);\n    }\n    boolean breakAcrossPage = rowStyle.isBreakAcrossPage();\n    if (!breakAcrossPage) {\n        if (properties.sizeOfCantSplitArray() == 0) {\n            properties.addNewCantSplit();\n        } else {\n            properties.getCantSplitArray(0).setVal(XWPFOnOff.ON);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.addTab",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.<init>", "com.deepoove.poi.resolver.RunningRunBody.refactorBody" ],
    "fullMethods" : [ "public RunningRunBody(RunBodyContext context, Pattern pattern) {\n    this.runBodyContext = context;\n    this.runs = context.getRuns();\n    if ((null == runs) || runs.isEmpty())\n        return;\n\n    Matcher matcher = pattern.matcher(getText(context));\n    if (matcher.find()) {\n        refactorBody();\n    }\n    buildRunEdge(pattern);\n}", "private void refactorBody() {\n    for (int i = runs.size() - 1; i >= 0; i--) {\n        XWPFRun xwpfRun = runs.get(i);\n        CTR ctr = xwpfRun.getCTR();\n        CTRImpl ctrimpl = ((CTRImpl) (ctr));\n        int sizeOfBrArray = ctr.sizeOfBrArray();\n        int sizeOfCrArray = ctr.sizeOfCrArray();\n        int sizeOfTabArray = ctr.sizeOfTabArray();\n        if (((sizeOfBrArray + sizeOfCrArray) + sizeOfTabArray) > 0) {\n            synchronized(ctrimpl.monitor()) {\n                // ctrimpl.check_orphaned();\n                List<? extends XmlObject> localArrayList = new ArrayList<XmlObject>();\n                ctrimpl.get_store().find_all_element_users(qname, localArrayList);\n                int size = localArrayList.size();\n                for (int j = size - 1; j >= 0; j--) {\n                    Object obj = localArrayList.get(j);\n                    if (obj instanceof CTEmpty) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        String tagName = ((CTEmpty) (obj)).getDomNode().getNodeName();\n                        if (\"w:br\".equals(tagName) || \"br\".equals(tagName)) {\n                            insertNewRun.addBreak();\n                        }\n                        if (\"w:cr\".equals(tagName) || \"cr\".equals(tagName)) {\n                            insertNewRun.addCarriageReturn();\n                        }\n                        if (\"w:tab\".equals(tagName) || \"tab\".equals(tagName)) {\n                            insertNewRun.addTab();\n                        }\n                    } else if (obj instanceof CTBr) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        CTBr addNewBr = insertNewRun.getCTR().addNewBr();\n                        if (null != ((CTBr) (obj)).getType())\n                            addNewBr.setType(((CTBr) (obj)).getType());\n\n                        if (null != ((CTBr) (obj)).getClear())\n                            addNewBr.setClear(((CTBr) (obj)).getClear());\n\n                    } else if (obj instanceof CTText) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        StyleUtils.styleRun(insertNewRun, xwpfRun);\n                        insertNewRun.setText(((CTText) (obj)).getStringValue());\n                    }\n                }\n                runBodyContext.removeRun(i);\n            }\n        }\n    }\n    this.runs = runBodyContext.getRuns();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TextRenderPolicy.Helper.renderTextRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.addBreak",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TextRenderPolicy.Helper.renderTextRun" ],
    "fullMethods" : [ "public static void renderTextRun(XWPFRun run, TextRenderData data) {\n    XWPFRun textRun = run;\n    if (data instanceof HyperlinkTextRenderData) {\n        textRun = createHyperlink(run, ((HyperlinkTextRenderData) (data)).getUrl());\n    }\n    StyleUtils.styleRun(textRun, data.getStyle());\n    String text = Optional.ofNullable(data.getText()).orElse(\"\");\n    String[] fragment = text.split(REGEX_LINE_CHARACTOR, -1);\n    if (fragment.length > 0) {\n        textRun.setText(fragment[0], 0);\n        boolean lineAtTable = ((fragment.length > 1) && (!(data instanceof HyperlinkTextRenderData))) && TableTools.isInsideTable(run);\n        for (int i = 1; i < fragment.length; i++) {\n            if (lineAtTable) {\n                textRun.addBreak(BreakType.TEXT_WRAPPING);\n            } else {\n                textRun.addCarriageReturn();\n            }\n            textRun.setText(fragment[i]);\n        }\n    }\n    if (data instanceof BookmarkTextRenderData) {\n        createBookmark(textRun, ((BookmarkTextRenderData) (data)).getBookmark());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.pagination.PaginationRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.addBreak",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.pagination.PaginationRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(RenderContext<Boolean> context) throws Exception {\n    XWPFRun run = context.getRun();\n    clearPlaceholder(context, false);\n    if (Boolean.TRUE.equals(context.getData())) {\n        run.addBreak(BreakType.PAGE);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.getVal",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>" ],
    "fullMethods" : [ "public XDDFOfPieChartData(XDDFChart parent, CTOfPieChart chart) {\n    super(parent);\n    this.chart = chart;\n    this.seriesNum = parent.getChartSeries().size();\n    for (CTPieSer series : chart.getSerList()) {\n        this.series.add(new Series(series, series.getCat(), series.getVal()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.init",
    "thirdPartyMethod" : "org.apache.poi.openxml4j.opc.PackagePart.getInputStream",
    "thirdPartyPackage" : "org.apache.poi.openxml4j.opc",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.init" ],
    "fullMethods" : [ "{\n    com.deepoove.poi.xwpf.NiceXWPFDocument$2 this;\n    java.io.InputStream $stack2;\n    java.lang.Object $stack3;\n    org.apache.poi.ooxml.POIXMLDocumentPart #l1;\n    org.apache.poi.openxml4j.opc.PackagePart part;\n    org.apache.poi.xwpf.usermodel.XWPFDocument #l0;\n\n\n    this := @this: com.deepoove.poi.xwpf.NiceXWPFDocument$2;\n    part := @parameter0: org.apache.poi.openxml4j.opc.PackagePart;\n    $stack3 = new org.apache.poi.xwpf.usermodel.XWPFDocument;\n    $stack2 = virtualinvoke part.<org.apache.poi.openxml4j.opc.PackagePart: java.io.InputStream getInputStream()>();\n    #l0 = (org.apache.poi.xwpf.usermodel.XWPFDocument) $stack3;\n    specialinvoke #l0.<org.apache.poi.xwpf.usermodel.XWPFDocument: void <init>(java.io.InputStream)>($stack2);\n    #l1 = (org.apache.poi.ooxml.POIXMLDocumentPart) $stack3;\n\n    return #l1;\n}\n" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.apache.poi.openxml4j.opc.PackagePart.getInputStream",
    "thirdPartyPackage" : "org.apache.poi.openxml4j.opc",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableString", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeAttachment" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "protected String createMergeableString(NiceXWPFDocument source, NiceXWPFDocument merged, Map<String, String> styleIdsMap) throws InvalidFormatException, IOException {\n    CTBody mergedBody = merged.getDocument().getBody();\n    // TODO For the same style, reduce the number of merges\n    // Map<String, String> styleIdsMap = mergeStyles(docMerge);\n    Map<String, String> numIdsMap = mergeNumbering(source, merged);\n    Map<String, String> blipIdsMap = mergePicture(source, merged);\n    Map<String, String> externalBlipIdsMap = mergeExternalPicture(source, merged);\n    Map<String, String> hyperlinkMap = mergeHyperlink(source, merged);\n    Map<String, String> chartIdsMap = mergeChart(source, merged);\n    Map<String, String> attachmentIdsMap = mergeAttachment(source, merged);\n    Map<String, String> footnoteIdsMap = mergeFootnote(source, merged);\n    Map<String, String> endnoteIdsMap = mergeEndnote(source, merged);\n    String appendString = mergedBody.xmlText(DefaultXmlOptions.OPTIONS_OUTER);\n    String addPart = ridSectPr(appendString);\n    // style\n    for (String styleId : styleIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:pStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:pStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:tblStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:tblStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:rStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:rStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\");\n    }\n    // picture id\n    Map<String, String> placeHolderblipIdsMap = new HashMap<String, String>();\n    for (String relaId : blipIdsMap.keySet()) {\n        placeHolderblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:embed=\\\"\" + relaId) + \"\\\"\", (\"r:embed=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n        // w:pict v:shape v:imagedata\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    Map<String, String> placeHolderExternalblipIdsMap = new HashMap<String, String>();\n    for (String relaId : externalBlipIdsMap.keySet()) {\n        placeHolderExternalblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderExternalblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:link=\\\"\" + relaId) + \"\\\"\", (\"r:link=\\\"\" + placeHolderExternalblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // hyperlink id\n    for (String relaId : hyperlinkMap.keySet()) {\n        hyperlinkMap.put(relaId, hyperlinkMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : hyperlinkMap.keySet()) {\n        // w:hyperlink r:id\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + hyperlinkMap.get(relaId)) + \"\\\"\");\n    }\n    // chart id\n    for (String relaId : chartIdsMap.keySet()) {\n        chartIdsMap.put(relaId, chartIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : chartIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + chartIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // attachment id\n    for (String relaId : attachmentIdsMap.keySet()) {\n        attachmentIdsMap.put(relaId, attachmentIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : attachmentIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + attachmentIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // footnote id\n    for (String relaId : footnoteIdsMap.keySet()) {\n        footnoteIdsMap.put(relaId, footnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : footnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"footnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"footnoteReference w:id=\\\"\" + footnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // endnote id\n    for (String relaId : endnoteIdsMap.keySet()) {\n        endnoteIdsMap.put(relaId, endnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : endnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"endnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"endnoteReference w:id=\\\"\" + endnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // numbering numId\n    for (String relaId : numIdsMap.keySet()) {\n        numIdsMap.put(relaId, numIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String numId : numIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:numId\\\\sw:val=\\\"\" + numId) + \"\\\"\", (\"<w:numId w:val=\\\"\" + numIdsMap.get(numId)) + \"\\\"\");\n    }\n    return addPart.replaceAll(CROSS_REPLACE_STRING, \"\");\n}", "protected Map<String, String> mergeAttachment(NiceXWPFDocument source, NiceXWPFDocument merged) throws InvalidFormatException, IOException {\n    Map<String, String> attachmentIdsMap = new HashMap<String, String>();\n    PackageRelationshipCollection part = merged.getPackagePart().getRelationshipsByType(POIXMLDocument.PACK_OBJECT_REL_TYPE);\n    Iterator<PackageRelationship> iterator = part.iterator();\n    while (iterator.hasNext()) {\n        PackageRelationship relationship = iterator.next();\n        PackagePart embeddPart = merged.getPackagePart().getRelatedPart(relationship);\n        String path = relationship.getTargetURI().getPath();\n        if ((null == path) || ((!path.endsWith(\".docx\")) && (!path.endsWith(\".xlsx\"))))\n            continue;\n\n        try {\n            byte[] byteData = IOUtils.toByteArray(embeddPart.getInputStream());\n            String newId = source.addEmbeddData(byteData, path.endsWith(\"docx\") ? 0 : 1);\n            attachmentIdsMap.putIfAbsent(relationship.getId(), newId);\n        } catch (IOException e) {\n            throw new POIXMLException(e);\n        }\n    } \n    return attachmentIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTChart.isSetTitle",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.MultiSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setTitle" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartMultiSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    List<XDDFChartData> chartSeries = chart.getChartSeries();\n    validate(chartSeries, data);\n    int totalSeriesCount = ensureSeriesCount(chart, chartSeries);\n    int valueCol = 1;\n    List<SeriesRenderData> usedSeriesDatas = new ArrayList<>();\n    for (XDDFChartData chartData : chartSeries) {\n        int orignSize = chartData.getSeriesCount();\n        List<SeriesRenderData> currentSeriesData = null;\n        if (chartSeries.size() <= 1) {\n            // ignore combo type\n            currentSeriesData = data.getSeriesDatas();\n        } else {\n            currentSeriesData = obtainSeriesData(chartData.getClass(), data.getSeriesDatas());\n        }\n        usedSeriesDatas.addAll(currentSeriesData);\n        int currentSeriesSize = currentSeriesData.size();\n        XDDFDataSource<?> categoriesData = null;\n        if (chartData instanceof XDDFScatterChartData) {\n            categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n        } else {\n            categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n        }\n        for (int i = 0; i < currentSeriesSize; i++) {\n            XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, currentSeriesData.get(i).getValues(), valueCol);\n            XDDFChartData.Series currentSeries = null;\n            if (i < orignSize) {\n                currentSeries = chartData.getSeries(i);\n                valuesData.setFormatCode(currentSeries.getValuesData().getFormatCode());\n                currentSeries.replaceData(categoriesData, valuesData);\n            } else {\n                // add series, should copy series with style\n                currentSeries = chartData.addSeries(categoriesData, valuesData);\n                processNewSeries(chartData, currentSeries);\n            }\n            String name = currentSeriesData.get(i).getName();\n            currentSeries.setTitle(name, chart.setSheetTitle(name, valueCol));\n            valueCol++;\n        }\n        // clear extra series\n        removeExtraSeries(chartData, orignSize, currentSeriesSize);\n    }\n    XSSFSheet sheet = chart.getWorkbook().getSheetAt(0);\n    updateCTTable(sheet, usedSeriesDatas);\n    removeExtraSheetCell(sheet, data.getCategories().length, totalSeriesCount, usedSeriesDatas.size());\n    for (XDDFChartData chartData : chartSeries) {\n        plot(chart, chartData);\n    }\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "protected void setTitle(XWPFChart chart, String title) {\n    if ((null == title) && chart.getCTChart().isSetTitle()) {\n        chart.getCTChart().unsetTitle();\n        return;\n    }\n    CTTitle ctTitle = chart.getCTChart().getTitle();\n    boolean isSet = setCTTitle(ctTitle, title);\n    if (!isSet) {\n        chart.setTitleText(title);\n        chart.setTitleOverlay(false);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTChart.isSetTitle",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.policy.reference.SingleSeriesChartTemplateRenderPolicy.doRender", "com.deepoove.poi.policy.reference.AbstractChartTemplateRenderPolicy.setTitle" ],
    "fullMethods" : [ "@Override\npublic void doRender(ChartTemplate eleTemplate, ChartSingleSeriesRenderData data, XWPFTemplate template) throws Exception {\n    XWPFChart chart = eleTemplate.getChart();\n    XDDFChartData pie = ChartUtils.getChartSeries(chart).get(0);\n    SeriesRenderData seriesDatas = data.getSeriesData();\n    XDDFDataSource<?> categoriesData = null;\n    if (pie instanceof XDDFScatterChartData) {\n        categoriesData = createNumbericalDataSource(chart, toNumberArray(data.getCategories()), 0);\n    } else {\n        categoriesData = createStringDataSource(chart, data.getCategories(), 0);\n    }\n    XDDFNumericalDataSource<? extends Number> valuesData = createNumbericalDataSource(chart, seriesDatas.getValues(), 1);\n    XDDFChartData.Series currentSeries = pie.getSeries(0);\n    currentSeries.replaceData(categoriesData, valuesData);\n    currentSeries.setTitle(seriesDatas.getName(), chart.setSheetTitle(seriesDatas.getName(), 1));\n    updateCTTable(chart.getWorkbook().getSheetAt(0), Arrays.asList(seriesDatas));\n    plot(chart, pie);\n    setTitle(chart, data.getChartTitle());\n    setAxisTitle(chart, data.getxAxisTitle(), data.getyAxisTitle());\n}", "protected void setTitle(XWPFChart chart, String title) {\n    if ((null == title) && chart.getCTChart().isSetTitle()) {\n        chart.getCTChart().unsetTitle();\n        return;\n    }\n    CTTitle ctTitle = chart.getCTChart().getTitle();\n    boolean isSet = setCTTitle(ctTitle, title);\n    if (!isSet) {\n        chart.setTitleText(title);\n        chart.setTitleOverlay(false);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFonts.setCs",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.DocxRenderPolicy.XWPFDocumentIterator.next",
    "thirdPartyMethod" : "org.apache.commons.collections4.CollectionUtils.isEmpty",
    "thirdPartyPackage" : "org.apache.commons.collections4",
    "path" : [ "com.deepoove.poi.policy.DocxRenderPolicy.XWPFDocumentIterator.next" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument next() {\n    if (!hasNext())\n        throw new NoSuchElementException(\"No instance of NiceXWPFDocument\");\n\n    if (CollectionUtils.isEmpty(datas) && (0 == cursor)) {\n        try {\n            cursor++;\n            return new NiceXWPFDocument(new ByteArrayInputStream(bytes));\n        } catch (IOException e) {\n            throw new RenderException(\"Create XWPFDocument error\", e);\n        }\n    } else {\n        // TODO performance, should compile template only once?\n        XWPFTemplate temp = XWPFTemplate.compile(new ByteArrayInputStream(bytes), config);\n        temp.render(datas.get(cursor++));\n        return temp.getXWPFDocument();\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.template.ChartTemplate.<init>",
    "thirdPartyMethod" : "org.apache.commons.collections4.CollectionUtils.isEmpty",
    "thirdPartyPackage" : "org.apache.commons.collections4",
    "path" : [ "com.deepoove.poi.template.ChartTemplate.<init>", "com.deepoove.poi.template.ChartTemplate.readChartType" ],
    "fullMethods" : [ "public ChartTemplate(String tagName, XWPFChart chart, XWPFRun run) {\n    this.tagName = tagName;\n    this.chart = chart;\n    this.run = run;\n    this.chartType = readChartType(this.chart);\n}", "private ChartTypes readChartType(XWPFChart chart) {\n    List<XDDFChartData> chartSeries = ChartUtils.getChartSeries(chart);\n    if (CollectionUtils.isEmpty(chartSeries)) {\n        return null;\n    }\n    XDDFChartData chartData = chartSeries.get(0);\n    ChartTypes chartType = null;\n    if (chartData.getClass() == XDDFAreaChartData.class) {\n        chartType = ChartTypes.AREA;\n    } else if (chartData.getClass() == XDDFArea3DChartData.class) {\n        chartType = ChartTypes.AREA3D;\n    } else if (chartData.getClass() == XDDFBarChartData.class) {\n        chartType = ChartTypes.BAR;\n    } else if (chartData.getClass() == XDDFBar3DChartData.class) {\n        chartType = ChartTypes.BAR3D;\n    } else if (chartData.getClass() == XDDFLineChartData.class) {\n        chartType = ChartTypes.LINE;\n    } else if (chartData.getClass() == XDDFLine3DChartData.class) {\n        chartType = ChartTypes.LINE3D;\n    } else if ((chartData.getClass() == XDDFPieChartData.class) || (chartData.getClass() == XDDFOfPieChartData.class)) {\n        chartType = ChartTypes.PIE;\n    } else if (chartData.getClass() == XDDFPie3DChartData.class) {\n        chartType = ChartTypes.PIE3D;\n    } else if (chartData.getClass() == XDDFRadarChartData.class) {\n        chartType = ChartTypes.RADAR;\n    } else if (chartData.getClass() == XDDFScatterChartData.class) {\n        chartType = ChartTypes.SCATTER;\n    } else if (chartData.getClass() == XDDFSurfaceChartData.class) {\n        chartType = ChartTypes.SURFACE;\n    } else if (chartData.getClass() == XDDFSurface3DChartData.class) {\n        chartType = ChartTypes.SURFACE3D;\n    } else if (chartData.getClass() == XDDFDoughnutChartData.class) {\n        chartType = ChartTypes.DOUGHNUT;\n    }\n    return chartType;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.DocumentProcessor.process",
    "thirdPartyMethod" : "org.apache.commons.collections4.CollectionUtils.isEmpty",
    "thirdPartyPackage" : "org.apache.commons.collections4",
    "path" : [ "com.deepoove.poi.render.processor.DocumentProcessor.process", "com.deepoove.poi.render.processor.DocumentProcessor.obtainTextboxes" ],
    "fullMethods" : [ "public void process(List<MetaTemplate> templates) {\n    // process in order( or sort first)\n    templates.forEach(template -> template.accept(this));\n    Set<XWPFTextboxContent> textboxs = obtainTextboxes(templates);\n    textboxs.forEach(content -> {\n        content.getXmlObject().set(content.getCTTxbxContent());\n    });\n}", "@SuppressWarnings(\"deprecation\")\nprivate Set<XWPFTextboxContent> obtainTextboxes(List<MetaTemplate> templates) {\n    Set<XWPFTextboxContent> textboxs = new HashSet<>();\n    if (CollectionUtils.isEmpty(templates))\n        return textboxs;\n\n    templates.forEach(template -> {\n        RunTemplate checkTemplate = (template instanceof RunTemplate) ? ((RunTemplate) (template)) : template instanceof BlockTemplate ? ((BlockTemplate) (template)).getStartMark() : null;\n        if (null != checkTemplate) {\n            if ((checkTemplate.getRun().getParent() instanceof XWPFParagraph) && (checkTemplate.getRun().getParagraph().getBody() instanceof XWPFTextboxContent)) {\n                textboxs.add(((XWPFTextboxContent) (checkTemplate.getRun().getParagraph().getBody())));\n            }\n        }\n    });\n    return textboxs;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.setKeepNext",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.sizeOfStrikeArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.removeParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.removeParagraph" ],
    "fullMethods" : [ "/**\n * Removes a specific paragraph from this textbox\n *\n * @param paragraph\n * \t\t- {@link XWPFParagraph} object to remove\n */\npublic void removeParagraph(XWPFParagraph paragraph) {\n    if (paragraphs.contains(paragraph)) {\n        CTP ctP = paragraph.getCTP();\n        XmlCursor c = ctP.newCursor();\n        c.removeXml();\n        c.dispose();\n        paragraphs.remove(paragraph);\n        bodyElements.remove(paragraph);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CommentBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CommentBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFHeaderFooter\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.setParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.setParagraph" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setParagraph(XWPFParagraph p, int paraPos) {\n    List<XWPFParagraph> paragraphs = ((List<XWPFParagraph>) (ReflectionUtils.getValue(\"paragraphs\", headerFooter)));\n    paragraphs.set(paraPos, p);\n    CTHdrFtr ctTc = headerFooter._getHdrFtr();\n    ctTc.setPArray(paraPos, p.getCTP());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.getSDTs",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.getSDTs" ],
    "fullMethods" : [ "public List<XWPFStructuredDocumentTag> getSDTs() {\n    if (null != sdts)\n        return sdts;\n\n    sdts = new ArrayList<>();\n    long count = paragraph.getIRuns().stream().filter(r -> r instanceof XWPFSDT).count();\n    if (0 == count)\n        return sdts;\n\n    CTP ctp = paragraph.getCTP();\n    XmlCursor c = ctp.newCursor();\n    try {\n        c.selectPath(\"child::*\");\n        while (c.toNextSelection()) {\n            XmlObject o = c.getObject();\n            if (o instanceof CTSdtBlock) {\n                XWPFStructuredDocumentTag cc = new XWPFStructuredDocumentTag(((CTSdtBlock) (o)), paragraph.getBody());\n                sdts.add(cc);\n            }\n            if (o instanceof CTSdtRun) {\n                XWPFStructuredDocumentTag cc = new XWPFStructuredDocumentTag(((CTSdtRun) (o)), paragraph.getBody());\n                sdts.add(cc);\n            }\n        } \n    } finally {\n        c.dispose();\n    }\n    return sdts;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewBookmarkEnd",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewBookmarkEnd" ],
    "fullMethods" : [ "public CTMarkupRange insertNewBookmarkEnd(int paramInt) {\n    CTP ctp = paragraph.getCTP();\n    synchronized(ctp.monitor()) {\n        // check_orphaned();\n        CTMarkupRange local = null;\n        local = ((CTMarkupRange) (((CTPImpl) (ctp)).get_store().insert_element_user(RUN_QNAME_SET, BOOKMARK_END_QNAME, paramInt)));\n        return local;\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.BodyContainer.getPosOfParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.BodyContainer.getPosOfParagraph" ],
    "fullMethods" : [ "/**\n * get the position of paragraph in bodyElements\n *\n * @param paragraph\n * @return the position of paragraph\n */\ndefault int getPosOfParagraph(XWPFParagraph paragraph) {\n    return getPosOfParagraphCTP(paragraph.getCTP());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.BodyContainer.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.BodyContainer.insertNewParagraph" ],
    "fullMethods" : [ "/**\n * insert paragraph at position of run\n *\n * @param run\n * @return the inserted paragraph\n */\ndefault XWPFParagraph insertNewParagraph(XWPFRun run) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    return insertNewParagraph(cursor);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.TextBoxBodyContainer.setParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.TextBoxBodyContainer.setParagraph" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setParagraph(XWPFParagraph paragraph, int pos) {\n    List<XWPFParagraph> paragraphs = ((List<XWPFParagraph>) (ReflectionUtils.getValue(\"paragraphs\", textbox)));\n    paragraphs.set(pos, paragraph);\n    CTTxbxContent ctTxbxContent = textbox.getCTTxbxContent();\n    ctTxbxContent.setPArray(pos, paragraph.getCTP());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.DocumentBodyContainer.closelySectPr",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.DocumentBodyContainer.closelySectPr" ],
    "fullMethods" : [ "@Override\npublic XWPFSection closelySectPr(IBodyElement element) {\n    List<IBodyElement> bodyElements = doc.getBodyElements();\n    boolean isEncounter = false;\n    for (IBodyElement ele : bodyElements) {\n        if (isEncounter) {\n            if (ele instanceof XWPFParagraph) {\n                XWPFParagraph para = ((XWPFParagraph) (ele));\n                CTP ctp = para.getCTP();\n                if (!ctp.isSetPPr())\n                    continue;\n\n                CTPPr pPr = ctp.getPPr();\n                if (pPr.isSetSectPr()) {\n                    return new XWPFSection(pPr.getSectPr());\n                }\n            }\n        } else if (ele == element) {\n            isEncounter = true;\n        }\n    }\n    CTBody body = doc.getDocument().getBody();\n    if (body.isSetSectPr()) {\n        return new XWPFSection(body.getSectPr());\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyle(XWPFParagraph paragraph) {\n    if (null == paragraph)\n        return null;\n\n    Builder builder = ParagraphStyle.builder();\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    if (paragraph.isWordWrapped()) {\n        builder.withAllowWordBreak(true);\n    }\n    if (pr.isSetPBdr()) {\n        CTPBdr ct = pr.getPBdr();\n        if (ct.isSetLeft()) {\n            builder.withLeftBorder(retriveBorderStyle(ct.getLeft()));\n        }\n        if (ct.isSetTop()) {\n            builder.withTopBorder(retriveBorderStyle(ct.getTop()));\n        }\n        if (ct.isSetRight()) {\n            builder.withRightBorder(retriveBorderStyle(ct.getRight()));\n        }\n        if (ct.isSetBottom()) {\n            builder.withBottomBorder(retriveBorderStyle(ct.getBottom()));\n        }\n    }\n    if (pr.isSetShd()) {\n        CTShd shd = pr.getShd();\n        builder.withShadingPattern(XWPFShadingPattern.valueOf(shd.getVal().intValue()));\n        if (shd.isSetFill())\n            builder.withBackgroundColor(shd.xgetFill().getStringValue());\n\n    }\n    builder.withAlign(paragraph.getAlignment());\n    int spacingBeforeLines = paragraph.getSpacingBeforeLines();\n    if ((-1) != spacingBeforeLines) {\n        builder.withSpacingBeforeLines(spacingBeforeLines / 100.0F);\n    }\n    int spacingAfterLines = paragraph.getSpacingAfterLines();\n    if ((-1) != spacingAfterLines) {\n        builder.withSpacingAfterLines(spacingAfterLines / 100.0F);\n    }\n    int spacingBefore = paragraph.getSpacingBefore();\n    if ((-1) != spacingBefore) {\n        builder.withSpacingBefore(UnitUtils.twips2Point(spacingBefore));\n    }\n    int spacingAfter = paragraph.getSpacingAfter();\n    if ((-1) != spacingAfter) {\n        builder.withSpacingAfter(UnitUtils.twips2Point(spacingAfter));\n    }\n    double spacingBetween = paragraph.getSpacingBetween();\n    if ((-1) != spacingBetween) {\n        builder.withSpacing(spacingBetween);\n        builder.withSpacingRule(paragraph.getSpacingLineRule());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewFldSimple",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewFldSimple" ],
    "fullMethods" : [ "public CTSimpleField insertNewFldSimple(int paramInt) {\n    CTP ctp = paragraph.getCTP();\n    synchronized(ctp.monitor()) {\n        // check_orphaned();\n        CTSimpleField localCTSimpleField = null;\n        localCTSimpleField = ((CTSimpleField) (((CTPImpl) (ctp)).get_store().insert_element_user(RUN_QNAME_SET, FLDSIMPLE_QNAME, paramInt)));\n        return localCTSimpleField;\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.closelySectPr",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.closelySectPr" ],
    "fullMethods" : [ "@Override\npublic XWPFSection closelySectPr(IBodyElement element) {\n    XWPFDocument doc = headerFooter.getXWPFDocument();\n    String relationId = doc.getRelationId(this.headerFooter);\n    if (null != relationId) {\n        List<IBodyElement> bodyElements = doc.getBodyElements();\n        for (IBodyElement ele : bodyElements) {\n            if (ele instanceof XWPFParagraph) {\n                XWPFParagraph para = ((XWPFParagraph) (ele));\n                CTP ctp = para.getCTP();\n                if (!ctp.isSetPPr())\n                    continue;\n\n                CTPPr pPr = ctp.getPPr();\n                if (pPr.isSetSectPr()) {\n                    XWPFSection xwpfSection = new XWPFSection(pPr.getSectPr());\n                    if (headerFooter instanceof XWPFHeader) {\n                        if (xwpfSection.haveHeader(relationId))\n                            return xwpfSection;\n\n                    } else if (headerFooter instanceof XWPFFooter) {\n                        if (xwpfSection.haveFooter(relationId))\n                            return xwpfSection;\n\n                    }\n                }\n            }\n        }\n    }\n    CTBody body = doc.getDocument().getBody();\n    if (body.isSetSectPr()) {\n        return new XWPFSection(body.getSectPr());\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFTableCell\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.DocumentBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.DocumentBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.IterableProcessor.next",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.IterableProcessor.next" ],
    "fullMethods" : [ "@Override\npublic void next(IterableTemplate iterable, ParentContext parentContext, IterableContext context, Object model) {\n    BodyContainer bodyContainer = ((BodyContainer) (parentContext));\n    XWPFParagraph endParagraph = ((XWPFParagraph) (iterable.getEndRun().getParent()));\n    CTP endCtp = endParagraph.getCTP();\n    int start = context.getStart();\n    int end = context.getEnd();\n    context.getNumberingContinue().resetCache();\n    // copy positon cursor\n    XmlCursor insertPostionCursor = endCtp.newCursor();\n    // copy content\n    List<IBodyElement> bodyElements = bodyContainer.getBodyElements();\n    List<IBodyElement> copies = new ArrayList<IBodyElement>();\n    for (int i = start + 1; i < end; i++) {\n        IBodyElement iBodyElement = bodyElements.get(i);\n        if (iBodyElement.getElementType() == BodyElementType.PARAGRAPH) {\n            insertPostionCursor = endCtp.newCursor();\n            XWPFParagraph insertNewParagraph = bodyContainer.insertNewParagraph(insertPostionCursor);\n            // find insert paragraph pos\n            int paraPos = bodyContainer.getParaPos(insertNewParagraph);\n            bodyContainer.setParagraph(((XWPFParagraph) (iBodyElement)), paraPos);\n            // re-update ctp reference\n            insertPostionCursor = endCtp.newCursor();\n            insertPostionCursor.toPrevSibling();\n            XmlObject object = insertPostionCursor.getObject();\n            XWPFParagraph copy = new XWPFParagraph(((CTP) (object)), bodyContainer.getTarget());\n            // update docpr\n            DrawingSupport.updateDocPrId(copy);\n            // update numbering\n            context.getNumberingContinue().updateNumbering(((XWPFParagraph) (iBodyElement)), copy);\n            copies.add(copy);\n            bodyContainer.updateBodyElements(insertNewParagraph, copy);\n            bodyContainer.setParagraph(copy, paraPos);\n        } else if (iBodyElement.getElementType() == BodyElementType.TABLE) {\n            insertPostionCursor = endCtp.newCursor();\n            XWPFTable insertNewTbl = bodyContainer.insertNewTbl(insertPostionCursor);\n            // find insert table pos\n            int tablePos = bodyContainer.getTablePos(insertNewTbl);\n            bodyContainer.setTable(tablePos, ((XWPFTable) (iBodyElement)));\n            insertPostionCursor = endCtp.newCursor();\n            insertPostionCursor.toPrevSibling();\n            XmlObject object = insertPostionCursor.getObject();\n            XWPFTable copy = new XWPFTable(((CTTbl) (object)), bodyContainer.getTarget());\n            DrawingSupport.updateDocPrId(copy);\n            copies.add(copy);\n            bodyContainer.updateBodyElements(insertNewTbl, copy);\n            bodyContainer.setTable(tablePos, copy);\n        }\n    }\n    // re-parse\n    List<MetaTemplate> templates = this.resolver.resolveBodyElements(copies);\n    // render\n    process(templates, model);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.setParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.setParagraph" ],
    "fullMethods" : [ "public void setParagraph(XWPFParagraph p) {\n    if (ctTxbxContent.sizeOfPArray() == 0) {\n        ctTxbxContent.addNewP();\n    }\n    ctTxbxContent.setPArray(0, p.getCTP());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.removeRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.removeRun" ],
    "fullMethods" : [ "public boolean removeRun(int pos) {\n    List<IRunElement> iruns = getIRuns();\n    List<XWPFRun> runs = getRuns();\n    if ((pos >= 0) && (pos < runs.size())) {\n        // Remove the run from our high level lists\n        XWPFRun run = runs.get(pos);\n        runs.remove(pos);\n        iruns.remove(run);\n        // Remove the run from the low-level XML\n        // calculate the correct pos as our run/irun list contains\n        // hyperlinks and fields so is different to the paragraph R array.\n        int rPos = 0;\n        for (int i = 0; i < pos; i++) {\n            XWPFRun currRun = runs.get(i);\n            if (run instanceof XWPFHyperlinkRun) {\n                if (currRun instanceof XWPFHyperlinkRun) {\n                    rPos++;\n                }\n            } else if (run instanceof XWPFFieldRun) {\n                if (currRun instanceof XWPFFieldRun) {\n                    rPos++;\n                }\n            } else if (!((currRun instanceof XWPFHyperlinkRun) || (currRun instanceof XWPFFieldRun))) {\n                rPos++;\n            }\n        }\n        if (run instanceof XWPFHyperlinkRun) {\n            paragraph.getCTP().removeHyperlink(rPos);\n        } else if (run instanceof XWPFFieldRun) {\n            paragraph.getCTP().removeFldSimple(rPos);\n        } else {\n            paragraph.getCTP().removeR(rPos);\n        }\n        return true;\n    }\n    return false;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewBookmarkStart",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewBookmarkStart" ],
    "fullMethods" : [ "public CTBookmark insertNewBookmarkStart(int paramInt) {\n    CTP ctp = paragraph.getCTP();\n    synchronized(ctp.monitor()) {\n        // check_orphaned();\n        CTBookmark local = null;\n        local = ((CTBookmark) (((CTPImpl) (ctp)).get_store().insert_element_user(RUN_QNAME_SET, BOOKMARK_START_QNAME, paramInt)));\n        return local;\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.AbstractIterableProcessor.visit",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.AbstractIterableProcessor.visit", "com.deepoove.poi.render.processor.IterableProcessor.handleNever" ],
    "fullMethods" : [ "@Override\npublic void visit(IterableTemplate iterableTemplate) {\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(iterableTemplate);\n    Object compute = renderDataCompute.compute(iterableTemplate.getStartMark().getTagName());\n    if ((null == compute) || ((compute instanceof Boolean) && (!((Boolean) (compute))))) {\n        handleNever(iterableTemplate, bodyContainer);\n        afterHandle(iterableTemplate, bodyContainer, true);\n    } else if (compute instanceof Iterable) {\n        handleIterable(iterableTemplate, bodyContainer, ((Iterable<?>) (compute)));\n        afterHandle(iterableTemplate, bodyContainer, false);\n    } else {\n        if ((compute instanceof Boolean) && ((Boolean) (compute))) {\n            handleOnceWithScope(iterableTemplate, renderDataCompute);\n        } else {\n            handleOnce(iterableTemplate, compute);\n        }\n        afterHandle(iterableTemplate, bodyContainer, false);\n    }\n}", "@Override\nprotected void handleNever(IterableTemplate iterableTemplate, BodyContainer bodyContainer) {\n    XWPFParagraph startParagraph = ((XWPFParagraph) (iterableTemplate.getStartRun().getParent()));\n    XWPFParagraph endParagraph = ((XWPFParagraph) (iterableTemplate.getEndRun().getParent()));\n    int startPos = bodyContainer.getPosOfParagraphCTP(startParagraph.getCTP());\n    int endPos = bodyContainer.getPosOfParagraphCTP(endParagraph.getCTP());\n    // remove content\n    for (int i = endPos - 1; i > startPos; i--) {\n        bodyContainer.removeBodyElement(i);\n    }\n    XWPFParagraphWrapper startParagraphWrapper = new XWPFParagraphWrapper(startParagraph);\n    XWPFParagraphWrapper endParagraphWrapper = new XWPFParagraphWrapper(endParagraph);\n    Integer startRunPos = iterableTemplate.getStartMark().getRunPos();\n    Integer endRunPos = iterableTemplate.getEndMark().getRunPos();\n    // remove run content\n    List<XWPFRun> startRuns = startParagraph.getRuns();\n    int startSize = startRuns.size();\n    for (int i = startSize - 1; i > startRunPos; i--) {\n        startParagraphWrapper.removeRun(i);\n    }\n    for (int i = endRunPos - 1; i >= 0; i--) {\n        endParagraphWrapper.removeRun(i);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewHyperlink",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewHyperlink" ],
    "fullMethods" : [ "public CTHyperlink insertNewHyperlink(int paramInt) {\n    CTP ctp = paragraph.getCTP();\n    synchronized(ctp.monitor()) {\n        // check_orphaned();\n        CTHyperlink localCTHyperlink = null;\n        localCTHyperlink = ((CTHyperlink) (((CTPImpl) (ctp)).get_store().insert_element_user(RUN_QNAME_SET, HYPER_QNAME, paramInt)));\n        return localCTHyperlink;\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.removeParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.removeParagraph" ],
    "fullMethods" : [ "/**\n * Removes a specific paragraph from this textbox\n *\n * @param paragraph\n * \t\t- {@link XWPFParagraph} object to remove\n */\npublic void removeParagraph(XWPFParagraph paragraph) {\n    if (paragraphs.contains(paragraph)) {\n        CTP ctP = paragraph.getCTP();\n        XmlCursor c = ctP.newCursor();\n        c.removeXml();\n        c.dispose();\n        paragraphs.remove(paragraph);\n        sdtElements.remove(paragraph);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderCell",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderCell" ],
    "fullMethods" : [ "public static void renderCell(XWPFTableCell cell, CellRenderData data, CellStyle defaultCellStyle, Style defaultTextStyle) throws Exception {\n    if (null == data)\n        return;\n\n    StyleUtils.styleTableCell(cell, defaultCellStyle);\n    StyleUtils.styleTableCell(cell, data.getCellStyle());\n    List<ParagraphStyle> defaultParaStyles = new ArrayList<>();\n    if (null != defaultTextStyle) {\n        defaultParaStyles.add(ParagraphStyle.builder().withDefaultTextStyle(defaultTextStyle).build());\n    }\n    if (null != defaultCellStyle) {\n        defaultParaStyles.add(defaultCellStyle.getDefaultParagraphStyle());\n    }\n    if (null != data.getCellStyle()) {\n        defaultParaStyles.add(data.getCellStyle().getDefaultParagraphStyle());\n    }\n    List<ParagraphRenderData> contents = data.getParagraphs();\n    if ((null != contents) && (!contents.isEmpty())) {\n        BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(cell);\n        XWPFParagraph placeHolder = cell.getParagraphArray(0);\n        if (null == placeHolder)\n            placeHolder = cell.addParagraph();\n\n        for (ParagraphRenderData item : contents) {\n            XWPFParagraph paragraph = bodyContainer.insertNewParagraph(placeHolder.getCTP().newCursor());\n            ParagraphRenderPolicy.Helper.renderParagraph(paragraph.createRun(), item, defaultParaStyles);\n        }\n        List<XWPFParagraph> paragraphs = cell.getParagraphs();\n        int pos = paragraphs.indexOf(placeHolder);\n        if ((-1) != pos)\n            cell.removeParagraph(pos);\n\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.SDTBodyContainer.setParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.SDTBodyContainer.setParagraph" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setParagraph(XWPFParagraph paragraph, int pos) {\n    List<XWPFParagraph> paragraphs = ((List<XWPFParagraph>) (ReflectionUtils.getValue(\"paragraphs\", sdtContent)));\n    paragraphs.set(pos, paragraph);\n    CTSdtContentBlock sdtContentBlock = sdtContent.getSdtContentBlock();\n    sdtContentBlock.setPArray(pos, paragraph.getCTP());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewCommentRangeStart",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewCommentRangeStart" ],
    "fullMethods" : [ "public void insertNewCommentRangeStart(XWPFRun run, BigInteger cId) {\n    int pos = getPosOfRun(run);\n    CTP ctp = paragraph.getCTP();\n    synchronized(ctp.monitor()) {\n        // check_orphaned();\n        CTMarkupRange mark = ((CTMarkupRange) (((CTPImpl) (ctp)).get_store().insert_element_user(RUN_QNAME_SET, COMMENT_START_QNAME, pos)));\n        mark.setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.setAndUpdateRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.setAndUpdateRun" ],
    "fullMethods" : [ "public void setAndUpdateRun(XWPFRun xwpfRun, XWPFRun source, int insertPostionCursor) {\n    // body\n    // maybe need find correct position:rPos;\n    int rPos = 0;\n    List<XWPFRun> runs = getRuns();\n    if ((insertPostionCursor >= 0) && (insertPostionCursor <= runs.size())) {\n        // calculate the correct pos as our run/irun list contains\n        // hyperlinks\n        // and fields so it is different to the paragraph R array.\n        for (int i = 0; i < insertPostionCursor; i++) {\n            XWPFRun currRun = runs.get(i);\n            if (xwpfRun instanceof XWPFHyperlinkRun) {\n                if (currRun instanceof XWPFHyperlinkRun) {\n                    rPos++;\n                }\n            } else if (xwpfRun instanceof XWPFFieldRun) {\n                if (currRun instanceof XWPFFieldRun) {\n                    rPos++;\n                }\n            } else if (!((currRun instanceof XWPFHyperlinkRun) || (currRun instanceof XWPFFieldRun))) {\n                rPos++;\n            }\n        }\n    }\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        paragraph.getCTP().setHyperlinkArray(rPos, ((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink());\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        paragraph.getCTP().setFldSimpleArray(rPos, ((XWPFFieldRun) (xwpfRun)).getCTField());\n    } else {\n        paragraph.getCTP().setRArray(rPos, xwpfRun.getCTR());\n    }\n    // runs\n    for (int i = 0; i < runs.size(); i++) {\n        XWPFRun ele = runs.get(i);\n        if (ele == source) {\n            runs.set(i, xwpfRun);\n        }\n    }\n    // iruns\n    List<IRunElement> iruns = getIRuns();\n    for (int i = 0; i < iruns.size(); i++) {\n        IRunElement ele = iruns.get(i);\n        if (ele == source) {\n            iruns.set(i, xwpfRun);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTextboxContent.getParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTextboxContent.getParagraph" ],
    "fullMethods" : [ "/**\n * if there is a corresponding {@link XWPFParagraph} of the parameter ctp in the\n * paragraphList of this textbox the method will return this paragraph if there\n * is no corresponding {@link XWPFParagraph} the method will return null\n *\n * @param p\n * \t\tis instance of CTP and is searching for an XWPFParagraph\n * @return null if there is no XWPFParagraph with an corresponding CTPparagraph\nin the paragraphList of this table XWPFParagraph with the\ncorrespondig CTP p\n */\n@Override\npublic XWPFParagraph getParagraph(CTP p) {\n    for (XWPFParagraph paragraph : paragraphs) {\n        if (p.equals(paragraph.getCTP())) {\n            return paragraph;\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CommentBodyContainer.setParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CommentBodyContainer.setParagraph" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setParagraph(XWPFParagraph p, int paraPos) {\n    List<XWPFParagraph> paragraphs = ((List<XWPFParagraph>) (ReflectionUtils.getValue(\"paragraphs\", comment)));\n    paragraphs.set(paraPos, p);\n    CTComment ctc = comment.getCtComment();\n    ctc.setPArray(paraPos, p.getCTP());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.setParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.setParagraph" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setParagraph(XWPFParagraph p, int pos) {\n    List<XWPFParagraph> paragraphs = ((List<XWPFParagraph>) (ReflectionUtils.getValue(\"paragraphs\", cell)));\n    paragraphs.set(pos, p);\n    CTTc ctTc = cell.getCTTc();\n    ctTc.setPArray(pos, p.getCTP());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.getParagraph" ],
    "fullMethods" : [ "@Override\npublic XWPFParagraph getParagraph(CTP p) {\n    for (XWPFParagraph paragraph : paragraphs) {\n        if (p.equals(paragraph.getCTP())) {\n            return paragraph;\n        }\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFHeaderFooter\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.NumberingContinue.of",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.NumberingContinue.of" ],
    "fullMethods" : [ "public static NumberingContinue of(BodyContainer bodyContainer, int start, int end, IterableTemplate iterable) {\n    if ((start + 1) >= end)\n        return new NumberingContinue();\n\n    final List<IBodyElement> elements = bodyContainer.getBodyElements().subList(start + 1, end);\n    if (elements.isEmpty())\n        return new NumberingContinue();\n\n    CTNumPr first = null;\n    int firstPos = -1;\n    for (IBodyElement element : elements) {\n        if (element.getElementType() == BodyElementType.PARAGRAPH) {\n            XWPFParagraph paragraph = ((XWPFParagraph) (element));\n            CTP ctp = paragraph.getCTP();\n            if ((ctp.getPPr() != null) && (ctp.getPPr().getNumPr() != null)) {\n                CTNumPr numPr = ctp.getPPr().getNumPr();\n                // find first\n                if (null == first) {\n                    first = numPr;\n                    firstPos = bodyContainer.getPosOfParagraphCTP(ctp);\n                } else // first is not unique\n                if (Objects.equals(numPr.getIlvl().getVal(), first.getIlvl().getVal()) && Objects.equals(numPr.getNumId().getVal(), first.getNumId().getVal())) {\n                    first = null;\n                    break;\n                }\n            }\n        }\n    }\n    if (null == first)\n        return new NumberingContinue();\n\n    // the first is unique, if first inside other iterable section\n    List<MetaTemplate> templates = iterable.getTemplates();\n    for (MetaTemplate template : templates) {\n        if (template instanceof IterableTemplate) {\n            CTP startCtp = ((XWPFParagraph) (((IterableTemplate) (template)).getStartRun().getParent())).getCTP();\n            CTP endCtp = ((XWPFParagraph) (((IterableTemplate) (template)).getEndRun().getParent())).getCTP();\n            int startPos = bodyContainer.getPosOfParagraphCTP(startCtp);\n            if (startPos >= firstPos)\n                break;\n\n            int endPos = bodyContainer.getPosOfParagraphCTP(endCtp);\n            if ((firstPos > startPos) && (firstPos < endPos)) {\n                return new NumberingContinue();\n            }\n        }\n    }\n    return new NumberingContinue(first.getNumId().getVal());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewCommentRangeEnd",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewCommentRangeEnd" ],
    "fullMethods" : [ "public void insertNewCommentRangeEnd(XWPFRun run, BigInteger cId) {\n    int pos = getPosOfRun(run);\n    CTP ctp = paragraph.getCTP();\n    synchronized(ctp.monitor()) {\n        // check_orphaned();\n        CTMarkupRange mark = ((CTMarkupRange) (((CTPImpl) (ctp)).get_store().insert_element_user(RUN_QNAME_SET, COMMENT_END_QNAME, pos)));\n        mark.setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.BodyContainer.getPosOfParagraphCTP",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.BodyContainer.getPosOfParagraphCTP" ],
    "fullMethods" : [ "/**\n * get the position of paragraph in bodyElements\n *\n * @param ctp\n * \t\tparagraph\n * @return the position of paragraph\n */\ndefault int getPosOfParagraphCTP(CTP ctp) {\n    IBodyElement current;\n    List<IBodyElement> bodyElements = getTarget().getBodyElements();\n    for (int i = 0; i < bodyElements.size(); i++) {\n        current = bodyElements.get(i);\n        if (current.getElementType() == BodyElementType.PARAGRAPH) {\n            if (((XWPFParagraph) (current)).getCTP().equals(ctp)) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter", "com.deepoove.poi.xwpf.XWPFParagraphWrapper.isCursorInParagraph" ],
    "fullMethods" : [ "public XWPFRun insertNewRunAfter(int pos) {\n    if (pos == paragraph.getRuns().size()) {\n        return paragraph.createRun();\n    }\n    if ((pos >= 0) && (pos < paragraph.getRuns().size())) {\n        XWPFRun run = paragraph.getRuns().get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInParagraph(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInParagraph(newCursor)) {\n            boolean nextSibling = newCursor.toNextSibling();\n            if (!nextSibling) {\n                return paragraph.createRun();\n            }\n            String uri = CTR.type.getName().getNamespaceURI();\n            String localPart = \"r\";\n            newCursor.beginElement(localPart, uri);\n            newCursor.toParent();\n            CTR r = ((CTR) (newCursor.getObject()));\n            XWPFRun newRun = new XWPFRun(r, ((IRunBody) (this.paragraph)));\n            List<IRunElement> iruns = getIRuns();\n            List<XWPFRun> runs = getRuns();\n            int iPos = iruns.size();\n            if (pos < runs.size()) {\n                XWPFRun oldAtPos = runs.get(pos);\n                int oldAt = iruns.indexOf(oldAtPos);\n                if (oldAt != (-1)) {\n                    iPos = oldAt;\n                }\n            }\n            if ((iPos + 1) >= iruns.size()) {\n                iruns.add(newRun);\n            } else {\n                iruns.add(iPos + 1, newRun);\n            }\n            // Runs itself is easy to update\n            if ((pos + 1) >= runs.size()) {\n                runs.add(newRun);\n            } else {\n                runs.add(pos + 1, newRun);\n            }\n            newCursor.dispose();\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}", "private boolean isCursorInParagraph(XmlCursor cursor) {\n    XmlCursor verify = cursor.newCursor();\n    verify.toParent();\n    boolean result = verify.getObject() == this.paragraph.getCTP();\n    verify.dispose();\n    return result;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewR",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewR" ],
    "fullMethods" : [ "public CTR insertNewR(int paramInt) {\n    CTP ctp = paragraph.getCTP();\n    synchronized(ctp.monitor()) {\n        // check_orphaned();\n        CTR localCTR = null;\n        localCTR = ((CTR) (((CTPImpl) (ctp)).get_store().insert_element_user(RUN_QNAME_SET, R_QNAME, paramInt)));\n        return localCTR;\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getCTP",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CTPictWrapper.getShapeAlt",
    "thirdPartyMethod" : "com.microsoft.schemas.vml.CTShape.getAlt",
    "thirdPartyPackage" : "com.microsoft.schemas.vml",
    "path" : [ "com.deepoove.poi.xwpf.CTPictWrapper.getShapeAlt" ],
    "fullMethods" : [ "public String getShapeAlt() {\n    return null == ctShape ? null : ctShape.getAlt();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CommentBodyContainer.removeBodyElement",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFComment.removeTable",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CommentBodyContainer.removeBodyElement" ],
    "fullMethods" : [ "@Override\npublic void removeBodyElement(int pos) {\n    List<IBodyElement> bodyElements = getBodyElements();\n    if ((pos >= 0) && (pos < bodyElements.size())) {\n        BodyElementType type = bodyElements.get(pos).getElementType();\n        if (type == BodyElementType.TABLE) {\n            comment.removeTable(((XWPFTable) (bodyElements.get(pos))));\n        }\n        if (type == BodyElementType.PARAGRAPH) {\n            comment.removeParagraph(((XWPFParagraph) (bodyElements.get(pos))));\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblBorders.isSetInsideH",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTStyle.xgetDefault",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeStyles" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "@SuppressWarnings(\"unchecked\")\nprotected Map<String, String> mergeStyles(NiceXWPFDocument source, NiceXWPFDocument merged) {\n    Map<String, String> styleIdsMap = new HashMap<String, String>();\n    XWPFStyles styles = source.getStyles();\n    if (null == styles)\n        styles = source.createStyles();\n\n    XWPFStyles stylesMerge = merged.getStyles();\n    if (null == stylesMerge)\n        return styleIdsMap;\n\n    try {\n        Field listStyleField = XWPFStyles.class.getDeclaredField(\"listStyle\");\n        listStyleField.setAccessible(true);\n        List<XWPFStyle> lists = ((List<XWPFStyle>) (listStyleField.get(stylesMerge)));\n        String defaultParaStyleId = null;\n        for (XWPFStyle xwpfStyle : lists) {\n            if (styles.styleExist(xwpfStyle.getStyleId())) {\n                if (!getRenameAndMergeExistsStyle()) {\n                    continue;\n                }\n                String id = xwpfStyle.getStyleId();\n                xwpfStyle.setStyleId(UUID.randomUUID().toString().substring(0, 8));\n                styleIdsMap.put(id, xwpfStyle.getStyleId());\n            }\n            // fix github issue 499\n            CTStyle ctStyle = xwpfStyle.getCTStyle();\n            if ((ctStyle.isSetDefault() && POIXMLUnits.parseOnOff(ctStyle.xgetDefault())) && (ctStyle.getType() == STStyleType.PARAGRAPH)) {\n                defaultParaStyleId = ctStyle.getStyleId();\n            }\n            if (ctStyle.isSetDefault()) {\n                ctStyle.unsetDefault();\n            }\n            if (ctStyle.isSetName() && StringUtils.isBlank(ctStyle.getName().getVal())) {\n                ctStyle.getName().setVal(ctStyle.getName().getVal() + xwpfStyle.getStyleId());\n            }\n            if (ctStyle.isSetBasedOn()) {\n                String newId = styleIdsMap.get(ctStyle.getBasedOn().getVal());\n                if (null != newId)\n                    ctStyle.getBasedOn().setVal(newId);\n\n            }\n            styles.addStyle(xwpfStyle);\n        }\n        if (null != defaultParaStyleId) {\n            final String dpid = defaultParaStyleId;\n            merged.getParagraphs().stream().filter(p -> null == p.getStyle()).forEach(p -> p.setStyle(dpid));\n        }\n    } catch (Exception e) {\n        // throw exception?\n        logger.error(\"merge style error\", e);\n    }\n    return styleIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr.isSetKeepLines",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.NumberingContinue.updateNumbering",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.setNumID",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.NumberingContinue.updateNumbering" ],
    "fullMethods" : [ "public void updateNumbering(XWPFParagraph source, XWPFParagraph target) {\n    XWPFDocument document = source.getDocument();\n    XWPFNumbering numbering = document.getNumbering();\n    if (null == numbering)\n        return;\n\n    BigInteger numID = source.getNumID();\n    if (numID == null)\n        return;\n\n    if ((null != continueNumID) && numID.equals(continueNumID)) {\n        return;\n    }\n    if (consistCache.get(numID) != null) {\n        target.setNumID(consistCache.get(numID));\n        return;\n    }\n    XWPFNumberingWrapper wrapper = new XWPFNumberingWrapper(numbering);\n    XWPFNum num = numbering.getNum(numID);\n    if (null == num)\n        return;\n\n    XWPFAbstractNum abstractNum = numbering.getAbstractNum(num.getCTNum().getAbstractNumId().getVal());\n    CTAbstractNum ctAbstractNum = ((CTAbstractNum) (abstractNum.getAbstractNum().copy()));\n    ctAbstractNum.setAbstractNumId(wrapper.getNextAbstractNumID());\n    // clear continues list\n    // (related to tracking numbering definitions when documents are\n    // repurposed and\n    // changed\n    if (ctAbstractNum.isSetNsid())\n        ctAbstractNum.unsetNsid();\n\n    // related to where the definition can be displayed in the user\n    // interface\n    if (ctAbstractNum.isSetTmpl())\n        ctAbstractNum.unsetTmpl();\n\n    BigInteger abstractNumID = numbering.addAbstractNum(new XWPFAbstractNum(ctAbstractNum));\n    BigInteger newNumId = numbering.addNum(abstractNumID);\n    target.setNumID(newNumId);\n    consistCache.put(numID, newNumId);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.NumberingRenderPolicy.Helper.renderNumbering",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.setNumID",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.NumberingRenderPolicy.Helper.renderNumbering" ],
    "fullMethods" : [ "public static void renderNumbering(XWPFRun run, NumberingRenderData data) throws Exception {\n    List<NumberingItemRenderData> items = data.getItems();\n    NumberingFormat[] array = data.getFormats().toArray(new NumberingFormat[]{  });\n    BigInteger numID = ((NiceXWPFDocument) (run.getParent().getDocument())).addNewMultiLevelNumberingId(array);\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    for (NumberingItemRenderData item : items) {\n        XWPFParagraph paragraph = bodyContainer.insertNewParagraph(run);\n        int level = item.getLevel();\n        if (NumberingItemRenderData.LEVEL_NORMAL != level) {\n            paragraph.setNumID(numID);\n            paragraph.setNumILvl(BigInteger.valueOf(level));\n        }\n        XWPFRun createRun = paragraph.createRun();\n        // StyleUtils.styleParaRpr(paragraph, StyleUtils.retriveStyle(run));\n        StyleUtils.styleRun(createRun, run);\n        ParagraphRenderPolicy.Helper.renderParagraph(createRun, item.getItem());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.setNumID",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ChartUtils.getChartSeries",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPlotArea.sizeOfOfPieChartArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.util.ChartUtils.getChartSeries" ],
    "fullMethods" : [ "public static List<XDDFChartData> getChartSeries(XWPFChart chart) {\n    List<XDDFChartData> series = new LinkedList<>();\n    List<XDDFChartData> chartSeries = chart.getChartSeries();\n    series.addAll(chartSeries);\n    CTPlotArea plotArea = chart.getCTChart().getPlotArea();\n    for (int i = 0; i < plotArea.sizeOfOfPieChartArray(); i++) {\n        CTOfPieChart barChart = plotArea.getOfPieChartArray(i);\n        series.add(new XDDFOfPieChartData(chart, barChart));\n    }\n    return series;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.sizeOfRFontsArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTShd.xgetFill",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyle(XWPFParagraph paragraph) {\n    if (null == paragraph)\n        return null;\n\n    Builder builder = ParagraphStyle.builder();\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    if (paragraph.isWordWrapped()) {\n        builder.withAllowWordBreak(true);\n    }\n    if (pr.isSetPBdr()) {\n        CTPBdr ct = pr.getPBdr();\n        if (ct.isSetLeft()) {\n            builder.withLeftBorder(retriveBorderStyle(ct.getLeft()));\n        }\n        if (ct.isSetTop()) {\n            builder.withTopBorder(retriveBorderStyle(ct.getTop()));\n        }\n        if (ct.isSetRight()) {\n            builder.withRightBorder(retriveBorderStyle(ct.getRight()));\n        }\n        if (ct.isSetBottom()) {\n            builder.withBottomBorder(retriveBorderStyle(ct.getBottom()));\n        }\n    }\n    if (pr.isSetShd()) {\n        CTShd shd = pr.getShd();\n        builder.withShadingPattern(XWPFShadingPattern.valueOf(shd.getVal().intValue()));\n        if (shd.isSetFill())\n            builder.withBackgroundColor(shd.xgetFill().getStringValue());\n\n    }\n    builder.withAlign(paragraph.getAlignment());\n    int spacingBeforeLines = paragraph.getSpacingBeforeLines();\n    if ((-1) != spacingBeforeLines) {\n        builder.withSpacingBeforeLines(spacingBeforeLines / 100.0F);\n    }\n    int spacingAfterLines = paragraph.getSpacingAfterLines();\n    if ((-1) != spacingAfterLines) {\n        builder.withSpacingAfterLines(spacingAfterLines / 100.0F);\n    }\n    int spacingBefore = paragraph.getSpacingBefore();\n    if ((-1) != spacingBefore) {\n        builder.withSpacingBefore(UnitUtils.twips2Point(spacingBefore));\n    }\n    int spacingAfter = paragraph.getSpacingAfter();\n    if ((-1) != spacingAfter) {\n        builder.withSpacingAfter(UnitUtils.twips2Point(spacingAfter));\n    }\n    double spacingBetween = paragraph.getSpacingBetween();\n    if ((-1) != spacingBetween) {\n        builder.withSpacing(spacingBetween);\n        builder.withSpacingRule(paragraph.getSpacingLineRule());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.setTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getCTTbl",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.setTable" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setTable(int pos, XWPFTable table) {\n    // cell.getTables().set(pos, table);\n    List<XWPFTable> tables = ((List<XWPFTable>) (ReflectionUtils.getValue(\"tables\", headerFooter)));\n    tables.set(pos, table);\n    headerFooter._getHdrFtr().setTblArray(pos, table.getCTTbl());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.setTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getCTTbl",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.setTable" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setTable(int pos, XWPFTable table) {\n    // cell.getTables().set(pos, table);\n    List<XWPFTable> tables = ((List<XWPFTable>) (ReflectionUtils.getValue(\"tables\", cell)));\n    tables.set(pos, table);\n    cell.getCTTc().setTblArray(pos, table.getCTTbl());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CommentBodyContainer.setTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getCTTbl",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CommentBodyContainer.setTable" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void setTable(int pos, XWPFTable table) {\n    // cell.getTables().set(pos, table);\n    List<XWPFTable> tables = ((List<XWPFTable>) (ReflectionUtils.getValue(\"tables\", comment)));\n    tables.set(pos, table);\n    comment.getCtComment().setTblArray(pos, table.getCTTbl());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.setWidth",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getCTTbl",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.setWidth", "com.deepoove.poi.util.TableTools.ensureTblW" ],
    "fullMethods" : [ "/**\n * set table width\n *\n * @param table\n * @param width\n * @param colWidths\n */\npublic static void setWidth(XWPFTable table, String width, int[] colWidths) {\n    ensureTblW(table);\n    table.setWidth(width);\n    if (null == colWidths) {\n        int columnSize = TableTools.obtainColumnSize(table);\n        if (table.getWidthType() == TableWidthType.DXA) {\n            colWidths = UnitUtils.average(Integer.valueOf(width), columnSize);\n        } else if (table.getWidthType() == TableWidthType.PCT) {\n            int sum = 0;\n            colWidths = new int[columnSize];\n            for (int i = 0; i < (columnSize - 1); i++) {\n                colWidths[i] = 100 / columnSize;\n                sum += colWidths[i];\n            }\n            colWidths[columnSize - 1] = 100 - sum;\n        }\n    }\n    if (null != colWidths) {\n        BigInteger[] gridCol = null;\n        String[] cellWidth = null;\n        if (table.getWidthType() == TableWidthType.DXA) {\n            cellWidth = Arrays.stream(colWidths).mapToObj(String::valueOf).toArray(String[]::new);\n            gridCol = Arrays.stream(colWidths).mapToObj(BigInteger::valueOf).toArray(BigInteger[]::new);\n        } else if (table.getWidthType() == TableWidthType.PCT) {\n            cellWidth = Arrays.stream(colWidths).mapToObj(w -> w + \"%\").toArray(String[]::new);\n            BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(table.getBody());\n            int pageWidth = bodyContainer.elementPageWidth(table);\n            int tableWidth = (pageWidth * Integer.valueOf(width.substring(0, width.length() - 1))) / 100;\n            gridCol = Arrays.stream(colWidths).mapToObj(w -> BigInteger.valueOf((w * tableWidth) / 100)).toArray(BigInteger[]::new);\n        }\n        CTTblGrid tblGrid = TableTools.getTblGrid(table);\n        CTTblLayoutType tblLayout = TableTools.getTblLayout(table);\n        tblLayout.setType(STTblLayoutType.FIXED);\n        for (int index = 0; index < colWidths.length; index++) {\n            if (null != gridCol) {\n                CTTblGridCol addNewGridCol = tblGrid.addNewGridCol();\n                addNewGridCol.setW(gridCol[index]);\n            }\n            List<XWPFTableRow> rows = table.getRows();\n            for (XWPFTableRow row : rows) {\n                row.getCell(index).setWidth(cellWidth[index]);\n            }\n        }\n    }\n}", "private static void ensureTblW(XWPFTable table) {\n    CTTbl ctTbl = table.getCTTbl();\n    CTTblPr tblPr = (ctTbl.getTblPr() != null) ? ctTbl.getTblPr() : ctTbl.addNewTblPr();\n    if (!tblPr.isSetTblW())\n        tblPr.addNewTblW();\n\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.getTblGrid",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getCTTbl",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.getTblGrid" ],
    "fullMethods" : [ "public static CTTblGrid getTblGrid(XWPFTable table) {\n    CTTblGrid tblGrid = table.getCTTbl().getTblGrid();\n    if (null == tblGrid) {\n        tblGrid = table.getCTTbl().addNewTblGrid();\n    }\n    return tblGrid;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.getTblLayout",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getCTTbl",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.getTblLayout", "com.deepoove.poi.util.TableTools.getTblPr" ],
    "fullMethods" : [ "public static CTTblLayoutType getTblLayout(XWPFTable table) {\n    CTTblPr tblPr = getTblPr(table);\n    return tblPr.isSetTblLayout() ? tblPr.getTblLayout() : tblPr.addNewTblLayout();\n}", "private static CTTblPr getTblPr(XWPFTable table) {\n    CTTblPr tblPr = table.getCTTbl().getTblPr();\n    if (null == tblPr) {\n        tblPr = table.getCTTbl().addNewTblPr();\n    }\n    return tblPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.widthTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getCTTbl",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.widthTable", "com.deepoove.poi.util.TableTools.getTblPr" ],
    "fullMethods" : [ "@Deprecated\npublic static void widthTable(XWPFTable table, float widthCM, int cols) {\n    int width = UnitUtils.cm2Twips(widthCM);\n    CTTblPr tblPr = getTblPr(table);\n    CTTblWidth tblW = (tblPr.isSetTblW()) ? tblPr.getTblW() : tblPr.addNewTblW();\n    tblW.setType(0 == width ? STTblWidth.AUTO : STTblWidth.DXA);\n    tblW.setW(BigInteger.valueOf(width));\n    if (0 != width) {\n        CTTblGrid tblGrid = getTblGrid(table);\n        for (int j = 0; j < cols; j++) {\n            CTTblGridCol addNewGridCol = tblGrid.addNewGridCol();\n            addNewGridCol.setW(BigInteger.valueOf(width / cols));\n        }\n    }\n}", "private static CTTblPr getTblPr(XWPFTable table) {\n    CTTblPr tblPr = table.getCTTbl().getTblPr();\n    if (null == tblPr) {\n        tblPr = table.getCTTbl().addNewTblPr();\n    }\n    return tblPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.widthTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getCTTbl",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.widthTable", "com.deepoove.poi.util.TableTools.getTblPr" ],
    "fullMethods" : [ "@Deprecated\npublic static void widthTable(XWPFTable table, float[] colWidths) {\n    float widthCM = 0;\n    for (float w : colWidths) {\n        widthCM += w;\n    }\n    int width = UnitUtils.cm2Twips(widthCM);\n    CTTblPr tblPr = getTblPr(table);\n    CTTblWidth tblW = (tblPr.isSetTblW()) ? tblPr.getTblW() : tblPr.addNewTblW();\n    tblW.setType(0 == width ? STTblWidth.AUTO : STTblWidth.DXA);\n    tblW.setW(BigInteger.valueOf(width));\n    if (0 != width) {\n        CTTblGrid tblGrid = getTblGrid(table);\n        for (float w : colWidths) {\n            CTTblGridCol addNewGridCol = tblGrid.addNewGridCol();\n            addNewGridCol.setW(BigInteger.valueOf(UnitUtils.cm2Twips(w)));\n        }\n    }\n}", "private static CTTblPr getTblPr(XWPFTable table) {\n    CTTblPr tblPr = table.getCTTbl().getTblPr();\n    if (null == tblPr) {\n        tblPr = table.getCTTbl().addNewTblPr();\n    }\n    return tblPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getCTTbl",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable", "com.deepoove.poi.util.TableTools.getTblPr" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}", "private static CTTblPr getTblPr(XWPFTable table) {\n    CTTblPr tblPr = table.getCTTbl().getTblPr();\n    if (null == tblPr) {\n        tblPr = table.getCTTbl().addNewTblPr();\n    }\n    return tblPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getCTTbl",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTable" ],
    "fullMethods" : [ "/**\n * set table style\n *\n * @param table\n * @param tableStyle\n */\npublic static void styleTable(XWPFTable table, TableStyle tableStyle) {\n    if ((null == table) || (null == tableStyle))\n        return;\n\n    TableTools.setWidth(table, tableStyle.getWidth(), tableStyle.getColWidths());\n    TableTools.setBorder(table::setLeftBorder, tableStyle.getLeftBorder());\n    TableTools.setBorder(table::setRightBorder, tableStyle.getRightBorder());\n    TableTools.setBorder(table::setTopBorder, tableStyle.getTopBorder());\n    TableTools.setBorder(table::setBottomBorder, tableStyle.getBottomBorder());\n    TableTools.setBorder(table::setInsideHBorder, tableStyle.getInsideHBorder());\n    TableTools.setBorder(table::setInsideVBorder, tableStyle.getInsideVBorder());\n    if (null != tableStyle.getAlign()) {\n        table.setTableAlignment(tableStyle.getAlign());\n    }\n    table.setCellMargins(tableStyle.getTopCellMargin(), tableStyle.getLeftCellMargin(), tableStyle.getBottomCellMargin(), tableStyle.getRightCellMargin());\n    if (null != tableStyle.getIndentation()) {\n        CTTbl ctTbl = table.getCTTbl();\n        CTTblPr tPr = (ctTbl.getTblPr() != null) ? ctTbl.getTblPr() : ctTbl.addNewTblPr();\n        CTTblWidth tw = (tPr.isSetTblInd()) ? tPr.getTblInd() : tPr.addNewTblInd();\n        tw.setType(STTblWidth.DXA);\n        tw.setW(BigInteger.valueOf(UnitUtils.cm2Twips(tableStyle.getIndentation())));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.getCTTbl",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render", "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.setTableRow" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        if ((null != data) && (data instanceof Iterable)) {\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            XWPFTableRow templateRow = table.getRow(templateRowIndex);\n            int insertPosition = templateRowIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            boolean firstFlag = true;\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateRowIndex++;\n                XWPFTableRow nextRow = table.insertNewTableRow(insertPosition);\n                setTableRow(table, templateRow, insertPosition);\n                // double set row\n                XmlCursor newCursor = templateRow.getCtRow().newCursor();\n                newCursor.toPrevSibling();\n                XmlObject object = newCursor.getObject();\n                nextRow = new XWPFTableRow(((CTRow) (object)), table);\n                if (!firstFlag) {\n                    // update VMerge cells for non-first row\n                    List<XWPFTableCell> tableCells = nextRow.getTableCells();\n                    for (XWPFTableCell cell : tableCells) {\n                        CTTcPr tcPr = TableTools.getTcPr(cell);\n                        CTVMerge vMerge = tcPr.getVMerge();\n                        if (null == vMerge)\n                            continue;\n\n                        if (STMerge.RESTART == vMerge.getVal()) {\n                            vMerge.setVal(STMerge.CONTINUE);\n                        }\n                    }\n                } else {\n                    firstFlag = false;\n                }\n                setTableRow(table, nextRow, insertPosition);\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                List<XWPFTableCell> cells = nextRow.getTableCells();\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        table.removeRow(templateRowIndex);\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \" error: \") + e.getMessage(), e);\n    }\n}", "@SuppressWarnings(\"unchecked\")\nprivate void setTableRow(XWPFTable table, XWPFTableRow templateRow, int pos) {\n    List<XWPFTableRow> rows = ((List<XWPFTableRow>) (ReflectionUtils.getValue(\"tableRows\", table)));\n    rows.set(pos, templateRow);\n    table.getCTTbl().setTrArray(pos, templateRow.getCtRow());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.apache.xmlbeans.impl.schema.SimpleTypeFactory.newInstance",
    "thirdPartyPackage" : "org.apache.xmlbeans.impl.schema",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.addSeries",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTOfPieChart.addNewSer",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.addSeries" ],
    "fullMethods" : [ "@Override\npublic XDDFChartData.Series addSeries(XDDFDataSource<?> category, XDDFNumericalDataSource<? extends Number> values) {\n    final long index = ++this.seriesNum;\n    final CTPieSer ctSer = this.chart.addNewSer();\n    ctSer.addNewCat();\n    ctSer.addNewVal();\n    ctSer.addNewIdx().setVal(index);\n    ctSer.addNewOrder().setVal(index);\n    final Series added = new Series(ctSer, category, values);\n    this.series.add(added);\n    return added;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTInd.isSetRight",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.mergeCellsHorizonal",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.removeCell",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.mergeCellsHorizonal" ],
    "fullMethods" : [ "/**\n * merge several columns of cells in the same row\n *\n * @param table\n * \t\ttable\n * @param row\n * \t\tindex of the row\n * @param fromCol\n * \t\tfrom column to be merged\n * @param toCol\n * \t\tto column to be merged\n */\npublic static void mergeCellsHorizonal(XWPFTable table, int row, int fromCol, int toCol) {\n    Preconditions.requireGreaterThan(toCol, fromCol, \"To column to be merged must greater than from column.\");\n    mergeCellsHorizontalWithoutRemove(table, row, fromCol, toCol);\n    XWPFTableRow rowTable = table.getRow(row);\n    for (int colIndex = fromCol + 1; colIndex <= toCol; colIndex++) {\n        rowTable.removeCell(fromCol + 1);\n        if (rowTable.getTableCells().size() != rowTable.getCtRow().sizeOfTcArray()) {\n            rowTable.getCtRow().removeTc(fromCol + 1);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.removeCell",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderTable", "com.deepoove.poi.policy.TableRenderPolicy.Helper.applyMergeRule" ],
    "fullMethods" : [ "public static XWPFTable renderTable(XWPFRun run, TableRenderData data) throws Exception {\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    XWPFTable table = bodyContainer.insertNewTable(run, data.obtainRowSize(), data.obtainColSize());\n    StyleUtils.styleTable(table, data.getTableStyle());\n    int size = table.getRows().size();\n    for (int i = 0; i < size; i++) {\n        RowRenderData rowRenderData = data.getRows().get(i);\n        renderRow(table.getRows().get(i), rowRenderData, StyleUtils.retriveStyle(run));\n    }\n    applyMergeRule(table, data.getMergeRule());\n    return table;\n}", "private static void applyMergeRule(XWPFTable table, MergeCellRule mergeRule) {\n    if (null == mergeRule)\n        return;\n\n    byte[][] markRemovedCell = new byte[TableTools.obtainRowSize(table)][TableTools.obtainColumnSize(table)];\n    Iterator<Entry<Grid, Grid>> iterator = mergeRule.mappingIterator();\n    while (iterator.hasNext()) {\n        Entry<Grid, Grid> next = iterator.next();\n        Grid key = next.getKey();\n        Grid value = next.getValue();\n        int startI = (key.getI() > value.getI()) ? value.getI() : key.getI();\n        int startJ = (key.getJ() > value.getJ()) ? value.getJ() : key.getJ();\n        int endI = (key.getI() > value.getI()) ? key.getI() : value.getI();\n        int endJ = (key.getJ() > value.getJ()) ? key.getJ() : value.getJ();\n        // merge(VMerge mark) vertical\n        if (startI != endI) {\n            for (int j = startJ; j <= endJ; j++) {\n                TableTools.mergeCellsVertically(table, j, startI, endI);\n            }\n        }\n        // merge horizontal cells without remove cells\n        if (startJ != endJ) {\n            for (int i = startI; i <= endI; i++) {\n                TableTools.mergeCellsHorizontalWithoutRemove(table, i, startJ, endJ);\n                for (int removedCol = startJ + 1; removedCol <= endJ; removedCol++) {\n                    markRemovedCell[i][removedCol] = 1;\n                }\n            }\n        }\n    } \n    // remove marked cell safely\n    for (int i = 0; i < markRemovedCell.length; i++) {\n        for (int j = markRemovedCell[i].length - 1; j >= 0; j--) {\n            if (markRemovedCell[i][j] >= 1) {\n                table.getRow(i).removeCell(j);\n                if (table.getRow(i).getTableCells().size() != table.getRow(i).getCtRow().sizeOfTcArray()) {\n                    table.getRow(i).getCtRow().removeTc(j);\n                }\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setExplosion",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.isSetExplosion",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setExplosion" ],
    "fullMethods" : [ "public void setExplosion(Long explosion) {\n    if (explosion == null) {\n        if (series.isSetExplosion()) {\n            series.unsetExplosion();\n        }\n    } else if (series.isSetExplosion()) {\n        series.getExplosion().setVal(explosion);\n    } else {\n        series.addNewExplosion().setVal(explosion);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.getExplosion",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPieSer.isSetExplosion",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.getExplosion" ],
    "fullMethods" : [ "public Long getExplosion() {\n    if (series.isSetExplosion()) {\n        return series.getExplosion().getVal();\n    } else {\n        return null;\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.getIArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.compute.ReadMapAccessor.generateCode",
    "thirdPartyMethod" : "org.springframework.expression.spel.CodeFlow.lastDescriptor",
    "thirdPartyPackage" : "org.springframework.expression.spel",
    "path" : [ "com.deepoove.poi.render.compute.ReadMapAccessor.generateCode" ],
    "fullMethods" : [ "@Override\npublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n    String descriptor = cf.lastDescriptor();\n    if ((descriptor == null) || (!descriptor.equals(\"Ljava/util/Map\"))) {\n        if (descriptor == null) {\n            cf.loadTarget(mv);\n        }\n        CodeFlow.insertCheckCast(mv, \"Ljava/util/Map\");\n    }\n    mv.visitLdcInsn(propertyName);\n    mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", true);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.setAndUpdateRun",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTP.setFldSimpleArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.setAndUpdateRun" ],
    "fullMethods" : [ "public void setAndUpdateRun(XWPFRun xwpfRun, XWPFRun source, int insertPostionCursor) {\n    // body\n    // maybe need find correct position:rPos;\n    int rPos = 0;\n    List<XWPFRun> runs = getRuns();\n    if ((insertPostionCursor >= 0) && (insertPostionCursor <= runs.size())) {\n        // calculate the correct pos as our run/irun list contains\n        // hyperlinks\n        // and fields so it is different to the paragraph R array.\n        for (int i = 0; i < insertPostionCursor; i++) {\n            XWPFRun currRun = runs.get(i);\n            if (xwpfRun instanceof XWPFHyperlinkRun) {\n                if (currRun instanceof XWPFHyperlinkRun) {\n                    rPos++;\n                }\n            } else if (xwpfRun instanceof XWPFFieldRun) {\n                if (currRun instanceof XWPFFieldRun) {\n                    rPos++;\n                }\n            } else if (!((currRun instanceof XWPFHyperlinkRun) || (currRun instanceof XWPFFieldRun))) {\n                rPos++;\n            }\n        }\n    }\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        paragraph.getCTP().setHyperlinkArray(rPos, ((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink());\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        paragraph.getCTP().setFldSimpleArray(rPos, ((XWPFFieldRun) (xwpfRun)).getCTField());\n    } else {\n        paragraph.getCTP().setRArray(rPos, xwpfRun.getCTR());\n    }\n    // runs\n    for (int i = 0; i < runs.size(); i++) {\n        XWPFRun ele = runs.get(i);\n        if (ele == source) {\n            runs.set(i, xwpfRun);\n        }\n    }\n    // iruns\n    List<IRunElement> iruns = getIRuns();\n    for (int i = 0; i < iruns.size(); i++) {\n        IRunElement ele = iruns.get(i);\n        if (ele == source) {\n            iruns.set(i, xwpfRun);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.SDTContentContext.createRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFFieldRun.getCTField",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.SDTContentContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XWPFRun xwpfRun, IRunBody p) {\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink().copy())), ((CTR) (((XWPFHyperlinkRun) (xwpfRun)).getCTR().copy())), p);\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        return new XWPFFieldRun(((CTSimpleField) (((XWPFFieldRun) (xwpfRun)).getCTField().copy())), ((CTR) (((XWPFFieldRun) (xwpfRun)).getCTR().copy())), p);\n    } else {\n        return new XWPFRun(((CTR) (xwpfRun.getCTR().copy())), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.setAndUpdateRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFFieldRun.getCTField",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.setAndUpdateRun" ],
    "fullMethods" : [ "public void setAndUpdateRun(XWPFRun xwpfRun, XWPFRun source, int insertPostionCursor) {\n    // body\n    // maybe need find correct position:rPos;\n    int rPos = 0;\n    List<XWPFRun> runs = getRuns();\n    if ((insertPostionCursor >= 0) && (insertPostionCursor <= runs.size())) {\n        // calculate the correct pos as our run/irun list contains\n        // hyperlinks\n        // and fields so it is different to the paragraph R array.\n        for (int i = 0; i < insertPostionCursor; i++) {\n            XWPFRun currRun = runs.get(i);\n            if (xwpfRun instanceof XWPFHyperlinkRun) {\n                if (currRun instanceof XWPFHyperlinkRun) {\n                    rPos++;\n                }\n            } else if (xwpfRun instanceof XWPFFieldRun) {\n                if (currRun instanceof XWPFFieldRun) {\n                    rPos++;\n                }\n            } else if (!((currRun instanceof XWPFHyperlinkRun) || (currRun instanceof XWPFFieldRun))) {\n                rPos++;\n            }\n        }\n    }\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        paragraph.getCTP().setHyperlinkArray(rPos, ((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink());\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        paragraph.getCTP().setFldSimpleArray(rPos, ((XWPFFieldRun) (xwpfRun)).getCTField());\n    } else {\n        paragraph.getCTP().setRArray(rPos, xwpfRun.getCTR());\n    }\n    // runs\n    for (int i = 0; i < runs.size(); i++) {\n        XWPFRun ele = runs.get(i);\n        if (ele == source) {\n            runs.set(i, xwpfRun);\n        }\n    }\n    // iruns\n    List<IRunElement> iruns = getIRuns();\n    for (int i = 0; i < iruns.size(); i++) {\n        IRunElement ele = iruns.get(i);\n        if (ele == source) {\n            iruns.set(i, xwpfRun);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.toc.TOCRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFFieldRun.getCTField",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.toc.TOCRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    XWPFRun run = ((RunTemplate) (eleTemplate)).getRun();\n    run.setText(\"\", 0);\n    XWPFParagraph tocPara = ((XWPFParagraph) (run.getParent()));\n    XWPFFieldRun fieldRun = tocPara.insertNewFieldRun(0);\n    CTSimpleField toc = fieldRun.getCTField();\n    toc.setInstr(\"TOC \\\\o\");\n    toc.setDirty(XWPFOnOff.ON);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.ParagraphContext.createRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFFieldRun.getCTField",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.ParagraphContext.createRun" ],
    "fullMethods" : [ "@Override\npublic XWPFRun createRun(XWPFRun xwpfRun, IRunBody p) {\n    if (xwpfRun instanceof XWPFHyperlinkRun) {\n        return new XWPFHyperlinkRun(((CTHyperlink) (((XWPFHyperlinkRun) (xwpfRun)).getCTHyperlink().copy())), ((CTR) (((XWPFHyperlinkRun) (xwpfRun)).getCTR().copy())), p);\n    } else if (xwpfRun instanceof XWPFFieldRun) {\n        return new XWPFFieldRun(((CTSimpleField) (((XWPFFieldRun) (xwpfRun)).getCTField().copy())), ((CTR) (((XWPFFieldRun) (xwpfRun)).getCTR().copy())), p);\n    } else {\n        return new XWPFRun(((CTR) (xwpfRun.getCTR().copy())), p);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTDecimalNumber.setVal",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId" ],
    "fullMethods" : [ "public BigInteger addNewMultiLevelNumberingId(NumberingFormat... numFmts) {\n    XWPFNumbering numbering = this.getNumbering();\n    if (null == numbering) {\n        numbering = this.createNumbering();\n    }\n    XWPFNumberingWrapper numberingWrapper = new XWPFNumberingWrapper(numbering);\n    CTAbstractNum cTAbstractNum = CTAbstractNum.Factory.newInstance();\n    // if we have an existing document, we must determine the next\n    // free number first.\n    cTAbstractNum.setAbstractNumId(numberingWrapper.getNextAbstractNumID());\n    // CTMultiLevelType addNewMultiLevelType = cTAbstractNum.addNewMultiLevelType();\n    // addNewMultiLevelType.setVal(STMultiLevelType.HYBRID_MULTILEVEL);\n    for (int i = 0; i < numFmts.length; i++) {\n        NumberingFormat numFmt = numFmts[i];\n        CTLvl cTLvl = cTAbstractNum.addNewLvl();\n        CTPPrBase ppr = (cTLvl.isSetPPr()) ? cTLvl.getPPr() : cTLvl.addNewPPr();\n        CTInd ind = (ppr.isSetInd()) ? ppr.getInd() : ppr.addNewInd();\n        ind.setLeft(BigInteger.valueOf(UnitUtils.cm2Twips(0.74F) * i));\n        Enum fmt = STNumberFormat.Enum.forInt(numFmt.getNumFmt());\n        String val = numFmt.getLvlText();\n        cTLvl.addNewNumFmt().setVal(fmt);\n        cTLvl.addNewLvlText().setVal(val);\n        cTLvl.addNewStart().setVal(BigInteger.valueOf(1));\n        cTLvl.setIlvl(BigInteger.valueOf(i));\n        if (fmt == STNumberFormat.BULLET) {\n            cTLvl.addNewLvlJc().setVal(STJc.LEFT);\n            CTRPr addNewRPr = cTLvl.addNewRPr();\n            CTFonts ctFonts = addNewRPr.addNewRFonts();\n            ctFonts.setAscii(\"Wingdings\");\n            ctFonts.setHAnsi(\"Wingdings\");\n            ctFonts.setHint(STHint.DEFAULT);\n        }\n    }\n    XWPFAbstractNum abstractNum = new XWPFAbstractNum(cTAbstractNum);\n    BigInteger abstractNumID = numbering.addAbstractNum(abstractNum);\n    return numbering.addNum(abstractNumID);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTDecimalNumber.setVal",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render", "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.minusGridSpan" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        for (int i = rowSize - 1; i >= 0; i--) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            String text = row.getCell(actualInsertPosition).getText();\n            if (\"_delete_\".equals(text)) {\n                table.removeRow(i);\n            } else {\n                removeCell(row, actualInsertPosition);\n            }\n        }\n    } catch (Exception e) {\n    }\n}", "private void minusGridSpan(XWPFTableRow row, int templateColIndex) {\n    XWPFTableCell actualCell = getActualCell(row, templateColIndex);\n    CTTcPr tcPr = actualCell.getCTTc().getTcPr();\n    CTDecimalNumber gridSpan = tcPr.getGridSpan();\n    gridSpan.setVal(BigInteger.valueOf(gridSpan.getVal().longValue() - 1));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTDecimalNumber.setVal",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render", "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.addColGridSpan" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}", "private void addColGridSpan(XWPFTableRow row, int insertPosition) {\n    XWPFTableCell actualCell = getActualCell(row, insertPosition);\n    CTTcPr tcPr = actualCell.getCTTc().getTcPr();\n    CTDecimalNumber gridSpan = tcPr.getGridSpan();\n    gridSpan.setVal(BigInteger.valueOf(gridSpan.getVal().longValue() + 1));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.mergeCellsHorizontalWithoutRemove",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTDecimalNumber.setVal",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.mergeCellsHorizontalWithoutRemove" ],
    "fullMethods" : [ "/**\n * merge several columns of cells in the same row, but do'not remove extra cells\n *\n * @param table\n * \t\ttable\n * @param row\n * \t\tindex of the row\n * @param fromCol\n * \t\tfrom column to be merged\n * @param toCol\n * \t\tto column to be merged\n */\npublic static void mergeCellsHorizontalWithoutRemove(XWPFTable table, int row, int fromCol, int toCol) {\n    Preconditions.requireGreaterThan(toCol, fromCol, \"To column to be merged must greater than from column.\");\n    XWPFTableCell cell = table.getRow(row).getCell(fromCol);\n    CTTcPr tcPr = getTcPr(cell);\n    tcPr.addNewGridSpan();\n    tcPr.getGridSpan().setVal(BigInteger.valueOf(((long) ((toCol - fromCol) + 1))));\n    int tcw = 0;\n    for (int colIndex = fromCol; colIndex <= toCol; colIndex++) {\n        XWPFTableCell tableCell = table.getRow(row).getCell(colIndex);\n        // TODO pct, auto\n        if (TableWidthType.DXA == tableCell.getWidthType()) {\n            if ((-1) == tableCell.getWidth())\n                return;\n\n            tcw += tableCell.getWidth();\n        } else {\n            return;\n        }\n    }\n    if (0 != tcw)\n        cell.setWidth(tcw + \"\");\n\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTDecimalNumber.setVal",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render", "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.addColGridSpan" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}", "private void addColGridSpan(XWPFTableRow row, int insertPosition) {\n    XWPFTableCell actualCell = getActualCell(row, insertPosition);\n    CTTcPr tcPr = actualCell.getCTTc().getTcPr();\n    CTDecimalNumber gridSpan = tcPr.getGridSpan();\n    gridSpan.setVal(BigInteger.valueOf(gridSpan.getVal().longValue() + 1));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPrBase.getInd",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.addNewMultiLevelNumberingId" ],
    "fullMethods" : [ "public BigInteger addNewMultiLevelNumberingId(NumberingFormat... numFmts) {\n    XWPFNumbering numbering = this.getNumbering();\n    if (null == numbering) {\n        numbering = this.createNumbering();\n    }\n    XWPFNumberingWrapper numberingWrapper = new XWPFNumberingWrapper(numbering);\n    CTAbstractNum cTAbstractNum = CTAbstractNum.Factory.newInstance();\n    // if we have an existing document, we must determine the next\n    // free number first.\n    cTAbstractNum.setAbstractNumId(numberingWrapper.getNextAbstractNumID());\n    // CTMultiLevelType addNewMultiLevelType = cTAbstractNum.addNewMultiLevelType();\n    // addNewMultiLevelType.setVal(STMultiLevelType.HYBRID_MULTILEVEL);\n    for (int i = 0; i < numFmts.length; i++) {\n        NumberingFormat numFmt = numFmts[i];\n        CTLvl cTLvl = cTAbstractNum.addNewLvl();\n        CTPPrBase ppr = (cTLvl.isSetPPr()) ? cTLvl.getPPr() : cTLvl.addNewPPr();\n        CTInd ind = (ppr.isSetInd()) ? ppr.getInd() : ppr.addNewInd();\n        ind.setLeft(BigInteger.valueOf(UnitUtils.cm2Twips(0.74F) * i));\n        Enum fmt = STNumberFormat.Enum.forInt(numFmt.getNumFmt());\n        String val = numFmt.getLvlText();\n        cTLvl.addNewNumFmt().setVal(fmt);\n        cTLvl.addNewLvlText().setVal(val);\n        cTLvl.addNewStart().setVal(BigInteger.valueOf(1));\n        cTLvl.setIlvl(BigInteger.valueOf(i));\n        if (fmt == STNumberFormat.BULLET) {\n            cTLvl.addNewLvlJc().setVal(STJc.LEFT);\n            CTRPr addNewRPr = cTLvl.addNewRPr();\n            CTFonts ctFonts = addNewRPr.addNewRFonts();\n            ctFonts.setAscii(\"Wingdings\");\n            ctFonts.setHAnsi(\"Wingdings\");\n            ctFonts.setHint(STHint.DEFAULT);\n        }\n    }\n    XWPFAbstractNum abstractNum = new XWPFAbstractNum(cTAbstractNum);\n    BigInteger abstractNumID = numbering.addAbstractNum(abstractNum);\n    return numbering.addNum(abstractNumID);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.addNewU",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleCTBorder",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTable.XWPFBorderType.toString",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel.XWPFTable",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleCTBorder" ],
    "fullMethods" : [ "public static void styleCTBorder(CTBorder b, BorderStyle style) {\n    if (null != style.getType())\n        b.setVal(STBorder.Enum.forString(style.getType().toString().toLowerCase()));\n\n    b.setSz(BigInteger.valueOf(style.getSize()));\n    b.setSpace(BigInteger.valueOf(style.getSpace()));\n    if (null != style.getColor())\n        b.setColor(style.getColor());\n\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.sizeOfUArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getLeft",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveBodyElements", "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph", "com.deepoove.poi.resolver.RunningRunBody.refactorRun" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveBodyElements(List<IBodyElement> bodyElements) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (null == bodyElements)\n        return metaTemplates;\n\n    // current iterable templates state\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    for (IBodyElement element : bodyElements) {\n        if (element == null)\n            continue;\n\n        if (element.getElementType() == BodyElementType.PARAGRAPH) {\n            resolveParagraph(((XWPFParagraph) (element)), metaTemplates, stack);\n        } else if (element.getElementType() == BodyElementType.TABLE) {\n            XWPFTable table = ((XWPFTable) (element));\n            List<XWPFTableRow> rows = table.getRows();\n            if (null == rows)\n                continue;\n\n            for (XWPFTableRow row : rows) {\n                resolveTableRow(row, metaTemplates, stack);\n            }\n        } else if ((element.getElementType() == BodyElementType.CONTENTCONTROL) && (element instanceof XWPFStructuredDocumentTag)) {\n            XWPFStructuredDocumentTag sdt = ((XWPFStructuredDocumentTag) (element));\n            addNewMeta(metaTemplates, stack, resolveSDTElements(sdt.getContent()));\n        }\n    }\n    checkStack(stack);\n    return metaTemplates;\n}", "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}", "public List<XWPFRun> refactorRun() {\n    if (pairs.isEmpty())\n        return null;\n\n    List<XWPFRun> templateRuns = new ArrayList<XWPFRun>();\n    int size = pairs.size();\n    Pair<RunEdge, RunEdge> runEdgePair;\n    for (int n = size - 1; n >= 0; n--) {\n        runEdgePair = pairs.get(n);\n        RunEdge startEdge = runEdgePair.getLeft();\n        RunEdge endEdge = runEdgePair.getRight();\n        int startRunPos = startEdge.getRunPos();\n        int endRunPos = endEdge.getRunPos();\n        int startOffset = startEdge.getRunEdge();\n        int endOffset = endEdge.getRunEdge();\n        String startText = runs.get(startRunPos).text();\n        String endText = runs.get(endRunPos).text();\n        if ((endOffset + 1) >= endText.length()) {\n            // delete the redundant end Run directly\n            if (startRunPos != endRunPos)\n                runBodyContext.removeRun(endRunPos);\n\n        } else {\n            // split end run, set extra in a run\n            String extra = endText.substring(endOffset + 1, endText.length());\n            if (startRunPos == endRunPos) {\n                // create run and set extra content\n                XWPFRun extraRun = runBodyContext.insertNewRunAfter(endRunPos);\n                StyleUtils.styleRun(extraRun, runs.get(endRunPos));\n                buildExtra(extra, extraRun);\n            } else {\n                // Set the extra content to the redundant end run\n                XWPFRun extraRun = runs.get(endRunPos);\n                buildExtra(extra, extraRun);\n            }\n        }\n        // remove extra run\n        for (int m = endRunPos - 1; m > startRunPos; m--) {\n            runBodyContext.removeRun(m);\n        }\n        if (startOffset <= 0) {\n            // set the start Run directly\n            XWPFRun templateRun = runs.get(startRunPos);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos));\n        } else {\n            // split start run, set extra in a run\n            String extra = startText.substring(0, startOffset);\n            XWPFRun extraRun = runs.get(startRunPos);\n            buildExtra(extra, extraRun);\n            XWPFRun templateRun = runBodyContext.insertNewRunAfter(startRunPos);\n            StyleUtils.styleRun(templateRun, extraRun);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos + 1));\n        }\n    }\n    return templateRuns;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.config.Configure.toString",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getLeft",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.config.Configure.toString" ],
    "fullMethods" : [ "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Configure Info\").append(\":\\n\");\n    sb.append(\"  Basic gramer: \").append(gramerPrefix).append(gramerSuffix).append(\"\\n\");\n    sb.append(\"  If and foreach gramer: \").append(gramerPrefix).append(iterable.getLeft()).append(gramerSuffix);\n    sb.append(gramerPrefix).append(iterable.getRight()).append(gramerSuffix).append(\"\\n\");\n    sb.append(\"  Regex:\").append(grammerRegex).append(\"\\n\");\n    sb.append(\"  Valid Error Handler: \").append(handler.getClass().getSimpleName()).append(\"\\n\");\n    sb.append(\"  Default Plugin: \").append(\"\\n\");\n    DEFAULT_POLICYS.forEach((chara, policy) -> {\n        sb.append(\"    \").append(gramerPrefix).append(chara.charValue()).append(gramerSuffix);\n        sb.append(\"->\").append(policy.getClass().getSimpleName()).append(\"\\n\");\n    });\n    sb.append(\"  Bind Plugin: \").append(\"\\n\");\n    CUSTOM_POLICYS.forEach((str, policy) -> {\n        sb.append(\"    \").append(gramerPrefix).append(str).append(gramerSuffix);\n        sb.append(\"->\").append(policy.getClass().getSimpleName()).append(\"\\n\");\n    });\n    sb.append(\"  Chart Plugin: \").append(\"\\n\");\n    DEFAULT_CHART_POLICYS.forEach((type, policy) -> {\n        sb.append(\"    \").append(type);\n        sb.append(\"->\").append(policy.getClass().getSimpleName()).append(\"\\n\");\n    });\n    sb.append(\"  Template Plugin: \").append(\"\\n\");\n    DEFAULT_TEMPLATE_POLICYS.forEach((clazz, policy) -> {\n        sb.append(\"    \").append(clazz.getSimpleName());\n        sb.append(\"->\").append(policy.getClass().getSimpleName()).append(\"\\n\");\n    });\n    sb.append(\"  SpELFunction: \").append(\"\\n\");\n    spELFunction.forEach((str, method) -> {\n        sb.append(\"    \").append(str);\n        sb.append(\"->\").append(method.toString()).append(\"\\n\");\n    });\n    return sb.toString();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.loggerInfo",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getLeft",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.loggerInfo" ],
    "fullMethods" : [ "public void loggerInfo() {\n    for (Pair<RunEdge, RunEdge> runEdges : pairs) {\n        LOG.debug(\"[Start]:\" + runEdges.getLeft().toString());\n        LOG.debug(\"[End]:\" + runEdges.getRight().toString());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getLeft",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns", "com.deepoove.poi.resolver.TemplateResolver.resolveXWPFRuns" ],
    "fullMethods" : [ "@Override\npublic List<MetaTemplate> resolveXWPFRuns(List<XWPFRun> runs) {\n    List<MetaTemplate> metaTemplates = new ArrayList<>();\n    if (runs == null)\n        return metaTemplates;\n\n    Deque<BlockTemplate> stack = new LinkedList<BlockTemplate>();\n    resolveXWPFRuns(runs, metaTemplates, stack);\n    checkStack(stack);\n    return metaTemplates;\n}", "private void resolveXWPFRuns(List<XWPFRun> runs, final List<MetaTemplate> metaTemplates, final Deque<BlockTemplate> stack) {\n    for (XWPFRun run : runs) {\n        String text = null;\n        if (StringUtils.isBlank(text = run.getText(0))) {\n            // textbox\n            List<MetaTemplate> visitBodyElements = resolveTextbox(run);\n            if (!visitBodyElements.isEmpty()) {\n                addNewMeta(metaTemplates, stack, visitBodyElements);\n                continue;\n            }\n            // picture\n            List<PictureTemplate> pictureTemplates = resolveXWPFPictures(run.getEmbeddedPictures());\n            if (!pictureTemplates.isEmpty()) {\n                addNewMeta(metaTemplates, stack, pictureTemplates);\n                continue;\n            }\n            // w:pict v:imagedata\n            PictImageTemplate pictImageTemplate = resolvePictImage(run);\n            if (null != pictImageTemplate) {\n                addNewMeta(metaTemplates, stack, pictImageTemplate);\n                continue;\n            }\n            // chart\n            ChartTemplate chartTemplate = resolveXWPFChart(run);\n            if (null != chartTemplate) {\n                addNewMeta(metaTemplates, stack, chartTemplate);\n                continue;\n            }\n            continue;\n        }\n        RunTemplate runTemplate = ((RunTemplate) (parseTemplateFactory(text, run, run)));\n        if (null == runTemplate)\n            continue;\n\n        char charValue = runTemplate.getSign().charValue();\n        if (charValue == config.getIterable().getLeft()) {\n            IterableTemplate freshIterableTemplate = new IterableTemplate(runTemplate);\n            stack.push(freshIterableTemplate);\n        } else if (charValue == config.getIterable().getRight()) {\n            if (stack.isEmpty())\n                throw new ResolverException(\"Mismatched start/end tags: No start mark found for end mark \" + runTemplate);\n\n            BlockTemplate latestIterableTemplate = stack.pop();\n            if (StringUtils.isNotEmpty(runTemplate.getTagName()) && (!latestIterableTemplate.getStartMark().getTagName().equals(runTemplate.getTagName()))) {\n                throw new ResolverException(((\"Mismatched start/end tags: start mark \" + latestIterableTemplate.getStartMark()) + \" does not match to end mark \") + runTemplate);\n            }\n            latestIterableTemplate.setEndMark(runTemplate);\n            if (latestIterableTemplate instanceof IterableTemplate) {\n                latestIterableTemplate = ((IterableTemplate) (latestIterableTemplate)).buildIfInline();\n            }\n            addNewMeta(metaTemplates, stack, latestIterableTemplate);\n        } else {\n            addNewMeta(metaTemplates, stack, runTemplate);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.<init>",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getLeft",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.<init>", "com.deepoove.poi.resolver.RunningRunBody.buildRunEdge" ],
    "fullMethods" : [ "public RunningRunBody(RunBodyContext context, Pattern pattern) {\n    this.runBodyContext = context;\n    this.runs = context.getRuns();\n    if ((null == runs) || runs.isEmpty())\n        return;\n\n    Matcher matcher = pattern.matcher(getText(context));\n    if (matcher.find()) {\n        refactorBody();\n    }\n    buildRunEdge(pattern);\n}", "private void buildRunEdge(Pattern pattern) {\n    // find all templates\n    Matcher matcher = pattern.matcher(getText(runBodyContext));\n    while (matcher.find()) {\n        pairs.add(ImmutablePair.of(new RunEdge(matcher.start(), matcher.group()), new RunEdge(matcher.end(), matcher.group())));\n    } \n    if (pairs.isEmpty())\n        return;\n\n    boolean endflag = false;\n    int size = runs.size();\n    int cursor = 0;\n    int pos = 0;\n    // find the run where all templates are located\n    Pair<RunEdge, RunEdge> pair = pairs.get(pos);\n    RunEdge startEdge = pair.getLeft();\n    RunEdge endEdge = pair.getRight();\n    int start = startEdge.getAllEdge();\n    int end = endEdge.getAllEdge();\n    for (int i = 0; i < size; i++) {\n        XWPFRun run = runs.get(i);\n        String text = run.text();\n        // empty run\n        if (null == text) {\n            LOG.warn(\"found the empty text run,may be produce bug:\" + run);\n            cursor += run.toString().length();\n            continue;\n        }\n        LOG.debug(text);\n        // The starting position is not enough, the cursor points to the next run\n        if ((text.length() + cursor) < start) {\n            cursor += text.length();\n            continue;\n        }\n        // index text\n        for (int offset = 0; offset < text.length(); offset++) {\n            if ((cursor + offset) == start) {\n                startEdge.setRunPos(i);\n                startEdge.setRunEdge(offset);\n                startEdge.setText(text);\n            }\n            if ((cursor + offset) == (end - 1)) {\n                endEdge.setRunPos(i);\n                endEdge.setRunEdge(offset);\n                endEdge.setText(text);\n                if (pos == (pairs.size() - 1)) {\n                    endflag = true;\n                    break;\n                }\n                // Continue to calculate the next template\n                pair = pairs.get(++pos);\n                startEdge = pair.getLeft();\n                endEdge = pair.getRight();\n                start = startEdge.getAllEdge();\n                end = endEdge.getAllEdge();\n            }\n        }\n        if (endflag)\n            break;\n\n        // the cursor points to the next run\n        cursor += text.length();\n    }\n    loggerInfo();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getLeft",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.resolver.TemplateResolver.resolveParagraph", "com.deepoove.poi.resolver.RunningRunBody.refactorRun" ],
    "fullMethods" : [ "public void resolveParagraph(XWPFParagraph paragraph, List<MetaTemplate> metaTemplates, Deque<BlockTemplate> stack) {\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    new RunningRunBody(new ParagraphContext(paragraphWrapper), templatePattern).refactorRun();\n    resolveXWPFRuns(paragraph.getRuns(), metaTemplates, stack);\n    paragraphWrapper.getSDTs().forEach(sdtEle -> addNewMeta(metaTemplates, stack, resolveSDTElements(sdtEle.getContent())));\n}", "public List<XWPFRun> refactorRun() {\n    if (pairs.isEmpty())\n        return null;\n\n    List<XWPFRun> templateRuns = new ArrayList<XWPFRun>();\n    int size = pairs.size();\n    Pair<RunEdge, RunEdge> runEdgePair;\n    for (int n = size - 1; n >= 0; n--) {\n        runEdgePair = pairs.get(n);\n        RunEdge startEdge = runEdgePair.getLeft();\n        RunEdge endEdge = runEdgePair.getRight();\n        int startRunPos = startEdge.getRunPos();\n        int endRunPos = endEdge.getRunPos();\n        int startOffset = startEdge.getRunEdge();\n        int endOffset = endEdge.getRunEdge();\n        String startText = runs.get(startRunPos).text();\n        String endText = runs.get(endRunPos).text();\n        if ((endOffset + 1) >= endText.length()) {\n            // delete the redundant end Run directly\n            if (startRunPos != endRunPos)\n                runBodyContext.removeRun(endRunPos);\n\n        } else {\n            // split end run, set extra in a run\n            String extra = endText.substring(endOffset + 1, endText.length());\n            if (startRunPos == endRunPos) {\n                // create run and set extra content\n                XWPFRun extraRun = runBodyContext.insertNewRunAfter(endRunPos);\n                StyleUtils.styleRun(extraRun, runs.get(endRunPos));\n                buildExtra(extra, extraRun);\n            } else {\n                // Set the extra content to the redundant end run\n                XWPFRun extraRun = runs.get(endRunPos);\n                buildExtra(extra, extraRun);\n            }\n        }\n        // remove extra run\n        for (int m = endRunPos - 1; m > startRunPos; m--) {\n            runBodyContext.removeRun(m);\n        }\n        if (startOffset <= 0) {\n            // set the start Run directly\n            XWPFRun templateRun = runs.get(startRunPos);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos));\n        } else {\n            // split start run, set extra in a run\n            String extra = startText.substring(0, startOffset);\n            XWPFRun extraRun = runs.get(startRunPos);\n            buildExtra(extra, extraRun);\n            XWPFRun templateRun = runBodyContext.insertNewRunAfter(startRunPos);\n            StyleUtils.styleRun(templateRun, extraRun);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos + 1));\n        }\n    }\n    return templateRuns;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.refactorRun",
    "thirdPartyMethod" : "org.apache.commons.lang3.tuple.Pair.getLeft",
    "thirdPartyPackage" : "org.apache.commons.lang3.tuple",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.refactorRun" ],
    "fullMethods" : [ "public List<XWPFRun> refactorRun() {\n    if (pairs.isEmpty())\n        return null;\n\n    List<XWPFRun> templateRuns = new ArrayList<XWPFRun>();\n    int size = pairs.size();\n    Pair<RunEdge, RunEdge> runEdgePair;\n    for (int n = size - 1; n >= 0; n--) {\n        runEdgePair = pairs.get(n);\n        RunEdge startEdge = runEdgePair.getLeft();\n        RunEdge endEdge = runEdgePair.getRight();\n        int startRunPos = startEdge.getRunPos();\n        int endRunPos = endEdge.getRunPos();\n        int startOffset = startEdge.getRunEdge();\n        int endOffset = endEdge.getRunEdge();\n        String startText = runs.get(startRunPos).text();\n        String endText = runs.get(endRunPos).text();\n        if ((endOffset + 1) >= endText.length()) {\n            // delete the redundant end Run directly\n            if (startRunPos != endRunPos)\n                runBodyContext.removeRun(endRunPos);\n\n        } else {\n            // split end run, set extra in a run\n            String extra = endText.substring(endOffset + 1, endText.length());\n            if (startRunPos == endRunPos) {\n                // create run and set extra content\n                XWPFRun extraRun = runBodyContext.insertNewRunAfter(endRunPos);\n                StyleUtils.styleRun(extraRun, runs.get(endRunPos));\n                buildExtra(extra, extraRun);\n            } else {\n                // Set the extra content to the redundant end run\n                XWPFRun extraRun = runs.get(endRunPos);\n                buildExtra(extra, extraRun);\n            }\n        }\n        // remove extra run\n        for (int m = endRunPos - 1; m > startRunPos; m--) {\n            runBodyContext.removeRun(m);\n        }\n        if (startOffset <= 0) {\n            // set the start Run directly\n            XWPFRun templateRun = runs.get(startRunPos);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos));\n        } else {\n            // split start run, set extra in a run\n            String extra = startText.substring(0, startOffset);\n            XWPFRun extraRun = runs.get(startRunPos);\n            buildExtra(extra, extraRun);\n            XWPFRun templateRun = runBodyContext.insertNewRunAfter(startRunPos);\n            StyleUtils.styleRun(templateRun, extraRun);\n            templateRun.setText(startEdge.getTag(), 0);\n            templateRuns.add(runs.get(startRunPos + 1));\n        }\n    }\n    return templateRuns;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.NumberingContinue.updateNumbering",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getDocument",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.NumberingContinue.updateNumbering" ],
    "fullMethods" : [ "public void updateNumbering(XWPFParagraph source, XWPFParagraph target) {\n    XWPFDocument document = source.getDocument();\n    XWPFNumbering numbering = document.getNumbering();\n    if (null == numbering)\n        return;\n\n    BigInteger numID = source.getNumID();\n    if (numID == null)\n        return;\n\n    if ((null != continueNumID) && numID.equals(continueNumID)) {\n        return;\n    }\n    if (consistCache.get(numID) != null) {\n        target.setNumID(consistCache.get(numID));\n        return;\n    }\n    XWPFNumberingWrapper wrapper = new XWPFNumberingWrapper(numbering);\n    XWPFNum num = numbering.getNum(numID);\n    if (null == num)\n        return;\n\n    XWPFAbstractNum abstractNum = numbering.getAbstractNum(num.getCTNum().getAbstractNumId().getVal());\n    CTAbstractNum ctAbstractNum = ((CTAbstractNum) (abstractNum.getAbstractNum().copy()));\n    ctAbstractNum.setAbstractNumId(wrapper.getNextAbstractNumID());\n    // clear continues list\n    // (related to tracking numbering definitions when documents are\n    // repurposed and\n    // changed\n    if (ctAbstractNum.isSetNsid())\n        ctAbstractNum.unsetNsid();\n\n    // related to where the definition can be displayed in the user\n    // interface\n    if (ctAbstractNum.isSetTmpl())\n        ctAbstractNum.unsetTmpl();\n\n    BigInteger abstractNumID = numbering.addAbstractNum(new XWPFAbstractNum(ctAbstractNum));\n    BigInteger newNumId = numbering.addNum(abstractNumID);\n    target.setNumID(newNumId);\n    consistCache.put(numID, newNumId);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.getDocument",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment" ],
    "fullMethods" : [ "public static void renderComment(XWPFRun run, CommentRenderData data) throws Exception {\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper parentContext = new XWPFParagraphWrapper(paragraph);\n    BigInteger cId = BigInteger.ZERO;\n    CommentContent commentContent = data.getCommentContent();\n    if (null != commentContent) {\n        XWPFComments comments = ((NiceXWPFDocument) (paragraph.getDocument())).createComments();\n        XWPFComment newComment = comments.createComment(NextIDUtils.getCommentMaxId(comments).add(BigInteger.ONE));\n        newComment.setAuthor(commentContent.getAuthor());\n        newComment.setDate(commentContent.getDate());\n        newComment.setInitials(commentContent.getInitials());\n        renderDocument(newComment.createParagraph().createRun(), commentContent.getContent());\n        cId = newComment.getCtComment().getId();\n        parentContext.insertNewCommentRangeStart(run, cId);\n    }\n    renderParagraph(run, Paragraphs.of().addList(data.getContents()).create());\n    if (null != commentContent) {\n        parentContext.insertNewCommentRangeEnd(run, cId);\n        XWPFRun newRun = parentContext.insertNewRun(ParagraphUtils.getRunPos(run));\n        newRun.getCTR().addNewCommentReference().setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTOfPieChart.getSerList",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.<init>" ],
    "fullMethods" : [ "public XDDFOfPieChartData(XDDFChart parent, CTOfPieChart chart) {\n    super(parent);\n    this.chart = chart;\n    this.seriesNum = parent.getChartSeries().size();\n    for (CTPieSer series : chart.getSerList()) {\n        this.series.add(new Series(series, series.getCat(), series.getVal()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.<init>",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTBr.setClear",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.<init>", "com.deepoove.poi.resolver.RunningRunBody.refactorBody" ],
    "fullMethods" : [ "public RunningRunBody(RunBodyContext context, Pattern pattern) {\n    this.runBodyContext = context;\n    this.runs = context.getRuns();\n    if ((null == runs) || runs.isEmpty())\n        return;\n\n    Matcher matcher = pattern.matcher(getText(context));\n    if (matcher.find()) {\n        refactorBody();\n    }\n    buildRunEdge(pattern);\n}", "private void refactorBody() {\n    for (int i = runs.size() - 1; i >= 0; i--) {\n        XWPFRun xwpfRun = runs.get(i);\n        CTR ctr = xwpfRun.getCTR();\n        CTRImpl ctrimpl = ((CTRImpl) (ctr));\n        int sizeOfBrArray = ctr.sizeOfBrArray();\n        int sizeOfCrArray = ctr.sizeOfCrArray();\n        int sizeOfTabArray = ctr.sizeOfTabArray();\n        if (((sizeOfBrArray + sizeOfCrArray) + sizeOfTabArray) > 0) {\n            synchronized(ctrimpl.monitor()) {\n                // ctrimpl.check_orphaned();\n                List<? extends XmlObject> localArrayList = new ArrayList<XmlObject>();\n                ctrimpl.get_store().find_all_element_users(qname, localArrayList);\n                int size = localArrayList.size();\n                for (int j = size - 1; j >= 0; j--) {\n                    Object obj = localArrayList.get(j);\n                    if (obj instanceof CTEmpty) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        String tagName = ((CTEmpty) (obj)).getDomNode().getNodeName();\n                        if (\"w:br\".equals(tagName) || \"br\".equals(tagName)) {\n                            insertNewRun.addBreak();\n                        }\n                        if (\"w:cr\".equals(tagName) || \"cr\".equals(tagName)) {\n                            insertNewRun.addCarriageReturn();\n                        }\n                        if (\"w:tab\".equals(tagName) || \"tab\".equals(tagName)) {\n                            insertNewRun.addTab();\n                        }\n                    } else if (obj instanceof CTBr) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        CTBr addNewBr = insertNewRun.getCTR().addNewBr();\n                        if (null != ((CTBr) (obj)).getType())\n                            addNewBr.setType(((CTBr) (obj)).getType());\n\n                        if (null != ((CTBr) (obj)).getClear())\n                            addNewBr.setClear(((CTBr) (obj)).getClear());\n\n                    } else if (obj instanceof CTText) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        StyleUtils.styleRun(insertNewRun, xwpfRun);\n                        insertNewRun.setText(((CTText) (obj)).getStringValue());\n                    }\n                }\n                runBodyContext.removeRun(i);\n            }\n        }\n    }\n    this.runs = runBodyContext.getRuns();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFtnEdn.setId",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableString", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeFootnote" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "protected String createMergeableString(NiceXWPFDocument source, NiceXWPFDocument merged, Map<String, String> styleIdsMap) throws InvalidFormatException, IOException {\n    CTBody mergedBody = merged.getDocument().getBody();\n    // TODO For the same style, reduce the number of merges\n    // Map<String, String> styleIdsMap = mergeStyles(docMerge);\n    Map<String, String> numIdsMap = mergeNumbering(source, merged);\n    Map<String, String> blipIdsMap = mergePicture(source, merged);\n    Map<String, String> externalBlipIdsMap = mergeExternalPicture(source, merged);\n    Map<String, String> hyperlinkMap = mergeHyperlink(source, merged);\n    Map<String, String> chartIdsMap = mergeChart(source, merged);\n    Map<String, String> attachmentIdsMap = mergeAttachment(source, merged);\n    Map<String, String> footnoteIdsMap = mergeFootnote(source, merged);\n    Map<String, String> endnoteIdsMap = mergeEndnote(source, merged);\n    String appendString = mergedBody.xmlText(DefaultXmlOptions.OPTIONS_OUTER);\n    String addPart = ridSectPr(appendString);\n    // style\n    for (String styleId : styleIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:pStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:pStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:tblStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:tblStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:rStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:rStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\");\n    }\n    // picture id\n    Map<String, String> placeHolderblipIdsMap = new HashMap<String, String>();\n    for (String relaId : blipIdsMap.keySet()) {\n        placeHolderblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:embed=\\\"\" + relaId) + \"\\\"\", (\"r:embed=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n        // w:pict v:shape v:imagedata\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    Map<String, String> placeHolderExternalblipIdsMap = new HashMap<String, String>();\n    for (String relaId : externalBlipIdsMap.keySet()) {\n        placeHolderExternalblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderExternalblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:link=\\\"\" + relaId) + \"\\\"\", (\"r:link=\\\"\" + placeHolderExternalblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // hyperlink id\n    for (String relaId : hyperlinkMap.keySet()) {\n        hyperlinkMap.put(relaId, hyperlinkMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : hyperlinkMap.keySet()) {\n        // w:hyperlink r:id\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + hyperlinkMap.get(relaId)) + \"\\\"\");\n    }\n    // chart id\n    for (String relaId : chartIdsMap.keySet()) {\n        chartIdsMap.put(relaId, chartIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : chartIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + chartIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // attachment id\n    for (String relaId : attachmentIdsMap.keySet()) {\n        attachmentIdsMap.put(relaId, attachmentIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : attachmentIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + attachmentIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // footnote id\n    for (String relaId : footnoteIdsMap.keySet()) {\n        footnoteIdsMap.put(relaId, footnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : footnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"footnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"footnoteReference w:id=\\\"\" + footnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // endnote id\n    for (String relaId : endnoteIdsMap.keySet()) {\n        endnoteIdsMap.put(relaId, endnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : endnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"endnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"endnoteReference w:id=\\\"\" + endnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // numbering numId\n    for (String relaId : numIdsMap.keySet()) {\n        numIdsMap.put(relaId, numIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String numId : numIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:numId\\\\sw:val=\\\"\" + numId) + \"\\\"\", (\"<w:numId w:val=\\\"\" + numIdsMap.get(numId)) + \"\\\"\");\n    }\n    return addPart.replaceAll(CROSS_REPLACE_STRING, \"\");\n}", "protected Map<String, String> mergeFootnote(NiceXWPFDocument source, NiceXWPFDocument merged) {\n    Map<String, String> blipIdsMap = new HashMap<>();\n    FootnoteEndnoteIdManager footnoteEndnoteIdManager = new FootnoteEndnoteIdManager(source);\n    List<XWPFFootnote> footnotes = merged.getFootnotes();\n    if (!footnotes.isEmpty()) {\n        XWPFFootnotes sourceFootnotes = source.createFootnotes();\n        for (XWPFFootnote footnote : footnotes) {\n            String relationId = footnote.getId().toString();\n            footnote.getCTFtnEdn().setId(footnoteEndnoteIdManager.nextId());\n            sourceFootnotes.addFootnote(footnote);\n            String blidId = footnote.getId().toString();\n            blipIdsMap.put(relationId, blidId);\n        }\n    }\n    return blipIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.EnhancedXWPFChart.setExternalId",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTChartSpace.getExternalData",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.EnhancedXWPFChart.setExternalId" ],
    "fullMethods" : [ "@Override\npublic void setExternalId(String id) {\n    CTChartSpace ctChartSpace = getCTChartSpace();\n    CTExternalData externalData = (ctChartSpace.isSetExternalData()) ? ctChartSpace.getExternalData() : ctChartSpace.addNewExternalData();\n    externalData.setId(id);\n    if (!externalData.isSetAutoUpdate()) {\n        externalData.addNewAutoUpdate().setVal(true);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPBdr.addNewLeft",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTStyle.isSetName",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeStyles" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "@SuppressWarnings(\"unchecked\")\nprotected Map<String, String> mergeStyles(NiceXWPFDocument source, NiceXWPFDocument merged) {\n    Map<String, String> styleIdsMap = new HashMap<String, String>();\n    XWPFStyles styles = source.getStyles();\n    if (null == styles)\n        styles = source.createStyles();\n\n    XWPFStyles stylesMerge = merged.getStyles();\n    if (null == stylesMerge)\n        return styleIdsMap;\n\n    try {\n        Field listStyleField = XWPFStyles.class.getDeclaredField(\"listStyle\");\n        listStyleField.setAccessible(true);\n        List<XWPFStyle> lists = ((List<XWPFStyle>) (listStyleField.get(stylesMerge)));\n        String defaultParaStyleId = null;\n        for (XWPFStyle xwpfStyle : lists) {\n            if (styles.styleExist(xwpfStyle.getStyleId())) {\n                if (!getRenameAndMergeExistsStyle()) {\n                    continue;\n                }\n                String id = xwpfStyle.getStyleId();\n                xwpfStyle.setStyleId(UUID.randomUUID().toString().substring(0, 8));\n                styleIdsMap.put(id, xwpfStyle.getStyleId());\n            }\n            // fix github issue 499\n            CTStyle ctStyle = xwpfStyle.getCTStyle();\n            if ((ctStyle.isSetDefault() && POIXMLUnits.parseOnOff(ctStyle.xgetDefault())) && (ctStyle.getType() == STStyleType.PARAGRAPH)) {\n                defaultParaStyleId = ctStyle.getStyleId();\n            }\n            if (ctStyle.isSetDefault()) {\n                ctStyle.unsetDefault();\n            }\n            if (ctStyle.isSetName() && StringUtils.isBlank(ctStyle.getName().getVal())) {\n                ctStyle.getName().setVal(ctStyle.getName().getVal() + xwpfStyle.getStyleId());\n            }\n            if (ctStyle.isSetBasedOn()) {\n                String newId = styleIdsMap.get(ctStyle.getBasedOn().getVal());\n                if (null != newId)\n                    ctStyle.getBasedOn().setVal(newId);\n\n            }\n            styles.addStyle(xwpfStyle);\n        }\n        if (null != defaultParaStyleId) {\n            final String dpid = defaultParaStyleId;\n            merged.getParagraphs().stream().filter(p -> null == p.getStyle()).forEach(p -> p.setStyle(dpid));\n        }\n    } catch (Exception e) {\n        // throw exception?\n        logger.error(\"merge style error\", e);\n    }\n    return styleIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ResourceLoader.loadContent",
    "thirdPartyMethod" : "org.apache.commons.compress.utils.IOUtils.closeQuietly",
    "thirdPartyPackage" : "org.apache.commons.compress.utils",
    "path" : [ "com.deepoove.poi.util.ResourceLoader.loadContent" ],
    "fullMethods" : [ "public static String loadContent(String url) throws IOException {\n    ClassLoader cl = getDefaultClassLoader();\n    InputStream stream = (null != cl) ? cl.getResourceAsStream(url) : ClassLoader.getSystemResourceAsStream(url);\n    try {\n        return new String(IOUtils.toByteArray(stream));\n    } finally {\n        IOUtils.closeQuietly(stream);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.BufferedImageUtils.getBufferByteArray",
    "thirdPartyMethod" : "org.apache.commons.compress.utils.IOUtils.closeQuietly",
    "thirdPartyPackage" : "org.apache.commons.compress.utils",
    "path" : [ "com.deepoove.poi.util.BufferedImageUtils.getBufferByteArray" ],
    "fullMethods" : [ "/**\n * Get picture byte array of BufferedImage\n *\n * @param image\n * @param format\n * \t\tformat of the image\n * @return  */\npublic static byte[] getBufferByteArray(BufferedImage image, String format) {\n    if (null == image)\n        return null;\n\n    String formatName = (StringUtils.isNotEmpty(format) && (format.charAt(0) == '.')) ? format.substring(1) : format;\n    if (StringUtils.isEmpty(formatName))\n        formatName = \"png\";\n\n    ByteArrayOutputStream os = new ByteArrayOutputStream();\n    try {\n        ImageIO.write(image, formatName, os);\n        return os.toByteArray();\n    } catch (Exception e) {\n        logger.error(\"getBufferByteArray error\", e);\n        return null;\n    } finally {\n        IOUtils.closeQuietly(os);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.BufferedImageUtils.readBufferedImage",
    "thirdPartyMethod" : "org.apache.commons.compress.utils.IOUtils.closeQuietly",
    "thirdPartyPackage" : "org.apache.commons.compress.utils",
    "path" : [ "com.deepoove.poi.util.BufferedImageUtils.readBufferedImage" ],
    "fullMethods" : [ "/**\n * read byte\n *\n * @param image\n * @return  */\npublic static BufferedImage readBufferedImage(byte[] image) {\n    ByteArrayInputStream inputStream = new ByteArrayInputStream(image);\n    try {\n        return ImageIO.read(inputStream);\n    } catch (IOException e) {\n        logger.error(\"readBufferedImage IO error\", e);\n        throw new RuntimeException(e);\n    } finally {\n        IOUtils.closeQuietly(inputStream);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ChartUtils.getChartSeries",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTPlotArea.getOfPieChartArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.util.ChartUtils.getChartSeries" ],
    "fullMethods" : [ "public static List<XDDFChartData> getChartSeries(XWPFChart chart) {\n    List<XDDFChartData> series = new LinkedList<>();\n    List<XDDFChartData> chartSeries = chart.getChartSeries();\n    series.addAll(chartSeries);\n    CTPlotArea plotArea = chart.getCTChart().getPlotArea();\n    for (int i = 0; i < plotArea.sizeOfOfPieChartArray(); i++) {\n        CTOfPieChart barChart = plotArea.getOfPieChartArray(i);\n        series.add(new XDDFOfPieChartData(chart, barChart));\n    }\n    return series;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.NumberingRenderPolicy.Helper.renderNumbering",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.IRunBody.getDocument",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.NumberingRenderPolicy.Helper.renderNumbering" ],
    "fullMethods" : [ "public static void renderNumbering(XWPFRun run, NumberingRenderData data) throws Exception {\n    List<NumberingItemRenderData> items = data.getItems();\n    NumberingFormat[] array = data.getFormats().toArray(new NumberingFormat[]{  });\n    BigInteger numID = ((NiceXWPFDocument) (run.getParent().getDocument())).addNewMultiLevelNumberingId(array);\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    for (NumberingItemRenderData item : items) {\n        XWPFParagraph paragraph = bodyContainer.insertNewParagraph(run);\n        int level = item.getLevel();\n        if (NumberingItemRenderData.LEVEL_NORMAL != level) {\n            paragraph.setNumID(numID);\n            paragraph.setNumILvl(BigInteger.valueOf(level));\n        }\n        XWPFRun createRun = paragraph.createRun();\n        // StyleUtils.styleParaRpr(paragraph, StyleUtils.retriveStyle(run));\n        StyleUtils.styleRun(createRun, run);\n        ParagraphRenderPolicy.Helper.renderParagraph(createRun, item.getItem());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblPr.addNewTblBorders",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTableCells",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render", "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.getColIndex" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        for (int i = rowSize - 1; i >= 0; i--) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            String text = row.getCell(actualInsertPosition).getText();\n            if (\"_delete_\".equals(text)) {\n                table.removeRow(i);\n            } else {\n                removeCell(row, actualInsertPosition);\n            }\n        }\n    } catch (Exception e) {\n    }\n}", "private int getColIndex(XWPFTableCell cell) {\n    XWPFTableRow tableRow = cell.getTableRow();\n    int orginalCol = 0;\n    for (int i = 0; i < tableRow.getTableCells().size(); i++) {\n        XWPFTableCell current = tableRow.getCell(i);\n        int intValue = 1;\n        CTTcPr tcPr = current.getCTTc().getTcPr();\n        if (null != tcPr) {\n            CTDecimalNumber gridSpan = tcPr.getGridSpan();\n            if (null != gridSpan)\n                intValue = gridSpan.getVal().intValue();\n\n        }\n        orginalCol += intValue;\n        if (current.getCTTc() == cell.getCTTc()) {\n            return orginalCol - intValue;\n        }\n    }\n    return -1;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTableRowWrapper.getTableICells",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTableCells",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTableRowWrapper.getTableICells" ],
    "fullMethods" : [ "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic List<ICell> getTableICells() {\n    boolean haveSdt = false;\n    List<ICell> cells = new ArrayList<>();\n    XmlCursor cursor = row.getCtRow().newCursor();\n    try {\n        cursor.selectPath(\"./*\");\n        while (cursor.toNextSelection()) {\n            XmlObject o = cursor.getObject();\n            if (o instanceof CTTc) {\n                cells.add(new XWPFTableCell(((CTTc) (o)), row, row.getTable().getBody()));\n            } else if (o instanceof CTSdtCell) {\n                haveSdt = true;\n                cells.add(new XWPFStructuredDocumentTag(((CTSdtCell) (o)), row, row.getTable().getBody()));\n            }\n        } \n    } finally {\n        cursor.dispose();\n    }\n    return haveSdt ? cells : ((List) (row.getTableCells()));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTableCells",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render", "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.getActualInsertPosition" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}", "private int getActualInsertPosition(XWPFTableRow tableRow, int insertPosition) {\n    int orginalCol = 0;\n    for (int i = 0; i < tableRow.getTableCells().size(); i++) {\n        XWPFTableCell current = tableRow.getCell(i);\n        int intValue = 1;\n        CTTcPr tcPr = current.getCTTc().getTcPr();\n        if (null != tcPr) {\n            CTDecimalNumber gridSpan = tcPr.getGridSpan();\n            if (null != gridSpan)\n                intValue = gridSpan.getVal().intValue();\n\n        }\n        orginalCol += intValue;\n        if (((orginalCol - intValue) == insertPosition) && (intValue == 1)) {\n            return i;\n        }\n    }\n    return -1;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderRow",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTableCells",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderRow" ],
    "fullMethods" : [ "public static void renderRow(XWPFTableRow row, RowRenderData data, Style defaultTextStyle) throws Exception {\n    if (null == data)\n        return;\n\n    int size = row.getTableCells().size();\n    if (size != data.obtainColSize()) {\n        throw new IllegalArgumentException(\"Number of cells and render data should be the same!\");\n    }\n    StyleUtils.styleTableRow(row, data.getRowStyle());\n    CellStyle defaultCellStyle = (null == data.getRowStyle()) ? null : data.getRowStyle().getDefaultCellStyle();\n    for (int i = 0; i < size; i++) {\n        renderCell(row.getCell(i), data.getCells().get(i), defaultCellStyle, defaultTextStyle);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTableCells",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.<init>", "com.deepoove.poi.xwpf.NiceXWPFDocument.niceDocumentRead", "com.deepoove.poi.xwpf.NiceXWPFDocument.read", "com.deepoove.poi.xwpf.NiceXWPFDocument.readTables" ],
    "fullMethods" : [ "public NiceXWPFDocument(InputStream in, boolean adjustDoc) throws IOException {\n    super(in);\n    this.adjustDoc = adjustDoc;\n    idenifierManagerWrapper = new IdenifierManagerWrapper(this);\n    niceDocumentRead();\n}", "private void niceDocumentRead() throws IOException {\n    read(this);\n    this.getHeaderList().forEach(header -> read(header));\n    this.getFooterList().forEach(header -> read(header));\n    // structured document tag\n    if (!contentControls.isEmpty()) {\n        XmlCursor docCursor = getDocument().newCursor();\n        docCursor.selectPath(\"./*\");\n        while (docCursor.toNextSelection()) {\n            XmlObject o = docCursor.getObject();\n            if (o instanceof CTBody) {\n                XmlCursor bodyCursor = o.newCursor();\n                bodyCursor.selectPath(\"./*\");\n                while (bodyCursor.toNextSelection()) {\n                    XmlObject bodyObj = bodyCursor.getObject();\n                    if (bodyObj instanceof CTSdtBlock) {\n                        XWPFStructuredDocumentTag c = new XWPFStructuredDocumentTag(((CTSdtBlock) (bodyObj)), this);\n                        bodyElements.add(c);\n                        structuredDocumentTags.add(c);\n                    }\n                } \n                bodyCursor.dispose();\n            }\n        } \n        docCursor.dispose();\n    }\n}", "private void read(IBody body) {\n    readParagraphs(body.getParagraphs());\n    readTables(body.getTables());\n}", "private void readTables(List<XWPFTable> tables) {\n    allTables.addAll(tables);\n    for (XWPFTable table : tables) {\n        List<XWPFTableRow> rows = table.getRows();\n        if (null == rows)\n            continue;\n\n        for (XWPFTableRow row : rows) {\n            List<XWPFTableCell> cells = row.getTableCells();\n            if (null == cells)\n                continue;\n\n            for (XWPFTableCell cell : cells) {\n                read(cell);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.mergeCellsHorizonal",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTableCells",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.mergeCellsHorizonal" ],
    "fullMethods" : [ "/**\n * merge several columns of cells in the same row\n *\n * @param table\n * \t\ttable\n * @param row\n * \t\tindex of the row\n * @param fromCol\n * \t\tfrom column to be merged\n * @param toCol\n * \t\tto column to be merged\n */\npublic static void mergeCellsHorizonal(XWPFTable table, int row, int fromCol, int toCol) {\n    Preconditions.requireGreaterThan(toCol, fromCol, \"To column to be merged must greater than from column.\");\n    mergeCellsHorizontalWithoutRemove(table, row, fromCol, toCol);\n    XWPFTableRow rowTable = table.getRow(row);\n    for (int colIndex = fromCol + 1; colIndex <= toCol; colIndex++) {\n        rowTable.removeCell(fromCol + 1);\n        if (rowTable.getTableCells().size() != rowTable.getCtRow().sizeOfTcArray()) {\n            rowTable.getCtRow().removeTc(fromCol + 1);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTableCells",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderTable", "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderRow" ],
    "fullMethods" : [ "public static XWPFTable renderTable(XWPFRun run, TableRenderData data) throws Exception {\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    XWPFTable table = bodyContainer.insertNewTable(run, data.obtainRowSize(), data.obtainColSize());\n    StyleUtils.styleTable(table, data.getTableStyle());\n    int size = table.getRows().size();\n    for (int i = 0; i < size; i++) {\n        RowRenderData rowRenderData = data.getRows().get(i);\n        renderRow(table.getRows().get(i), rowRenderData, StyleUtils.retriveStyle(run));\n    }\n    applyMergeRule(table, data.getMergeRule());\n    return table;\n}", "public static void renderRow(XWPFTableRow row, RowRenderData data, Style defaultTextStyle) throws Exception {\n    if (null == data)\n        return;\n\n    int size = row.getTableCells().size();\n    if (size != data.obtainColSize()) {\n        throw new IllegalArgumentException(\"Number of cells and render data should be the same!\");\n    }\n    StyleUtils.styleTableRow(row, data.getRowStyle());\n    CellStyle defaultCellStyle = (null == data.getRowStyle()) ? null : data.getRowStyle().getDefaultCellStyle();\n    for (int i = 0; i < size; i++) {\n        renderCell(row.getCell(i), data.getCells().get(i), defaultCellStyle, defaultTextStyle);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTableCells",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render", "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.getActualInsertPosition" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}", "private int getActualInsertPosition(XWPFTableRow tableRow, int insertPosition) {\n    int orginalCol = 0;\n    for (int i = 0; i < tableRow.getTableCells().size(); i++) {\n        XWPFTableCell current = tableRow.getCell(i);\n        int intValue = 1;\n        CTTcPr tcPr = current.getCTTc().getTcPr();\n        if (null != tcPr) {\n            CTDecimalNumber gridSpan = tcPr.getGridSpan();\n            if (null != gridSpan)\n                intValue = gridSpan.getVal().intValue();\n\n        }\n        orginalCol += intValue;\n        if (((orginalCol - intValue) == insertPosition) && (intValue == 1)) {\n            return i;\n        }\n    }\n    return -1;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.obtainColumnSize",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTableCells",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.obtainColumnSize" ],
    "fullMethods" : [ "public static int obtainColumnSize(XWPFTable table) {\n    return table.getRows().get(0).getTableCells().size();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTableCells",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        if ((null != data) && (data instanceof Iterable)) {\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            XWPFTableRow templateRow = table.getRow(templateRowIndex);\n            int insertPosition = templateRowIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            boolean firstFlag = true;\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateRowIndex++;\n                XWPFTableRow nextRow = table.insertNewTableRow(insertPosition);\n                setTableRow(table, templateRow, insertPosition);\n                // double set row\n                XmlCursor newCursor = templateRow.getCtRow().newCursor();\n                newCursor.toPrevSibling();\n                XmlObject object = newCursor.getObject();\n                nextRow = new XWPFTableRow(((CTRow) (object)), table);\n                if (!firstFlag) {\n                    // update VMerge cells for non-first row\n                    List<XWPFTableCell> tableCells = nextRow.getTableCells();\n                    for (XWPFTableCell cell : tableCells) {\n                        CTTcPr tcPr = TableTools.getTcPr(cell);\n                        CTVMerge vMerge = tcPr.getVMerge();\n                        if (null == vMerge)\n                            continue;\n\n                        if (STMerge.RESTART == vMerge.getVal()) {\n                            vMerge.setVal(STMerge.CONTINUE);\n                        }\n                    }\n                } else {\n                    firstFlag = false;\n                }\n                setTableRow(table, nextRow, insertPosition);\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                List<XWPFTableCell> cells = nextRow.getTableCells();\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        table.removeRow(templateRowIndex);\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \" error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTableCells",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    try {\n        RunTemplate runTemplate = cast2runTemplate(eleTemplate);\n        XWPFRun run = runTemplate.getRun();\n        checkTargetIsTable(run, (\"Processing [\" + runTemplate.getTagName()) + \"] failed, the target content is not a table\");\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        final XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n        // \n        int position = getRowIndex(tagCell.getTableRow());\n        List<XWPFTableRow> tempRows = getAllTemplateRow(table, position);\n        if ((null != data) && (data instanceof Iterable)) {\n            // \n            final XWPFTableRow firstTempRow = tempRows.get(0);\n            Iterator<?> dataIt = ((Iterable<?>) (data)).iterator();\n            boolean hasNextData = dataIt.hasNext();\n            int index = 0;\n            while (hasNextData) {\n                Object dt = dataIt.next();\n                hasNextData = dataIt.hasNext();\n                Iterator<XWPFTableRow> rowTempIt = tempRows.iterator();\n                boolean hasNextTempRow = rowTempIt.hasNext();\n                while (hasNextTempRow) {\n                    XWPFTableRow tempRow = rowTempIt.next();\n                    hasNextTempRow = rowTempIt.hasNext();\n                    if (!table.addRow(tempRow, position)) {\n                        throw new RenderException(\"\");\n                    }\n                    // \n                    XmlCursor newCursor = firstTempRow.getCtRow().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    XWPFTableRow newRow = new XWPFTableRow(((CTRow) (object)), table);\n                    newRow.getCtRow().set(object);\n                    setTableRow(table, newRow, position);\n                    List<XWPFTableCell> cells = newRow.getTableCells();\n                    RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(dt, EnvIterator.makeEnv(index, hasNextData || hasNextTempRow)));\n                    cells.forEach(tableCell -> {\n                        List<MetaTemplate> metaTemplates = resolver.resolveBodyElements(tableCell.getBodyElements());\n                        new DocumentProcessor(template, resolver, dataCompute).process(metaTemplates);\n                    });\n                    ++position;\n                } \n                ++index;\n            } \n        }\n        removeTableRow(table, position, tempRows.size());\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-row template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTableCells",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render", "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.getColIndex" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        int templateColIndex = getColIndex(tagCell);\n        if ((null == data) || ((data instanceof Boolean) && (!((Boolean) (data))))) {\n            // table.removeRow(templateRowIndex);\n            // tagCell.setText(\"_delete_\");\n            run.setText(\"_delete_\", 0);\n            CTTcPr tcPr = TableTools.getTcPr(tagCell);\n            CTVMerge vMerge = tcPr.getVMerge();\n            System.out.println(null == vMerge ? null : vMerge.getVal());\n            if ((null != vMerge) && vMerge.getVal().equals(STMerge.RESTART)) {\n                XWPFTableRow row = table.getRow(templateRowIndex + 1);\n                int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n                XWPFTableCell actualCell = row.getCell(actualInsertPosition);\n                System.out.println(actualCell.getCTTc());\n                actualCell.getParagraphArray(0).createRun().setText(\"_delete_\", 0);\n            }\n        } else {\n            run.setText(\"\", 0);\n        }\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}", "private int getColIndex(XWPFTableCell cell) {\n    XWPFTableRow tableRow = cell.getTableRow();\n    int orginalCol = 0;\n    for (int i = 0; i < tableRow.getTableCells().size(); i++) {\n        XWPFTableCell current = tableRow.getCell(i);\n        int intValue = 1;\n        CTTcPr tcPr = current.getCTTc().getTcPr();\n        if (null != tcPr) {\n            CTDecimalNumber gridSpan = tcPr.getGridSpan();\n            if (null != gridSpan)\n                intValue = gridSpan.getVal().intValue();\n\n        }\n        orginalCol += intValue;\n        if (current.getCTTc() == cell.getCTTc()) {\n            return orginalCol - intValue;\n        }\n    }\n    return -1;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTStyle.getName",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeStyles" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "@SuppressWarnings(\"unchecked\")\nprotected Map<String, String> mergeStyles(NiceXWPFDocument source, NiceXWPFDocument merged) {\n    Map<String, String> styleIdsMap = new HashMap<String, String>();\n    XWPFStyles styles = source.getStyles();\n    if (null == styles)\n        styles = source.createStyles();\n\n    XWPFStyles stylesMerge = merged.getStyles();\n    if (null == stylesMerge)\n        return styleIdsMap;\n\n    try {\n        Field listStyleField = XWPFStyles.class.getDeclaredField(\"listStyle\");\n        listStyleField.setAccessible(true);\n        List<XWPFStyle> lists = ((List<XWPFStyle>) (listStyleField.get(stylesMerge)));\n        String defaultParaStyleId = null;\n        for (XWPFStyle xwpfStyle : lists) {\n            if (styles.styleExist(xwpfStyle.getStyleId())) {\n                if (!getRenameAndMergeExistsStyle()) {\n                    continue;\n                }\n                String id = xwpfStyle.getStyleId();\n                xwpfStyle.setStyleId(UUID.randomUUID().toString().substring(0, 8));\n                styleIdsMap.put(id, xwpfStyle.getStyleId());\n            }\n            // fix github issue 499\n            CTStyle ctStyle = xwpfStyle.getCTStyle();\n            if ((ctStyle.isSetDefault() && POIXMLUnits.parseOnOff(ctStyle.xgetDefault())) && (ctStyle.getType() == STStyleType.PARAGRAPH)) {\n                defaultParaStyleId = ctStyle.getStyleId();\n            }\n            if (ctStyle.isSetDefault()) {\n                ctStyle.unsetDefault();\n            }\n            if (ctStyle.isSetName() && StringUtils.isBlank(ctStyle.getName().getVal())) {\n                ctStyle.getName().setVal(ctStyle.getName().getVal() + xwpfStyle.getStyleId());\n            }\n            if (ctStyle.isSetBasedOn()) {\n                String newId = styleIdsMap.get(ctStyle.getBasedOn().getVal());\n                if (null != newId)\n                    ctStyle.getBasedOn().setVal(newId);\n\n            }\n            styles.addStyle(xwpfStyle);\n        }\n        if (null != defaultParaStyleId) {\n            final String dpid = defaultParaStyleId;\n            merged.getParagraphs().stream().filter(p -> null == p.getStyle()).forEach(p -> p.setStyle(dpid));\n        }\n    } catch (Exception e) {\n        // throw exception?\n        logger.error(\"merge style error\", e);\n    }\n    return styleIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableRow",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTrPr.sizeOfTblHeaderArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableRow" ],
    "fullMethods" : [ "/**\n * set row style\n *\n * @param row\n * @param rowStyle\n */\npublic static void styleTableRow(XWPFTableRow row, RowStyle rowStyle) {\n    if ((null == row) || (null == rowStyle))\n        return;\n\n    int height = rowStyle.getHeight();\n    CTRow ctRow = row.getCtRow();\n    CTTrPr properties = (ctRow.isSetTrPr()) ? ctRow.getTrPr() : ctRow.addNewTrPr();\n    if (0 != height) {\n        row.setHeight(height);\n        CTHeight h = (properties.sizeOfTrHeightArray() == 0) ? properties.addNewTrHeight() : properties.getTrHeightArray(0);\n        String heightRule = rowStyle.getHeightRule();\n        if (\"exact\".equals(heightRule))\n            h.setHRule(STHeightRule.EXACT);\n        else if (\"atleast\".equals(heightRule))\n            h.setHRule(STHeightRule.AT_LEAST);\n        else\n            h.setHRule(STHeightRule.AUTO);\n\n    }\n    boolean repeated = rowStyle.isRepeated();\n    if (repeated) {\n        CTOnOff tblHeader = (properties.sizeOfTblHeaderArray() == 0) ? properties.addNewTblHeader() : properties.getTblHeaderArray(0);\n        tblHeader.setVal(XWPFOnOff.ON);\n    }\n    boolean breakAcrossPage = rowStyle.isBreakAcrossPage();\n    if (!breakAcrossPage) {\n        if (properties.sizeOfCantSplitArray() == 0) {\n            properties.addNewCantSplit();\n        } else {\n            properties.getCantSplitArray(0).setVal(XWPFOnOff.ON);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveBorderStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTBorder.getSz",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveBorderStyle" ],
    "fullMethods" : [ "public static BorderStyle retriveBorderStyle(CTBorder border) {\n    BorderStyle.Builder borderBuilder = BorderStyle.builder();\n    if (border.isSetColor())\n        borderBuilder.withColor(border.xgetColor().getStringValue());\n\n    if (border.isSetSz())\n        borderBuilder.withSize(border.getSz().intValue());\n\n    if (border.getVal() != null)\n        borderBuilder.withType(XWPFBorderType.valueOf(border.getVal().toString().toUpperCase()));\n\n    return borderBuilder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTInd.isSetHanging",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.resolver.RunningRunBody.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.addBreak",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.resolver.RunningRunBody.<init>", "com.deepoove.poi.resolver.RunningRunBody.refactorBody" ],
    "fullMethods" : [ "public RunningRunBody(RunBodyContext context, Pattern pattern) {\n    this.runBodyContext = context;\n    this.runs = context.getRuns();\n    if ((null == runs) || runs.isEmpty())\n        return;\n\n    Matcher matcher = pattern.matcher(getText(context));\n    if (matcher.find()) {\n        refactorBody();\n    }\n    buildRunEdge(pattern);\n}", "private void refactorBody() {\n    for (int i = runs.size() - 1; i >= 0; i--) {\n        XWPFRun xwpfRun = runs.get(i);\n        CTR ctr = xwpfRun.getCTR();\n        CTRImpl ctrimpl = ((CTRImpl) (ctr));\n        int sizeOfBrArray = ctr.sizeOfBrArray();\n        int sizeOfCrArray = ctr.sizeOfCrArray();\n        int sizeOfTabArray = ctr.sizeOfTabArray();\n        if (((sizeOfBrArray + sizeOfCrArray) + sizeOfTabArray) > 0) {\n            synchronized(ctrimpl.monitor()) {\n                // ctrimpl.check_orphaned();\n                List<? extends XmlObject> localArrayList = new ArrayList<XmlObject>();\n                ctrimpl.get_store().find_all_element_users(qname, localArrayList);\n                int size = localArrayList.size();\n                for (int j = size - 1; j >= 0; j--) {\n                    Object obj = localArrayList.get(j);\n                    if (obj instanceof CTEmpty) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        String tagName = ((CTEmpty) (obj)).getDomNode().getNodeName();\n                        if (\"w:br\".equals(tagName) || \"br\".equals(tagName)) {\n                            insertNewRun.addBreak();\n                        }\n                        if (\"w:cr\".equals(tagName) || \"cr\".equals(tagName)) {\n                            insertNewRun.addCarriageReturn();\n                        }\n                        if (\"w:tab\".equals(tagName) || \"tab\".equals(tagName)) {\n                            insertNewRun.addTab();\n                        }\n                    } else if (obj instanceof CTBr) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        CTBr addNewBr = insertNewRun.getCTR().addNewBr();\n                        if (null != ((CTBr) (obj)).getType())\n                            addNewBr.setType(((CTBr) (obj)).getType());\n\n                        if (null != ((CTBr) (obj)).getClear())\n                            addNewBr.setClear(((CTBr) (obj)).getClear());\n\n                    } else if (obj instanceof CTText) {\n                        XWPFRun insertNewRun = runBodyContext.insertNewRunAfter(i);\n                        StyleUtils.styleRun(insertNewRun, xwpfRun);\n                        insertNewRun.setText(((CTText) (obj)).getStringValue());\n                    }\n                }\n                runBodyContext.removeRun(i);\n            }\n        }\n    }\n    this.runs = runBodyContext.getRuns();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleCTBorder",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.STBorder.Enum.forString",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.STBorder",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleCTBorder" ],
    "fullMethods" : [ "public static void styleCTBorder(CTBorder b, BorderStyle style) {\n    if (null != style.getType())\n        b.setVal(STBorder.Enum.forString(style.getType().toString().toLowerCase()));\n\n    b.setSz(BigInteger.valueOf(style.getSize()));\n    b.setSpace(BigInteger.valueOf(style.getSpace()));\n    if (null != style.getColor())\n        b.setColor(style.getColor());\n\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr.getShd",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr.getShd",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyle(XWPFParagraph paragraph) {\n    if (null == paragraph)\n        return null;\n\n    Builder builder = ParagraphStyle.builder();\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    if (paragraph.isWordWrapped()) {\n        builder.withAllowWordBreak(true);\n    }\n    if (pr.isSetPBdr()) {\n        CTPBdr ct = pr.getPBdr();\n        if (ct.isSetLeft()) {\n            builder.withLeftBorder(retriveBorderStyle(ct.getLeft()));\n        }\n        if (ct.isSetTop()) {\n            builder.withTopBorder(retriveBorderStyle(ct.getTop()));\n        }\n        if (ct.isSetRight()) {\n            builder.withRightBorder(retriveBorderStyle(ct.getRight()));\n        }\n        if (ct.isSetBottom()) {\n            builder.withBottomBorder(retriveBorderStyle(ct.getBottom()));\n        }\n    }\n    if (pr.isSetShd()) {\n        CTShd shd = pr.getShd();\n        builder.withShadingPattern(XWPFShadingPattern.valueOf(shd.getVal().intValue()));\n        if (shd.isSetFill())\n            builder.withBackgroundColor(shd.xgetFill().getStringValue());\n\n    }\n    builder.withAlign(paragraph.getAlignment());\n    int spacingBeforeLines = paragraph.getSpacingBeforeLines();\n    if ((-1) != spacingBeforeLines) {\n        builder.withSpacingBeforeLines(spacingBeforeLines / 100.0F);\n    }\n    int spacingAfterLines = paragraph.getSpacingAfterLines();\n    if ((-1) != spacingAfterLines) {\n        builder.withSpacingAfterLines(spacingAfterLines / 100.0F);\n    }\n    int spacingBefore = paragraph.getSpacingBefore();\n    if ((-1) != spacingBefore) {\n        builder.withSpacingBefore(UnitUtils.twips2Point(spacingBefore));\n    }\n    int spacingAfter = paragraph.getSpacingAfter();\n    if ((-1) != spacingAfter) {\n        builder.withSpacingAfter(UnitUtils.twips2Point(spacingAfter));\n    }\n    double spacingBetween = paragraph.getSpacingBetween();\n    if ((-1) != spacingBetween) {\n        builder.withSpacing(spacingBetween);\n        builder.withSpacingRule(paragraph.getSpacingLineRule());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShapeProperties",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.main.CTShapeProperties.set",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShapeProperties" ],
    "fullMethods" : [ "@Override\npublic void setShapeProperties(XDDFShapeProperties properties) {\n    if (properties == null) {\n        if (series.isSetSpPr()) {\n            series.unsetSpPr();\n        }\n    } else if (series.isSetSpPr()) {\n        series.setSpPr(properties.getXmlObject());\n    } else {\n        series.addNewSpPr().set(properties.getXmlObject());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.removeBodyElement",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getParagraphs",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.removeBodyElement" ],
    "fullMethods" : [ "@SuppressWarnings(\"unchecked\")\n@Override\npublic void removeBodyElement(int pos) {\n    // TODO remove Nest Table\n    List<IBodyElement> bodyElements = getBodyElements();\n    if ((pos >= 0) && (pos < bodyElements.size())) {\n        BodyElementType type = bodyElements.get(pos).getElementType();\n        if (type == BodyElementType.TABLE) {\n            int indexOf = cell.getTables().indexOf(bodyElements.get(pos));\n            // remove cell's table\n            List<XWPFTable> tables = ((List<XWPFTable>) (ReflectionUtils.getValue(\"tables\", cell)));\n            tables.remove(indexOf);\n            cell.getCTTc().removeTbl(indexOf);\n        }\n        if (type == BodyElementType.PARAGRAPH) {\n            int indexOf = cell.getParagraphs().indexOf(bodyElements.get(pos));\n            // cell.removeParagraph may has bug\n            // cell.removeParagraph(indexOf);\n            List<XWPFParagraph> paragraphs = ((List<XWPFParagraph>) (ReflectionUtils.getValue(\"paragraphs\", cell)));\n            paragraphs.remove(indexOf);\n            cell.getCTTc().removeP(indexOf);\n        }\n        bodyElements.remove(pos);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderCell",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableCell.getParagraphs",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderCell" ],
    "fullMethods" : [ "public static void renderCell(XWPFTableCell cell, CellRenderData data, CellStyle defaultCellStyle, Style defaultTextStyle) throws Exception {\n    if (null == data)\n        return;\n\n    StyleUtils.styleTableCell(cell, defaultCellStyle);\n    StyleUtils.styleTableCell(cell, data.getCellStyle());\n    List<ParagraphStyle> defaultParaStyles = new ArrayList<>();\n    if (null != defaultTextStyle) {\n        defaultParaStyles.add(ParagraphStyle.builder().withDefaultTextStyle(defaultTextStyle).build());\n    }\n    if (null != defaultCellStyle) {\n        defaultParaStyles.add(defaultCellStyle.getDefaultParagraphStyle());\n    }\n    if (null != data.getCellStyle()) {\n        defaultParaStyles.add(data.getCellStyle().getDefaultParagraphStyle());\n    }\n    List<ParagraphRenderData> contents = data.getParagraphs();\n    if ((null != contents) && (!contents.isEmpty())) {\n        BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(cell);\n        XWPFParagraph placeHolder = cell.getParagraphArray(0);\n        if (null == placeHolder)\n            placeHolder = cell.addParagraph();\n\n        for (ParagraphRenderData item : contents) {\n            XWPFParagraph paragraph = bodyContainer.insertNewParagraph(placeHolder.getCTP().newCursor());\n            ParagraphRenderPolicy.Helper.renderParagraph(paragraph.createRun(), item, defaultParaStyles);\n        }\n        List<XWPFParagraph> paragraphs = cell.getParagraphs();\n        int pos = paragraphs.indexOf(placeHolder);\n        if ((-1) != pos)\n            cell.removeParagraph(pos);\n\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.ListRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.createRun",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.ListRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(RenderContext<List<Object>> context) throws Exception {\n    XWPFRun run = context.getRun();\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    List<Object> datas = context.getData();\n    for (Object data : datas) {\n        if (data instanceof TextRenderData) {\n            XWPFRun createRun = bodyContainer.insertNewParagraph(run).createRun();\n            StyleUtils.styleRun(createRun, run);\n            TextRenderPolicy.Helper.renderTextRun(createRun, ((TextRenderData) (data)));\n        } else if (data instanceof TableRenderData) {\n            TableRenderPolicy.Helper.renderTable(run, ((TableRenderData) (data)));\n        } else if (data instanceof NumberingRenderData) {\n            NumberingRenderPolicy.Helper.renderNumbering(run, ((NumberingRenderData) (data)));\n        } else if (data instanceof PictureRenderData) {\n            PictureRenderPolicy.Helper.renderPicture(bodyContainer.insertNewParagraph(run).createRun(), ((PictureRenderData) (data)));\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.merge",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.createRun",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.merge" ],
    "fullMethods" : [ "public NiceXWPFDocument merge(NiceXWPFDocument docMerge) throws Exception {\n    return merge(Arrays.asList(docMerge), createParagraph().createRun());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.createRun",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment" ],
    "fullMethods" : [ "public static void renderComment(XWPFRun run, CommentRenderData data) throws Exception {\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper parentContext = new XWPFParagraphWrapper(paragraph);\n    BigInteger cId = BigInteger.ZERO;\n    CommentContent commentContent = data.getCommentContent();\n    if (null != commentContent) {\n        XWPFComments comments = ((NiceXWPFDocument) (paragraph.getDocument())).createComments();\n        XWPFComment newComment = comments.createComment(NextIDUtils.getCommentMaxId(comments).add(BigInteger.ONE));\n        newComment.setAuthor(commentContent.getAuthor());\n        newComment.setDate(commentContent.getDate());\n        newComment.setInitials(commentContent.getInitials());\n        renderDocument(newComment.createParagraph().createRun(), commentContent.getContent());\n        cId = newComment.getCtComment().getId();\n        parentContext.insertNewCommentRangeStart(run, cId);\n    }\n    renderParagraph(run, Paragraphs.of().addList(data.getContents()).create());\n    if (null != commentContent) {\n        parentContext.insertNewCommentRangeEnd(run, cId);\n        XWPFRun newRun = parentContext.insertNewRun(ParagraphUtils.getRunPos(run));\n        newRun.getCTR().addNewCommentReference().setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.merge",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.createRun",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.merge" ],
    "fullMethods" : [ "public NiceXWPFDocument merge(Iterator<NiceXWPFDocument> iterator, XWPFRun run) throws Exception {\n    XWPFRun newRun = run;\n    String paragraphText = ParagraphUtils.trimLine(((XWPFParagraph) (run.getParent())));\n    boolean havePictures = ParagraphUtils.havePictures(((XWPFParagraph) (run.getParent())));\n    if ((!ParagraphUtils.trimLine(run.text()).equals(paragraphText)) || havePictures) {\n        BodyContainer container = BodyContainerFactory.getBodyContainer(run);\n        XWPFParagraph paragraph = container.insertNewParagraph(run);\n        newRun = paragraph.createRun();\n    }\n    return new XmlXWPFDocumentMerge().merge(this, iterator, newRun);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.createRun",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFParagraphWrapper.insertNewRunAfter" ],
    "fullMethods" : [ "public XWPFRun insertNewRunAfter(int pos) {\n    if (pos == paragraph.getRuns().size()) {\n        return paragraph.createRun();\n    }\n    if ((pos >= 0) && (pos < paragraph.getRuns().size())) {\n        XWPFRun run = paragraph.getRuns().get(pos);\n        CTR ctr = run.getCTR();\n        XmlCursor newCursor = ctr.newCursor();\n        if (!isCursorInParagraph(newCursor)) {\n            // look up correct position for CTP -> XXX -> R array\n            newCursor.toParent();\n        }\n        if (isCursorInParagraph(newCursor)) {\n            boolean nextSibling = newCursor.toNextSibling();\n            if (!nextSibling) {\n                return paragraph.createRun();\n            }\n            String uri = CTR.type.getName().getNamespaceURI();\n            String localPart = \"r\";\n            newCursor.beginElement(localPart, uri);\n            newCursor.toParent();\n            CTR r = ((CTR) (newCursor.getObject()));\n            XWPFRun newRun = new XWPFRun(r, ((IRunBody) (this.paragraph)));\n            List<IRunElement> iruns = getIRuns();\n            List<XWPFRun> runs = getRuns();\n            int iPos = iruns.size();\n            if (pos < runs.size()) {\n                XWPFRun oldAtPos = runs.get(pos);\n                int oldAt = iruns.indexOf(oldAtPos);\n                if (oldAt != (-1)) {\n                    iPos = oldAt;\n                }\n            }\n            if ((iPos + 1) >= iruns.size()) {\n                iruns.add(newRun);\n            } else {\n                iruns.add(iPos + 1, newRun);\n            }\n            // Runs itself is easy to update\n            if ((pos + 1) >= runs.size()) {\n                runs.add(newRun);\n            } else {\n                runs.add(pos + 1, newRun);\n            }\n            newCursor.dispose();\n            return newRun;\n        }\n        newCursor.dispose();\n    }\n    return null;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.AbstractXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.createRun",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.AbstractXWPFDocumentMerge.merge" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergedIterator) throws Exception {\n    return merge(source, mergedIterator, source.createParagraph().createRun());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.NumberingRenderPolicy.Helper.renderNumbering",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.createRun",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.NumberingRenderPolicy.Helper.renderNumbering" ],
    "fullMethods" : [ "public static void renderNumbering(XWPFRun run, NumberingRenderData data) throws Exception {\n    List<NumberingItemRenderData> items = data.getItems();\n    NumberingFormat[] array = data.getFormats().toArray(new NumberingFormat[]{  });\n    BigInteger numID = ((NiceXWPFDocument) (run.getParent().getDocument())).addNewMultiLevelNumberingId(array);\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    for (NumberingItemRenderData item : items) {\n        XWPFParagraph paragraph = bodyContainer.insertNewParagraph(run);\n        int level = item.getLevel();\n        if (NumberingItemRenderData.LEVEL_NORMAL != level) {\n            paragraph.setNumID(numID);\n            paragraph.setNumILvl(BigInteger.valueOf(level));\n        }\n        XWPFRun createRun = paragraph.createRun();\n        // StyleUtils.styleParaRpr(paragraph, StyleUtils.retriveStyle(run));\n        StyleUtils.styleRun(createRun, run);\n        ParagraphRenderPolicy.Helper.renderParagraph(createRun, item.getItem());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.DocumentRenderPolicy.Helper.renderDocument",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.createRun",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.DocumentRenderPolicy.Helper.renderDocument" ],
    "fullMethods" : [ "public static void renderDocument(XWPFRun run, DocumentRenderData data) throws Exception {\n    List<RenderData> contents = data.getContents();\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    for (RenderData item : contents) {\n        XWPFParagraph paragraph = bodyContainer.insertNewParagraph(run);\n        XWPFRun createRun = paragraph.createRun();\n        StyleUtils.styleParagraph(paragraph, run.getParent());\n        StyleUtils.styleRun(createRun, run);\n        if (item instanceof ParagraphRenderData) {\n            ParagraphRenderPolicy.Helper.renderParagraph(createRun, ((ParagraphRenderData) (item)));\n        } else if (item instanceof TableRenderData) {\n            TableRenderPolicy.Helper.renderTable(createRun, ((TableRenderData) (item)));\n            BodyContainerFactory.getBodyContainer(createRun).clearPlaceholder(createRun);\n        } else if (item instanceof NumberingRenderData) {\n            NumberingRenderPolicy.Helper.renderNumbering(createRun, ((NumberingRenderData) (item)));\n            BodyContainerFactory.getBodyContainer(createRun).clearPlaceholder(createRun);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.XWPFTemplate.create",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.createRun",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.XWPFTemplate.create" ],
    "fullMethods" : [ "/**\n * Create new document with styled tag\n *\n * @return template\n * @since 1.10.0\n */\npublic static XWPFTemplate create(DocumentRenderData data, Style templateTagStyle) {\n    Configure configure = Configure.builder().bind(TEMPLATE_TAG_NAME, new DocumentRenderPolicy()).build();\n    XWPFDocument document = new NiceXWPFDocument();\n    XWPFRun run = document.createParagraph().createRun();\n    run.setText((configure.getGramerPrefix() + TEMPLATE_TAG_NAME) + configure.getGramerSuffix());\n    StyleUtils.styleRun(run, templateTagStyle);\n    return compile(document, configure).render(Collections.singletonMap(TEMPLATE_TAG_NAME, data));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderCell",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.createRun",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TableRenderPolicy.Helper.renderCell" ],
    "fullMethods" : [ "public static void renderCell(XWPFTableCell cell, CellRenderData data, CellStyle defaultCellStyle, Style defaultTextStyle) throws Exception {\n    if (null == data)\n        return;\n\n    StyleUtils.styleTableCell(cell, defaultCellStyle);\n    StyleUtils.styleTableCell(cell, data.getCellStyle());\n    List<ParagraphStyle> defaultParaStyles = new ArrayList<>();\n    if (null != defaultTextStyle) {\n        defaultParaStyles.add(ParagraphStyle.builder().withDefaultTextStyle(defaultTextStyle).build());\n    }\n    if (null != defaultCellStyle) {\n        defaultParaStyles.add(defaultCellStyle.getDefaultParagraphStyle());\n    }\n    if (null != data.getCellStyle()) {\n        defaultParaStyles.add(data.getCellStyle().getDefaultParagraphStyle());\n    }\n    List<ParagraphRenderData> contents = data.getParagraphs();\n    if ((null != contents) && (!contents.isEmpty())) {\n        BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(cell);\n        XWPFParagraph placeHolder = cell.getParagraphArray(0);\n        if (null == placeHolder)\n            placeHolder = cell.addParagraph();\n\n        for (ParagraphRenderData item : contents) {\n            XWPFParagraph paragraph = bodyContainer.insertNewParagraph(placeHolder.getCTP().newCursor());\n            ParagraphRenderPolicy.Helper.renderParagraph(paragraph.createRun(), item, defaultParaStyles);\n        }\n        List<XWPFParagraph> paragraphs = cell.getParagraphs();\n        int pos = paragraphs.indexOf(placeHolder);\n        if ((-1) != pos)\n            cell.removeParagraph(pos);\n\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFParagraph.createRun",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        int templateColIndex = getColIndex(tagCell);\n        if ((null == data) || ((data instanceof Boolean) && (!((Boolean) (data))))) {\n            // table.removeRow(templateRowIndex);\n            // tagCell.setText(\"_delete_\");\n            run.setText(\"_delete_\", 0);\n            CTTcPr tcPr = TableTools.getTcPr(tagCell);\n            CTVMerge vMerge = tcPr.getVMerge();\n            System.out.println(null == vMerge ? null : vMerge.getVal());\n            if ((null != vMerge) && vMerge.getVal().equals(STMerge.RESTART)) {\n                XWPFTableRow row = table.getRow(templateRowIndex + 1);\n                int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n                XWPFTableCell actualCell = row.getCell(actualInsertPosition);\n                System.out.println(actualCell.getCTTc());\n                actualCell.getParagraphArray(0).createRun().setText(\"_delete_\", 0);\n            }\n        } else {\n            run.setText(\"\", 0);\n        }\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.getSzArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFonts.setEastAsia",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.removeParagraph",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTSdtContentBlock.removeP",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XWPFStructuredDocumentTagContent.removeParagraph" ],
    "fullMethods" : [ "/**\n * removes a paragraph of this textbox\n *\n * @param pos\n * \t\tThe position in the list of paragraphs, 0-based\n */\npublic void removeParagraph(int pos) {\n    XWPFParagraph removedParagraph = paragraphs.get(pos);\n    paragraphs.remove(pos);\n    sdtContentBlock.removeP(pos);\n    sdtElements.remove(removedParagraph);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.EnhancedXWPFChart.<init>",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFChart.<init>",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.EnhancedXWPFChart.<init>" ],
    "fullMethods" : [ "public EnhancedXWPFChart() {\n    super();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.PictureRenderPolicy.Helper.renderPicture",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.PictureRenderPolicy.Helper.renderPicture" ],
    "fullMethods" : [ "public static void renderPicture(XWPFRun run, PictureRenderData picture) throws Exception {\n    byte[] imageBytes = picture.readPictureData();\n    if (null == imageBytes) {\n        throw new IllegalStateException(\"Can't read picture byte arrays!\");\n    }\n    PictureType pictureType = picture.getPictureType();\n    if (null == pictureType) {\n        pictureType = PictureType.suggestFileType(imageBytes);\n    }\n    if (null == pictureType) {\n        throw new RenderException(\"PictureRenderData must set picture type!\");\n    }\n    PictureStyle style = picture.getPictureStyle();\n    if (null == style)\n        style = new PictureStyle();\n\n    int width = style.getWidth();\n    int height = style.getHeight();\n    int svgScale = style.getSvgScale();\n    if (pictureType == PictureType.SVG) {\n        imageBytes = SVGConvertor.toPng(imageBytes, ((float) (width)), ((float) (height)), svgScale);\n        pictureType = PictureType.PNG;\n    }\n    if (!isSetSize(style)) {\n        BufferedImage original = BufferedImageUtils.readBufferedImage(imageBytes);\n        width = original.getWidth();\n        height = original.getHeight();\n        if (style.getScalePattern() == WidthScalePattern.FIT) {\n            BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n            int pageWidth = UnitUtils.twips2Pixel(bodyContainer.elementPageWidth(((IBodyElement) (run.getParent()))));\n            if (width > pageWidth) {\n                double ratio = pageWidth / ((double) (width));\n                width = pageWidth;\n                height = ((int) (height * ratio));\n            }\n        }\n    }\n    try (InputStream stream = new ByteArrayInputStream(imageBytes)) {\n        PictureAlign align = style.getAlign();\n        if ((null != align) && (run.getParent() instanceof XWPFParagraph)) {\n            ((XWPFParagraph) (run.getParent())).setAlignment(ParagraphAlignment.valueOf(align.ordinal() + 1));\n        }\n        run.addPicture(stream, pictureType.type(), \"Generated\", Units.pixelToEMU(width), Units.pixelToEMU(height));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.DefaultPictImageTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.reference.DefaultPictImageTemplateRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(PictImageTemplate pictImageTemplate, PictureRenderData data, XWPFTemplate template) throws Exception {\n    CTPictWrapper t = pictImageTemplate.getPicture();\n    byte[] image = data.readPictureData();\n    PictureType pictureType = data.getPictureType();\n    if (null == pictureType) {\n        pictureType = PictureType.suggestFileType(image);\n    }\n    XWPFRun run = pictImageTemplate.getRun();\n    if (run.getParent().getPart() instanceof XWPFHeaderFooter) {\n        XWPFHeaderFooter headerFooter = ((XWPFHeaderFooter) (run.getParent().getPart()));\n        setPictureReference(t, headerFooter.addPictureData(image, pictureType.type()));\n    } else {\n        setPictureReference(t, template.getXWPFDocument().addPictureData(image, pictureType.type()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CommentBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CommentBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFHeaderFooter\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.DynamicTableRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.DynamicTableRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(RenderContext<Object> context) throws Exception {\n    RunTemplate runTemplate = ((RunTemplate) (context.getEleTemplate()));\n    XWPFRun run = runTemplate.getRun();\n    run.setText(\"\", 0);\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell cell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = cell.getTableRow().getTable();\n        render(table, context.getData());\n    } catch (Exception e) {\n        throw new RenderException(\"Dynamic render table error:\" + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.NiceXWPFDocument.merge",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.NiceXWPFDocument.merge" ],
    "fullMethods" : [ "public NiceXWPFDocument merge(Iterator<NiceXWPFDocument> iterator, XWPFRun run) throws Exception {\n    XWPFRun newRun = run;\n    String paragraphText = ParagraphUtils.trimLine(((XWPFParagraph) (run.getParent())));\n    boolean havePictures = ParagraphUtils.havePictures(((XWPFParagraph) (run.getParent())));\n    if ((!ParagraphUtils.trimLine(run.text()).equals(paragraphText)) || havePictures) {\n        BodyContainer container = BodyContainerFactory.getBodyContainer(run);\n        XWPFParagraph paragraph = container.insertNewParagraph(run);\n        newRun = paragraph.createRun();\n    }\n    return new XmlXWPFDocumentMerge().merge(this, iterator, newRun);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.field.SimpleFieldRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.field.SimpleFieldRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(RenderContext<String> context) throws Exception {\n    RunTemplate runTemplate = ((RunTemplate) (context.getEleTemplate()));\n    XWPFRun run = context.getRun();\n    run.setText(\"\", 0);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper paragraphWrapper = new XWPFParagraphWrapper(paragraph);\n    XWPFRun startRun = paragraphWrapper.insertNewRun(runTemplate.getRunPos());\n    StyleUtils.styleRun(startRun, run);\n    CTR ctr = startRun.getCTR();\n    CTFldChar addNewFldChar = ctr.addNewFldChar();\n    addNewFldChar.setFldCharType(STFldCharType.BEGIN);\n    XWPFRun instrRun = paragraphWrapper.insertNewRun(runTemplate.getRunPos());\n    StyleUtils.styleRun(instrRun, run);\n    ctr = instrRun.getCTR();\n    CTText addNewInstrText = ctr.addNewInstrText();\n    // \"EQ \\\\o\\\\ac(, 1)\"\n    addNewInstrText.setStringValue(context.getData());\n    XWPFRun sepRun = paragraphWrapper.insertNewRun(runTemplate.getRunPos());\n    StyleUtils.styleRun(sepRun, run);\n    ctr = sepRun.getCTR();\n    addNewFldChar = ctr.addNewFldChar();\n    addNewFldChar.setFldCharType(STFldCharType.SEPARATE);\n    XWPFRun endRun = paragraphWrapper.insertNewRun(runTemplate.getRunPos());\n    StyleUtils.styleRun(endRun, run);\n    ctr = endRun.getCTR();\n    addNewFldChar = ctr.addNewFldChar();\n    addNewFldChar.setFldCharType(STFldCharType.END);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.BodyContainer.insertNewParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.BodyContainer.insertNewParagraph" ],
    "fullMethods" : [ "/**\n * insert paragraph at position of run\n *\n * @param run\n * @return the inserted paragraph\n */\ndefault XWPFParagraph insertNewParagraph(XWPFRun run) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    return insertNewParagraph(cursor);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.BodyContainer.clearPlaceholder",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.BodyContainer.clearPlaceholder" ],
    "fullMethods" : [ "/**\n * clear run\n *\n * @param run\n * @param remove\n */\ndefault void clearPlaceholder(XWPFRun run, boolean remove) {\n    IRunBody parent = run.getParent();\n    run.setText(\"\", 0);\n    if (parent instanceof XWPFParagraph) {\n        if (remove)\n            new XWPFParagraphWrapper(((XWPFParagraph) (parent))).removeRun(ParagraphUtils.getRunPos(run));\n\n        String paragraphText = ParagraphUtils.trimLine(((XWPFParagraph) (parent)));\n        boolean havePictures = ParagraphUtils.havePictures(((XWPFParagraph) (parent)));\n        boolean havePageBreak = ParagraphUtils.havePageBreak(((XWPFParagraph) (parent)));\n        boolean haveObject = ParagraphUtils.haveObject(((XWPFParagraph) (parent)));\n        if (((\"\".equals(paragraphText) && (!havePictures)) && (!havePageBreak)) && (!haveObject)) {\n            int pos = getPosOfParagraph(((XWPFParagraph) (parent)));\n            removeBodyElement(pos);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.RunBodyContextFactory.getRunBodyContext",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.RunBodyContextFactory.getRunBodyContext" ],
    "fullMethods" : [ "public static RunBodyContext getRunBodyContext(XWPFRun run) {\n    return getRunBodyContext(run.getParent());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFTableCell\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.DocumentBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.DocumentBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.IterableProcessor.next",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.IterableProcessor.next" ],
    "fullMethods" : [ "@Override\npublic void next(IterableTemplate iterable, ParentContext parentContext, IterableContext context, Object model) {\n    BodyContainer bodyContainer = ((BodyContainer) (parentContext));\n    XWPFParagraph endParagraph = ((XWPFParagraph) (iterable.getEndRun().getParent()));\n    CTP endCtp = endParagraph.getCTP();\n    int start = context.getStart();\n    int end = context.getEnd();\n    context.getNumberingContinue().resetCache();\n    // copy positon cursor\n    XmlCursor insertPostionCursor = endCtp.newCursor();\n    // copy content\n    List<IBodyElement> bodyElements = bodyContainer.getBodyElements();\n    List<IBodyElement> copies = new ArrayList<IBodyElement>();\n    for (int i = start + 1; i < end; i++) {\n        IBodyElement iBodyElement = bodyElements.get(i);\n        if (iBodyElement.getElementType() == BodyElementType.PARAGRAPH) {\n            insertPostionCursor = endCtp.newCursor();\n            XWPFParagraph insertNewParagraph = bodyContainer.insertNewParagraph(insertPostionCursor);\n            // find insert paragraph pos\n            int paraPos = bodyContainer.getParaPos(insertNewParagraph);\n            bodyContainer.setParagraph(((XWPFParagraph) (iBodyElement)), paraPos);\n            // re-update ctp reference\n            insertPostionCursor = endCtp.newCursor();\n            insertPostionCursor.toPrevSibling();\n            XmlObject object = insertPostionCursor.getObject();\n            XWPFParagraph copy = new XWPFParagraph(((CTP) (object)), bodyContainer.getTarget());\n            // update docpr\n            DrawingSupport.updateDocPrId(copy);\n            // update numbering\n            context.getNumberingContinue().updateNumbering(((XWPFParagraph) (iBodyElement)), copy);\n            copies.add(copy);\n            bodyContainer.updateBodyElements(insertNewParagraph, copy);\n            bodyContainer.setParagraph(copy, paraPos);\n        } else if (iBodyElement.getElementType() == BodyElementType.TABLE) {\n            insertPostionCursor = endCtp.newCursor();\n            XWPFTable insertNewTbl = bodyContainer.insertNewTbl(insertPostionCursor);\n            // find insert table pos\n            int tablePos = bodyContainer.getTablePos(insertNewTbl);\n            bodyContainer.setTable(tablePos, ((XWPFTable) (iBodyElement)));\n            insertPostionCursor = endCtp.newCursor();\n            insertPostionCursor.toPrevSibling();\n            XmlObject object = insertPostionCursor.getObject();\n            XWPFTable copy = new XWPFTable(((CTTbl) (object)), bodyContainer.getTarget());\n            DrawingSupport.updateDocPrId(copy);\n            copies.add(copy);\n            bodyContainer.updateBodyElements(insertNewTbl, copy);\n            bodyContainer.setTable(tablePos, copy);\n        }\n    }\n    // re-parse\n    List<MetaTemplate> templates = this.resolver.resolveBodyElements(copies);\n    // render\n    process(templates, model);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.TextRenderPolicy.Helper.renderTextRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.TextRenderPolicy.Helper.renderTextRun", "com.deepoove.poi.policy.TextRenderPolicy.Helper.createHyperlink" ],
    "fullMethods" : [ "public static void renderTextRun(XWPFRun run, TextRenderData data) {\n    XWPFRun textRun = run;\n    if (data instanceof HyperlinkTextRenderData) {\n        textRun = createHyperlink(run, ((HyperlinkTextRenderData) (data)).getUrl());\n    }\n    StyleUtils.styleRun(textRun, data.getStyle());\n    String text = Optional.ofNullable(data.getText()).orElse(\"\");\n    String[] fragment = text.split(REGEX_LINE_CHARACTOR, -1);\n    if (fragment.length > 0) {\n        textRun.setText(fragment[0], 0);\n        boolean lineAtTable = ((fragment.length > 1) && (!(data instanceof HyperlinkTextRenderData))) && TableTools.isInsideTable(run);\n        for (int i = 1; i < fragment.length; i++) {\n            if (lineAtTable) {\n                textRun.addBreak(BreakType.TEXT_WRAPPING);\n            } else {\n                textRun.addCarriageReturn();\n            }\n            textRun.setText(fragment[i]);\n        }\n    }\n    if (data instanceof BookmarkTextRenderData) {\n        createBookmark(textRun, ((BookmarkTextRenderData) (data)).getBookmark());\n    }\n}", "private static XWPFRun createHyperlink(XWPFRun run, String url) {\n    XWPFParagraphWrapper paragraph = new XWPFParagraphWrapper(((XWPFParagraph) (run.getParent())));\n    XWPFRun hyperlink = paragraph.insertNewHyperLinkRun(run, url);\n    StyleUtils.styleRun(hyperlink, run);\n    run.setText(\"\", 0);\n    return hyperlink;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.AbstractIterableProcessor.visit",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.AbstractIterableProcessor.visit", "com.deepoove.poi.render.processor.IterableProcessor.handleNever" ],
    "fullMethods" : [ "@Override\npublic void visit(IterableTemplate iterableTemplate) {\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(iterableTemplate);\n    Object compute = renderDataCompute.compute(iterableTemplate.getStartMark().getTagName());\n    if ((null == compute) || ((compute instanceof Boolean) && (!((Boolean) (compute))))) {\n        handleNever(iterableTemplate, bodyContainer);\n        afterHandle(iterableTemplate, bodyContainer, true);\n    } else if (compute instanceof Iterable) {\n        handleIterable(iterableTemplate, bodyContainer, ((Iterable<?>) (compute)));\n        afterHandle(iterableTemplate, bodyContainer, false);\n    } else {\n        if ((compute instanceof Boolean) && ((Boolean) (compute))) {\n            handleOnceWithScope(iterableTemplate, renderDataCompute);\n        } else {\n            handleOnce(iterableTemplate, compute);\n        }\n        afterHandle(iterableTemplate, bodyContainer, false);\n    }\n}", "@Override\nprotected void handleNever(IterableTemplate iterableTemplate, BodyContainer bodyContainer) {\n    XWPFParagraph startParagraph = ((XWPFParagraph) (iterableTemplate.getStartRun().getParent()));\n    XWPFParagraph endParagraph = ((XWPFParagraph) (iterableTemplate.getEndRun().getParent()));\n    int startPos = bodyContainer.getPosOfParagraphCTP(startParagraph.getCTP());\n    int endPos = bodyContainer.getPosOfParagraphCTP(endParagraph.getCTP());\n    // remove content\n    for (int i = endPos - 1; i > startPos; i--) {\n        bodyContainer.removeBodyElement(i);\n    }\n    XWPFParagraphWrapper startParagraphWrapper = new XWPFParagraphWrapper(startParagraph);\n    XWPFParagraphWrapper endParagraphWrapper = new XWPFParagraphWrapper(endParagraph);\n    Integer startRunPos = iterableTemplate.getStartMark().getRunPos();\n    Integer endRunPos = iterableTemplate.getEndMark().getRunPos();\n    // remove run content\n    List<XWPFRun> startRuns = startParagraph.getRuns();\n    int startSize = startRuns.size();\n    for (int i = startSize - 1; i > startRunPos; i--) {\n        startParagraphWrapper.removeRun(i);\n    }\n    for (int i = endRunPos - 1; i >= 0; i--) {\n        endParagraphWrapper.removeRun(i);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.bookmark.BookmarkRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.bookmark.BookmarkRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(RenderContext<TextRenderData> context) throws Exception {\n    Helper.renderTextRun(context.getRun(), context.getData());\n    XWPFRun run = context.getRun();\n    XWPFParagraphWrapper wapper = new XWPFParagraphWrapper(((XWPFParagraph) (run.getParent())));\n    CTBookmark bookmarkStart = wapper.insertNewBookmark(run);\n    Object renderData = context.getData();\n    TextRenderData data = (renderData instanceof TextRenderData) ? ((TextRenderData) (renderData)) : new TextRenderData(renderData.toString());\n    String text = (null == data.getText()) ? \"\" : data.getText();\n    bookmarkStart.setName(text);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.ParagraphRenderPolicy.Helper.renderParagraph",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.ParagraphRenderPolicy.Helper.renderParagraph" ],
    "fullMethods" : [ "public static void renderParagraph(XWPFRun run, ParagraphRenderData data, List<ParagraphStyle> defaultControlStyles) throws Exception {\n    List<RenderData> contents = data.getContents();\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    styleParagraphWithDefaultStyle(paragraph, defaultControlStyles);\n    StyleUtils.styleParagraph(paragraph, data.getParagraphStyle());\n    XWPFParagraphWrapper parentContext = new XWPFParagraphWrapper(paragraph);\n    for (RenderData content : contents) {\n        XWPFRun fragment = parentContext.insertNewRun(ParagraphUtils.getRunPos(run));\n        StyleUtils.styleRun(fragment, run);\n        if (content instanceof TextRenderData) {\n            styleRunWithDefaultStyle(fragment, defaultControlStyles);\n            StyleUtils.styleRun(fragment, null == data.getParagraphStyle() ? null : data.getParagraphStyle().getDefaultTextStyle());\n            TextRenderPolicy.Helper.renderTextRun(fragment, ((TextRenderData) (content)));\n        } else if (content instanceof PictureRenderData) {\n            PictureRenderPolicy.Helper.renderPicture(fragment, ((PictureRenderData) (content)));\n        } else if (content instanceof CommentRenderData) {\n            CommentRenderPolicy.Helper.renderComment(fragment, ((CommentRenderData) (content)));\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.DocumentRenderPolicy.Helper.renderDocument",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.DocumentRenderPolicy.Helper.renderDocument" ],
    "fullMethods" : [ "public static void renderDocument(XWPFRun run, DocumentRenderData data) throws Exception {\n    List<RenderData> contents = data.getContents();\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    for (RenderData item : contents) {\n        XWPFParagraph paragraph = bodyContainer.insertNewParagraph(run);\n        XWPFRun createRun = paragraph.createRun();\n        StyleUtils.styleParagraph(paragraph, run.getParent());\n        StyleUtils.styleRun(createRun, run);\n        if (item instanceof ParagraphRenderData) {\n            ParagraphRenderPolicy.Helper.renderParagraph(createRun, ((ParagraphRenderData) (item)));\n        } else if (item instanceof TableRenderData) {\n            TableRenderPolicy.Helper.renderTable(createRun, ((TableRenderData) (item)));\n            BodyContainerFactory.getBodyContainer(createRun).clearPlaceholder(createRun);\n        } else if (item instanceof NumberingRenderData) {\n            NumberingRenderPolicy.Helper.renderNumbering(createRun, ((NumberingRenderData) (item)));\n            BodyContainerFactory.getBodyContainer(createRun).clearPlaceholder(createRun);\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.CellBodyContainer.clearPlaceholder",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.CellBodyContainer.clearPlaceholder" ],
    "fullMethods" : [ "@Override\npublic void clearPlaceholder(XWPFRun run) {\n    IRunBody parent = run.getParent();\n    run.setText(\"\", 0);\n    // <p>elements must be located before </tc> elements\n    if (parent instanceof XWPFParagraph) {\n        String paragraphText = ParagraphUtils.trimLine(((XWPFParagraph) (parent)));\n        boolean havePictures = ParagraphUtils.havePictures(((XWPFParagraph) (parent)));\n        if (\"\".equals(paragraphText) && (!havePictures)) {\n            int pos = getPosOfParagraph(((XWPFParagraph) (parent)));\n            int lastPos = cell.getBodyElements().size() - 1;\n            if (canRemoveParagraph(pos, lastPos)) {\n                removeBodyElement(pos);\n            }\n        }\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        int templateColIndex = getColIndex(tagCell);\n        if ((null == data) || ((data instanceof Boolean) && (!((Boolean) (data))))) {\n            // table.removeRow(templateRowIndex);\n            // tagCell.setText(\"_delete_\");\n            run.setText(\"_delete_\", 0);\n            CTTcPr tcPr = TableTools.getTcPr(tagCell);\n            CTVMerge vMerge = tcPr.getVMerge();\n            System.out.println(null == vMerge ? null : vMerge.getVal());\n            if ((null != vMerge) && vMerge.getVal().equals(STMerge.RESTART)) {\n                XWPFTableRow row = table.getRow(templateRowIndex + 1);\n                int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n                XWPFTableCell actualCell = row.getCell(actualInsertPosition);\n                System.out.println(actualCell.getCTTc());\n                actualCell.getParagraphArray(0).createRun().setText(\"_delete_\", 0);\n            }\n        } else {\n            run.setText(\"\", 0);\n        }\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.isInsideTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.TableTools.isInsideTable" ],
    "fullMethods" : [ "public static boolean isInsideTable(XWPFRun run) {\n    return ((XWPFParagraph) (run.getParent())).getPartType() == BodyType.TABLECELL;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        for (int i = rowSize - 1; i >= 0; i--) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            String text = row.getCell(actualInsertPosition).getText();\n            if (\"_delete_\".equals(text)) {\n                table.removeRow(i);\n            } else {\n                removeCell(row, actualInsertPosition);\n            }\n        }\n    } catch (Exception e) {\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.BodyContainerFactory.getBodyContainer",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.BodyContainerFactory.getBodyContainer" ],
    "fullMethods" : [ "public static BodyContainer getBodyContainer(XWPFRun run) {\n    assert run.getParent() instanceof IBodyElement;\n    return getBodyContainer(((IBodyElement) (run.getParent())).getBody());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.toc.TOCRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.toc.TOCRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    XWPFRun run = ((RunTemplate) (eleTemplate)).getRun();\n    run.setText(\"\", 0);\n    XWPFParagraph tocPara = ((XWPFParagraph) (run.getParent()));\n    XWPFFieldRun fieldRun = tocPara.insertNewFieldRun(0);\n    CTSimpleField toc = fieldRun.getCTField();\n    toc.setInstr(\"TOC \\\\o\");\n    toc.setDirty(XWPFOnOff.ON);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.comment.CommentRenderPolicy.Helper.renderComment" ],
    "fullMethods" : [ "public static void renderComment(XWPFRun run, CommentRenderData data) throws Exception {\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    XWPFParagraphWrapper parentContext = new XWPFParagraphWrapper(paragraph);\n    BigInteger cId = BigInteger.ZERO;\n    CommentContent commentContent = data.getCommentContent();\n    if (null != commentContent) {\n        XWPFComments comments = ((NiceXWPFDocument) (paragraph.getDocument())).createComments();\n        XWPFComment newComment = comments.createComment(NextIDUtils.getCommentMaxId(comments).add(BigInteger.ONE));\n        newComment.setAuthor(commentContent.getAuthor());\n        newComment.setDate(commentContent.getDate());\n        newComment.setInitials(commentContent.getInitials());\n        renderDocument(newComment.createParagraph().createRun(), commentContent.getContent());\n        cId = newComment.getCtComment().getId();\n        parentContext.insertNewCommentRangeStart(run, cId);\n    }\n    renderParagraph(run, Paragraphs.of().addList(data.getContents()).create());\n    if (null != commentContent) {\n        parentContext.insertNewCommentRangeEnd(run, cId);\n        XWPFRun newRun = parentContext.insertNewRun(ParagraphUtils.getRunPos(run));\n        newRun.getCTR().addNewCommentReference().setId(cId);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.NumberingRenderPolicy.Helper.renderNumbering",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.NumberingRenderPolicy.Helper.renderNumbering" ],
    "fullMethods" : [ "public static void renderNumbering(XWPFRun run, NumberingRenderData data) throws Exception {\n    List<NumberingItemRenderData> items = data.getItems();\n    NumberingFormat[] array = data.getFormats().toArray(new NumberingFormat[]{  });\n    BigInteger numID = ((NiceXWPFDocument) (run.getParent().getDocument())).addNewMultiLevelNumberingId(array);\n    BodyContainer bodyContainer = BodyContainerFactory.getBodyContainer(run);\n    for (NumberingItemRenderData item : items) {\n        XWPFParagraph paragraph = bodyContainer.insertNewParagraph(run);\n        int level = item.getLevel();\n        if (NumberingItemRenderData.LEVEL_NORMAL != level) {\n            paragraph.setNumID(numID);\n            paragraph.setNumILvl(BigInteger.valueOf(level));\n        }\n        XWPFRun createRun = paragraph.createRun();\n        // StyleUtils.styleParaRpr(paragraph, StyleUtils.retriveStyle(run));\n        StyleUtils.styleRun(createRun, run);\n        ParagraphRenderPolicy.Helper.renderParagraph(createRun, item.getItem());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.insertNewTable",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.HeaderFooterBodyContainer.insertNewTable" ],
    "fullMethods" : [ "@Override\npublic XWPFTable insertNewTable(XWPFRun run, int row, int col) {\n    XmlCursor cursor = ((XWPFParagraph) (run.getParent())).getCTP().newCursor();\n    XWPFTable table = insertNewTbl(cursor);\n    // hack for cursor.removeXmlContents(); in XWPFHeaderFooter\n    List<XWPFTableRow> rows = table.getRows();\n    for (int i = 0; i < rows.size(); i++) {\n        table.removeRow(i);\n    }\n    for (int i = 0; i < row; i++) {\n        XWPFTableRow tabRow = (table.getRow(i) == null) ? table.createRow() : table.getRow(i);\n        for (int k = 0; k < col; k++) {\n            if (tabRow.getCell(k) == null) {\n                tabRow.createCell();\n            }\n        }\n    }\n    return table;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.NumberingContinue.of",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.processor.NumberingContinue.of" ],
    "fullMethods" : [ "public static NumberingContinue of(BodyContainer bodyContainer, int start, int end, IterableTemplate iterable) {\n    if ((start + 1) >= end)\n        return new NumberingContinue();\n\n    final List<IBodyElement> elements = bodyContainer.getBodyElements().subList(start + 1, end);\n    if (elements.isEmpty())\n        return new NumberingContinue();\n\n    CTNumPr first = null;\n    int firstPos = -1;\n    for (IBodyElement element : elements) {\n        if (element.getElementType() == BodyElementType.PARAGRAPH) {\n            XWPFParagraph paragraph = ((XWPFParagraph) (element));\n            CTP ctp = paragraph.getCTP();\n            if ((ctp.getPPr() != null) && (ctp.getPPr().getNumPr() != null)) {\n                CTNumPr numPr = ctp.getPPr().getNumPr();\n                // find first\n                if (null == first) {\n                    first = numPr;\n                    firstPos = bodyContainer.getPosOfParagraphCTP(ctp);\n                } else // first is not unique\n                if (Objects.equals(numPr.getIlvl().getVal(), first.getIlvl().getVal()) && Objects.equals(numPr.getNumId().getVal(), first.getNumId().getVal())) {\n                    first = null;\n                    break;\n                }\n            }\n        }\n    }\n    if (null == first)\n        return new NumberingContinue();\n\n    // the first is unique, if first inside other iterable section\n    List<MetaTemplate> templates = iterable.getTemplates();\n    for (MetaTemplate template : templates) {\n        if (template instanceof IterableTemplate) {\n            CTP startCtp = ((XWPFParagraph) (((IterableTemplate) (template)).getStartRun().getParent())).getCTP();\n            CTP endCtp = ((XWPFParagraph) (((IterableTemplate) (template)).getEndRun().getParent())).getCTP();\n            int startPos = bodyContainer.getPosOfParagraphCTP(startCtp);\n            if (startPos >= firstPos)\n                break;\n\n            int endPos = bodyContainer.getPosOfParagraphCTP(endCtp);\n            if ((firstPos > startPos) && (firstPos < endPos)) {\n                return new NumberingContinue();\n            }\n        }\n    }\n    return new NumberingContinue(first.getNumId().getVal());\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    try {\n        RunTemplate runTemplate = cast2runTemplate(eleTemplate);\n        XWPFRun run = runTemplate.getRun();\n        checkTargetIsTable(run, (\"Processing [\" + runTemplate.getTagName()) + \"] failed, the target content is not a table\");\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        final XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n        // \n        int position = getRowIndex(tagCell.getTableRow());\n        List<XWPFTableRow> tempRows = getAllTemplateRow(table, position);\n        if ((null != data) && (data instanceof Iterable)) {\n            // \n            final XWPFTableRow firstTempRow = tempRows.get(0);\n            Iterator<?> dataIt = ((Iterable<?>) (data)).iterator();\n            boolean hasNextData = dataIt.hasNext();\n            int index = 0;\n            while (hasNextData) {\n                Object dt = dataIt.next();\n                hasNextData = dataIt.hasNext();\n                Iterator<XWPFTableRow> rowTempIt = tempRows.iterator();\n                boolean hasNextTempRow = rowTempIt.hasNext();\n                while (hasNextTempRow) {\n                    XWPFTableRow tempRow = rowTempIt.next();\n                    hasNextTempRow = rowTempIt.hasNext();\n                    if (!table.addRow(tempRow, position)) {\n                        throw new RenderException(\"\");\n                    }\n                    // \n                    XmlCursor newCursor = firstTempRow.getCtRow().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    XWPFTableRow newRow = new XWPFTableRow(((CTRow) (object)), table);\n                    newRow.getCtRow().set(object);\n                    setTableRow(table, newRow, position);\n                    List<XWPFTableCell> cells = newRow.getTableCells();\n                    RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(dt, EnvIterator.makeEnv(index, hasNextData || hasNextTempRow)));\n                    cells.forEach(tableCell -> {\n                        List<MetaTemplate> metaTemplates = resolver.resolveBodyElements(tableCell.getBodyElements());\n                        new DocumentProcessor(template, resolver, dataCompute).process(metaTemplates);\n                    });\n                    ++position;\n                } \n                ++index;\n            } \n        }\n        removeTableRow(table, position, tempRows.size());\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-row template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.reference.DefaultPictureTemplateRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.reference.DefaultPictureTemplateRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(PictureTemplate pictureTemplate, PictureRenderData data, XWPFTemplate template) throws Exception {\n    XWPFPicture t = pictureTemplate.getPicture();\n    byte[] image = data.readPictureData();\n    PictureType pictureType = data.getPictureType();\n    if (null == pictureType) {\n        pictureType = PictureType.suggestFileType(image);\n    }\n    XWPFRun run = ((XWPFRun) (ReflectionUtils.getValue(\"run\", t)));\n    if (run.getParent().getPart() instanceof XWPFHeaderFooter) {\n        XWPFHeaderFooter headerFooter = ((XWPFHeaderFooter) (run.getParent().getPart()));\n        setPictureReference(t, headerFooter.addPictureData(image, pictureType.type()));\n    } else {\n        setPictureReference(t, template.getXWPFDocument().addPictureData(image, pictureType.type()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.template.IterableTemplate.buildIfInline",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.template.IterableTemplate.buildIfInline" ],
    "fullMethods" : [ "public IterableTemplate buildIfInline() {\n    XWPFRun startRun = startMark.getRun();\n    XWPFRun endRun = endMark.getRun();\n    if (startRun.getParent() == endRun.getParent()) {\n        InlineIterableTemplate instance = new InlineIterableTemplate(startMark);\n        instance.endMark = endMark;\n        instance.templates = templates;\n        return instance;\n    }\n    return this;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.RenderContext.getContainer",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.render.RenderContext.getContainer" ],
    "fullMethods" : [ "public IBody getContainer() {\n    // XWPFTableCellXWPFDocumentXWPFHeaderFooterXWPFAbstractFootnoteEndnote\n    return ((XWPFParagraph) (getRun().getParent())).getBody();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.ParagraphUtils.getRunPos",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.ParagraphUtils.getRunPos", "com.deepoove.poi.util.ParagraphUtils.getRunList" ],
    "fullMethods" : [ "public static Integer getRunPos(XWPFRun run) {\n    List<XWPFRun> runs = getRunList(run);\n    for (int i = 0; i < runs.size(); i++) {\n        if (run == runs.get(i)) {\n            return i;\n        }\n    }\n    return null;\n}", "private static List<XWPFRun> getRunList(XWPFRun run) {\n    IRunBody parent = run.getParent();\n    if (parent instanceof XWPFParagraph) {\n        XWPFParagraph paragraph = ((XWPFParagraph) (parent));\n        return paragraph.getRuns();\n    } else if (parent instanceof XWPFStructuredDocumentTagContent) {\n        XWPFStructuredDocumentTagContent paragraph = ((XWPFStructuredDocumentTagContent) (parent));\n        return paragraph.getRuns();\n    }\n    return new ArrayList<>();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        if ((null != data) && (data instanceof Iterable)) {\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            XWPFTableRow templateRow = table.getRow(templateRowIndex);\n            int insertPosition = templateRowIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            boolean firstFlag = true;\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateRowIndex++;\n                XWPFTableRow nextRow = table.insertNewTableRow(insertPosition);\n                setTableRow(table, templateRow, insertPosition);\n                // double set row\n                XmlCursor newCursor = templateRow.getCtRow().newCursor();\n                newCursor.toPrevSibling();\n                XmlObject object = newCursor.getObject();\n                nextRow = new XWPFTableRow(((CTRow) (object)), table);\n                if (!firstFlag) {\n                    // update VMerge cells for non-first row\n                    List<XWPFTableCell> tableCells = nextRow.getTableCells();\n                    for (XWPFTableCell cell : tableCells) {\n                        CTTcPr tcPr = TableTools.getTcPr(cell);\n                        CTVMerge vMerge = tcPr.getVMerge();\n                        if (null == vMerge)\n                            continue;\n\n                        if (STMerge.RESTART == vMerge.getVal()) {\n                            vMerge.setVal(STMerge.CONTINUE);\n                        }\n                    }\n                } else {\n                    firstFlag = false;\n                }\n                setTableRow(table, nextRow, insertPosition);\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                List<XWPFTableCell> cells = nextRow.getTableCells();\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        table.removeRow(templateRowIndex);\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \" error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getParent",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPBdr.isSetLeft",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPBdr.isSetLeft",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveParagraphStyle" ],
    "fullMethods" : [ "public static ParagraphStyle retriveParagraphStyle(XWPFParagraph paragraph) {\n    if (null == paragraph)\n        return null;\n\n    Builder builder = ParagraphStyle.builder();\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    if (paragraph.isWordWrapped()) {\n        builder.withAllowWordBreak(true);\n    }\n    if (pr.isSetPBdr()) {\n        CTPBdr ct = pr.getPBdr();\n        if (ct.isSetLeft()) {\n            builder.withLeftBorder(retriveBorderStyle(ct.getLeft()));\n        }\n        if (ct.isSetTop()) {\n            builder.withTopBorder(retriveBorderStyle(ct.getTop()));\n        }\n        if (ct.isSetRight()) {\n            builder.withRightBorder(retriveBorderStyle(ct.getRight()));\n        }\n        if (ct.isSetBottom()) {\n            builder.withBottomBorder(retriveBorderStyle(ct.getBottom()));\n        }\n    }\n    if (pr.isSetShd()) {\n        CTShd shd = pr.getShd();\n        builder.withShadingPattern(XWPFShadingPattern.valueOf(shd.getVal().intValue()));\n        if (shd.isSetFill())\n            builder.withBackgroundColor(shd.xgetFill().getStringValue());\n\n    }\n    builder.withAlign(paragraph.getAlignment());\n    int spacingBeforeLines = paragraph.getSpacingBeforeLines();\n    if ((-1) != spacingBeforeLines) {\n        builder.withSpacingBeforeLines(spacingBeforeLines / 100.0F);\n    }\n    int spacingAfterLines = paragraph.getSpacingAfterLines();\n    if ((-1) != spacingAfterLines) {\n        builder.withSpacingAfterLines(spacingAfterLines / 100.0F);\n    }\n    int spacingBefore = paragraph.getSpacingBefore();\n    if ((-1) != spacingBefore) {\n        builder.withSpacingBefore(UnitUtils.twips2Point(spacingBefore));\n    }\n    int spacingAfter = paragraph.getSpacingAfter();\n    if ((-1) != spacingAfter) {\n        builder.withSpacingAfter(UnitUtils.twips2Point(spacingAfter));\n    }\n    double spacingBetween = paragraph.getSpacingBetween();\n    if ((-1) != spacingBetween) {\n        builder.withSpacing(spacingBetween);\n        builder.withSpacingRule(paragraph.getSpacingLineRule());\n    }\n    return builder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleTableCell",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTc.isSetTcPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleTableCell" ],
    "fullMethods" : [ "/**\n * set cell style\n *\n * @param cell\n * @param cellStyle\n */\npublic static void styleTableCell(XWPFTableCell cell, CellStyle cellStyle) {\n    if ((null == cell) || (null == cellStyle))\n        return;\n\n    if (null != cellStyle.getVertAlign()) {\n        cell.setVerticalAlignment(cellStyle.getVertAlign());\n    }\n    if (null != cellStyle.getBackgroundColor()) {\n        CTTc ctTc = cell.getCTTc();\n        CTTcPr pr = (ctTc.isSetTcPr()) ? ctTc.getTcPr() : ctTc.addNewTcPr();\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = cellStyle.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(cellStyle.getBackgroundColor());\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.getTcPr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTc.isSetTcPr",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.getTcPr" ],
    "fullMethods" : [ "public static CTTcPr getTcPr(XWPFTableCell cell) {\n    CTTcPr tcPr = (cell.getCTTc().isSetTcPr()) ? cell.getCTTc().getTcPr() : cell.getCTTc().addNewTcPr();\n    return tcPr;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.compute.ReadMapAccessor.generateCode",
    "thirdPartyMethod" : "org.springframework.expression.spel.CodeFlow.loadTarget",
    "thirdPartyPackage" : "org.springframework.expression.spel",
    "path" : [ "com.deepoove.poi.render.compute.ReadMapAccessor.generateCode" ],
    "fullMethods" : [ "@Override\npublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n    String descriptor = cf.lastDescriptor();\n    if ((descriptor == null) || (!descriptor.equals(\"Ljava/util/Map\"))) {\n        if (descriptor == null) {\n            cf.loadTarget(mv);\n        }\n        CodeFlow.insertCheckCast(mv, \"Ljava/util/Map\");\n    }\n    mv.visitLdcInsn(propertyName);\n    mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", true);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.setVaryColors",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTOfPieChart.isSetVaryColors",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.setVaryColors" ],
    "fullMethods" : [ "@Override\npublic void setVaryColors(Boolean varyColors) {\n    if (varyColors == null) {\n        if (chart.isSetVaryColors()) {\n            chart.unsetVaryColors();\n        }\n    } else if (chart.isSetVaryColors()) {\n        chart.getVaryColors().setVal(varyColors);\n    } else {\n        chart.addNewVaryColors().setVal(varyColors);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTable",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.RemoveTableColumnRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        for (int i = rowSize - 1; i >= 0; i--) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            String text = row.getCell(actualInsertPosition).getText();\n            if (\"_delete_\".equals(text)) {\n                table.removeRow(i);\n            } else {\n                removeCell(row, actualInsertPosition);\n            }\n        }\n    } catch (Exception e) {\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTable",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException(((\"The template tag \" + runTemplate.getSource()) + \" must be inside a \") + \"table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTableRow tableRow = tagCell.getTableRow();\n        XWPFTable table = tableRow.getTable();\n        run.setText(\"\", 0);\n        int loopColumnNum = getLoopColumnNum(tagCell);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int rowSize = table.getRows().size();\n        int index = 0;\n        if (data instanceof Iterable) {\n            int dataSize = getSize(((Iterable<?>) (data)));\n            int[] loopColWidths = processLoopColWidth(table, tableRow, templateColIndex, dataSize, loopColumnNum);\n            int[] newCellInsertPoint4row = new int[rowSize];\n            XWPFTableCell[] cursorCell4row = new XWPFTableCell[rowSize];\n            boolean initFlag = true;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                List<XWPFTableCell> cells = new ArrayList<>();\n                int loopCellStartPoint = (index * loopColumnNum) + templateColIndex;\n                for (int j = 0; j < (loopColumnNum * 2); j += 2) {\n                    for (int i = 0; i < rowSize; i++) {\n                        XWPFTableRow row = table.getRow(i);\n                        int actualLoopCellPosition = getActualInsertPosition(row, loopCellStartPoint + j);\n                        if ((-1) == actualLoopCellPosition) {\n                            addColGridSpan(row, loopCellStartPoint + j);\n                            continue;\n                        }\n                        XWPFTableCell loopCell = row.getCell(actualLoopCellPosition);\n                        if (initFlag) {\n                            loopCell.setWidth(String.valueOf(loopColWidths[j / 2]));\n                            if (j == 0) {\n                                cursorCell4row[i] = loopCell;\n                                newCellInsertPoint4row[i] = actualLoopCellPosition;\n                            }\n                        }\n                        insertCell(row, newCellInsertPoint4row[i]);\n                        setTableCell(row, loopCell, newCellInsertPoint4row[i]);\n                        // double set row\n                        XmlCursor newCursor = cursorCell4row[i].getCTTc().newCursor();\n                        newCursor.toPrevSibling();\n                        XmlObject object = newCursor.getObject();\n                        XWPFTableCell nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (loopCell.getPart())));\n                        setTableCell(row, nextCell, newCellInsertPoint4row[i]++);\n                        cells.add(nextCell);\n                    }\n                }\n                initFlag = false;\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        int endPoint = ((index * loopColumnNum) + templateColIndex) - 1;\n        for (int j = loopColumnNum; j > 0; j--) {\n            for (int i = 0; i < rowSize; i++) {\n                XWPFTableRow row = table.getRow(i);\n                int actualInsertPosition = getActualInsertPosition(row, endPoint + j);\n                if ((-1) == actualInsertPosition) {\n                    minusGridSpan(row, endPoint + j);\n                    continue;\n                }\n                removeCell(row, actualInsertPosition);\n            }\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-column template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XWPFTableRowWrapper.getTableICells",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTable",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.xwpf.XWPFTableRowWrapper.getTableICells" ],
    "fullMethods" : [ "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic List<ICell> getTableICells() {\n    boolean haveSdt = false;\n    List<ICell> cells = new ArrayList<>();\n    XmlCursor cursor = row.getCtRow().newCursor();\n    try {\n        cursor.selectPath(\"./*\");\n        while (cursor.toNextSelection()) {\n            XmlObject o = cursor.getObject();\n            if (o instanceof CTTc) {\n                cells.add(new XWPFTableCell(((CTTc) (o)), row, row.getTable().getBody()));\n            } else if (o instanceof CTSdtCell) {\n                haveSdt = true;\n                cells.add(new XWPFStructuredDocumentTag(((CTSdtCell) (o)), row, row.getTable().getBody()));\n            }\n        } \n    } finally {\n        cursor.dispose();\n    }\n    return haveSdt ? cells : ((List) (row.getTableCells()));\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.policy.DynamicTableRenderPolicy.doRender",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTable",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.policy.DynamicTableRenderPolicy.doRender" ],
    "fullMethods" : [ "@Override\npublic void doRender(RenderContext<Object> context) throws Exception {\n    RunTemplate runTemplate = ((RunTemplate) (context.getEleTemplate()));\n    XWPFRun run = runTemplate.getRun();\n    run.setText(\"\", 0);\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell cell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = cell.getTableRow().getTable();\n        render(table, context.getData());\n    } catch (Exception e) {\n        throw new RenderException(\"Dynamic render table error:\" + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTable",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateColIndex = getTemplateColIndex(tagCell);\n        int actualColIndex = getActualInsertPosition(tagCell.getTableRow(), templateColIndex);\n        XWPFTableCell firstCell = tagCell.getTableRow().getCell(actualColIndex);\n        int width = firstCell.getWidth();\n        TableWidthType widthType = firstCell.getWidthType();\n        if ((TableWidthType.DXA != widthType) || (width == 0)) {\n            throw new IllegalArgumentException(\"template col must set width in centimeters.\");\n        }\n        int rowSize = table.getRows().size();\n        if ((null != data) && (data instanceof Iterable)) {\n            int colWidth = processLoopColWidth(table, width, templateColIndex, data);\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            int insertPosition = templateColIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateColIndex++;\n                List<XWPFTableCell> cells = new ArrayList<XWPFTableCell>();\n                for (int i = 0; i < rowSize; i++) {\n                    XWPFTableRow row = table.getRow(i);\n                    int actualInsertPosition = getActualInsertPosition(row, insertPosition);\n                    if ((-1) == actualInsertPosition) {\n                        addColGridSpan(row, insertPosition);\n                        continue;\n                    }\n                    XWPFTableCell templateCell = row.getCell(actualInsertPosition);\n                    templateCell.setWidth(colWidth + \"\");\n                    XWPFTableCell nextCell = insertCell(row, actualInsertPosition);\n                    setTableCell(row, templateCell, actualInsertPosition);\n                    // double set row\n                    XmlCursor newCursor = templateCell.getCTTc().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    nextCell = new XWPFTableCell(((CTTc) (object)), row, ((IBody) (nextCell.getPart())));\n                    setTableCell(row, nextCell, actualInsertPosition);\n                    cells.add(nextCell);\n                }\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        for (int i = 0; i < rowSize; i++) {\n            XWPFTableRow row = table.getRow(i);\n            int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n            if ((-1) == actualInsertPosition) {\n                minusGridSpan(row, templateColIndex);\n                continue;\n            }\n            removeCell(row, actualInsertPosition);\n        }\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTable",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.LoopRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        if ((null != data) && (data instanceof Iterable)) {\n            Iterator<?> iterator = ((Iterable<?>) (data)).iterator();\n            XWPFTableRow templateRow = table.getRow(templateRowIndex);\n            int insertPosition = templateRowIndex;\n            TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n            boolean firstFlag = true;\n            int index = 0;\n            boolean hasNext = iterator.hasNext();\n            while (hasNext) {\n                Object root = iterator.next();\n                hasNext = iterator.hasNext();\n                insertPosition = templateRowIndex++;\n                XWPFTableRow nextRow = table.insertNewTableRow(insertPosition);\n                setTableRow(table, templateRow, insertPosition);\n                // double set row\n                XmlCursor newCursor = templateRow.getCtRow().newCursor();\n                newCursor.toPrevSibling();\n                XmlObject object = newCursor.getObject();\n                nextRow = new XWPFTableRow(((CTRow) (object)), table);\n                if (!firstFlag) {\n                    // update VMerge cells for non-first row\n                    List<XWPFTableCell> tableCells = nextRow.getTableCells();\n                    for (XWPFTableCell cell : tableCells) {\n                        CTTcPr tcPr = TableTools.getTcPr(cell);\n                        CTVMerge vMerge = tcPr.getVMerge();\n                        if (null == vMerge)\n                            continue;\n\n                        if (STMerge.RESTART == vMerge.getVal()) {\n                            vMerge.setVal(STMerge.CONTINUE);\n                        }\n                    }\n                } else {\n                    firstFlag = false;\n                }\n                setTableRow(table, nextRow, insertPosition);\n                RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(root, EnvIterator.makeEnv(index++, hasNext)));\n                List<XWPFTableCell> cells = nextRow.getTableCells();\n                cells.forEach(cell -> {\n                    List<MetaTemplate> templates = resolver.resolveBodyElements(cell.getBodyElements());\n                    new DocumentProcessor(template, resolver, dataCompute).process(templates);\n                });\n            } \n        }\n        table.removeRow(templateRowIndex);\n        afterloop(table, data);\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \" error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTable",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.MultipleRowTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    try {\n        RunTemplate runTemplate = cast2runTemplate(eleTemplate);\n        XWPFRun run = runTemplate.getRun();\n        checkTargetIsTable(run, (\"Processing [\" + runTemplate.getTagName()) + \"] failed, the target content is not a table\");\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        final XWPFTable table = tagCell.getTableRow().getTable();\n        run.setText(\"\", 0);\n        TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix));\n        // \n        int position = getRowIndex(tagCell.getTableRow());\n        List<XWPFTableRow> tempRows = getAllTemplateRow(table, position);\n        if ((null != data) && (data instanceof Iterable)) {\n            // \n            final XWPFTableRow firstTempRow = tempRows.get(0);\n            Iterator<?> dataIt = ((Iterable<?>) (data)).iterator();\n            boolean hasNextData = dataIt.hasNext();\n            int index = 0;\n            while (hasNextData) {\n                Object dt = dataIt.next();\n                hasNextData = dataIt.hasNext();\n                Iterator<XWPFTableRow> rowTempIt = tempRows.iterator();\n                boolean hasNextTempRow = rowTempIt.hasNext();\n                while (hasNextTempRow) {\n                    XWPFTableRow tempRow = rowTempIt.next();\n                    hasNextTempRow = rowTempIt.hasNext();\n                    if (!table.addRow(tempRow, position)) {\n                        throw new RenderException(\"\");\n                    }\n                    // \n                    XmlCursor newCursor = firstTempRow.getCtRow().newCursor();\n                    newCursor.toPrevSibling();\n                    XmlObject object = newCursor.getObject();\n                    XWPFTableRow newRow = new XWPFTableRow(((CTRow) (object)), table);\n                    newRow.getCtRow().set(object);\n                    setTableRow(table, newRow, position);\n                    List<XWPFTableCell> cells = newRow.getTableCells();\n                    RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory().newCompute(EnvModel.of(dt, EnvIterator.makeEnv(index, hasNextData || hasNextTempRow)));\n                    cells.forEach(tableCell -> {\n                        List<MetaTemplate> metaTemplates = resolver.resolveBodyElements(tableCell.getBodyElements());\n                        new DocumentProcessor(template, resolver, dataCompute).process(metaTemplates);\n                    });\n                    ++position;\n                } \n                ++index;\n            } \n        }\n        removeTableRow(table, position, tempRows.size());\n    } catch (Exception e) {\n        throw new RenderException(\"failed to render table multi-row template\", e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFTableRow.getTable",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.plugin.table.SectionColumnTableRenderPolicy.render" ],
    "fullMethods" : [ "@Override\npublic void render(ElementTemplate eleTemplate, Object data, XWPFTemplate template) {\n    RunTemplate runTemplate = ((RunTemplate) (eleTemplate));\n    XWPFRun run = runTemplate.getRun();\n    try {\n        if (!TableTools.isInsideTable(run)) {\n            throw new IllegalStateException((\"The template tag \" + runTemplate.getSource()) + \" must be inside a table\");\n        }\n        XWPFTableCell tagCell = ((XWPFTableCell) (((XWPFParagraph) (run.getParent())).getBody()));\n        XWPFTable table = tagCell.getTableRow().getTable();\n        int templateRowIndex = getTemplateRowIndex(tagCell);\n        int templateColIndex = getColIndex(tagCell);\n        if ((null == data) || ((data instanceof Boolean) && (!((Boolean) (data))))) {\n            // table.removeRow(templateRowIndex);\n            // tagCell.setText(\"_delete_\");\n            run.setText(\"_delete_\", 0);\n            CTTcPr tcPr = TableTools.getTcPr(tagCell);\n            CTVMerge vMerge = tcPr.getVMerge();\n            System.out.println(null == vMerge ? null : vMerge.getVal());\n            if ((null != vMerge) && vMerge.getVal().equals(STMerge.RESTART)) {\n                XWPFTableRow row = table.getRow(templateRowIndex + 1);\n                int actualInsertPosition = getActualInsertPosition(row, templateColIndex);\n                XWPFTableCell actualCell = row.getCell(actualInsertPosition);\n                System.out.println(actualCell.getCTTc());\n                actualCell.getParagraphArray(0).createRun().setText(\"_delete_\", 0);\n            }\n        } else {\n            run.setText(\"\", 0);\n        }\n    } catch (Exception e) {\n        throw new RenderException(((\"HackLoopTable for \" + eleTemplate) + \"error: \") + e.getMessage(), e);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleParaRpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTParaRPr.sizeOfBArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleParaRpr", "com.deepoove.poi.util.StyleUtils.styleParaRpr" ],
    "fullMethods" : [ "public static void styleParaRpr(XWPFParagraph paragraph, Style style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    CTP ctp = paragraph.getCTP();\n    CTPPr pPr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTParaRPr pr = (pPr.isSetRPr()) ? pPr.getRPr() : pPr.addNewRPr();\n    StyleUtils.styleParaRpr(pr, style);\n}", "/**\n * set w:rPr style\n *\n * @param pr\n * @param style\n */\nprivate static void styleParaRpr(CTParaRPr pr, Style style) {\n    if ((null == pr) || (null == style))\n        return;\n\n    if (StringUtils.isNotBlank(style.getColor())) {\n        CTColor color = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        color.setVal(style.getColor());\n    }\n    if (null != style.isItalic()) {\n        CTOnOff italic = (pr.sizeOfIArray() > 0) ? pr.getIArray(0) : pr.addNewI();\n        italic.setVal(style.isItalic() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.isBold()) {\n        CTOnOff bold = (pr.sizeOfBArray() > 0) ? pr.getBArray(0) : pr.addNewB();\n        bold.setVal(style.isBold() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if ((0 != style.getFontSize()) && ((-1) != style.getFontSize())) {\n        BigDecimal bd = BigDecimal.valueOf(style.getFontSize());\n        CTHpsMeasure ctSize = (pr.sizeOfSzArray() > 0) ? pr.getSzArray(0) : pr.addNewSz();\n        ctSize.setVal(bd.multiply(BigDecimal.valueOf(2)).setScale(0, RoundingMode.HALF_UP).toBigInteger());\n    }\n    if (null != style.isStrike()) {\n        CTOnOff strike = (pr.sizeOfStrikeArray() > 0) ? pr.getStrikeArray(0) : pr.addNewStrike();\n        strike.setVal(style.isStrike() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        CTUnderline underline = (pr.sizeOfUArray() > 0) ? pr.getUArray(0) : pr.addNewU();\n        underline.setVal(STUnderline.Enum.forInt(underlinePatern.getValue()));\n        if (null != style.getUnderlineColor()) {\n            String color = style.getUnderlineColor();\n            SimpleValue svColor = null;\n            if (color.equals(\"auto\")) {\n                STHexColorAuto hexColor = STHexColorAuto.Factory.newInstance();\n                hexColor.setEnumValue(STHexColorAuto.Enum.forString(color));\n                svColor = ((SimpleValue) (hexColor));\n            } else {\n                STHexColorRGB rgbColor = STHexColorRGB.Factory.newInstance();\n                rgbColor.setStringValue(color);\n                svColor = ((SimpleValue) (rgbColor));\n            }\n            underline.setColor(svColor);\n        }\n    }\n    CTFonts fonts = (pr.sizeOfRFontsArray() > 0) ? pr.getRFontsArray(0) : pr.addNewRFonts();\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        fonts.setEastAsia(fontFamily);\n        fonts.setAscii(fontFamily);\n        fonts.setHAnsi(fontFamily);\n        fonts.setCs(fontFamily);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        fonts.setAscii(westernFontFamily);\n        fonts.setHAnsi(westernFontFamily);\n        fonts.setCs(westernFontFamily);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveBorderStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTBorder.xgetColor",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveBorderStyle" ],
    "fullMethods" : [ "public static BorderStyle retriveBorderStyle(CTBorder border) {\n    BorderStyle.Builder borderBuilder = BorderStyle.builder();\n    if (border.isSetColor())\n        borderBuilder.withColor(border.xgetColor().getStringValue());\n\n    if (border.isSetSz())\n        borderBuilder.withSize(border.getSz().intValue());\n\n    if (border.getVal() != null)\n        borderBuilder.withType(XWPFBorderType.valueOf(border.getVal().toString().toUpperCase()));\n\n    return borderBuilder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.TableTools.borderTable",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblBorders.addNewBottom",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.TableTools.borderTable" ],
    "fullMethods" : [ "public static void borderTable(XWPFTable table, int size) {\n    CTTblPr tblPr = getTblPr(table);\n    CTTblBorders tblBorders = tblPr.getTblBorders();\n    if (null == tblBorders) {\n        tblBorders = tblPr.addNewTblBorders();\n    }\n    BigInteger borderSize = BigInteger.valueOf(size);\n    if (!tblBorders.isSetBottom())\n        tblBorders.addNewBottom();\n\n    if (!tblBorders.isSetLeft())\n        tblBorders.addNewLeft();\n\n    if (!tblBorders.isSetTop())\n        tblBorders.addNewTop();\n\n    if (!tblBorders.isSetRight())\n        tblBorders.addNewRight();\n\n    if (!tblBorders.isSetInsideH())\n        tblBorders.addNewInsideH();\n\n    if (!tblBorders.isSetInsideV())\n        tblBorders.addNewInsideV();\n\n    tblBorders.getBottom().setSz(borderSize);\n    tblBorders.getLeft().setSz(borderSize);\n    tblBorders.getTop().setSz(borderSize);\n    tblBorders.getRight().setSz(borderSize);\n    tblBorders.getInsideH().setSz(borderSize);\n    tblBorders.getInsideV().setSz(borderSize);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.apache.poi.xwpf.usermodel.XWPFRun.getUnderlineColor",
    "thirdPartyPackage" : "org.apache.poi.xwpf.usermodel",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun" ],
    "fullMethods" : [ "/**\n * set run style by other run\n *\n * @param dest\n * @param src\n */\npublic static void styleRun(XWPFRun dest, XWPFRun src) {\n    if ((null == dest) || (null == src))\n        return;\n\n    if (StringUtils.isNotEmpty(src.getStyle()))\n        dest.setStyle(src.getStyle());\n\n    if (Boolean.TRUE.equals(src.isBold()))\n        dest.setBold(src.isBold());\n\n    if (StringUtils.isNotBlank(src.getColor()))\n        dest.setColor(src.getColor());\n\n    if (0 != src.getCharacterSpacing())\n        dest.setCharacterSpacing(src.getCharacterSpacing());\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.ascii)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.ascii);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.eastAsia)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.eastAsia);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.hAnsi)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.hAnsi);\n\n    if (StringUtils.isNotBlank(src.getFontFamily(FontCharRange.cs)))\n        dest.setFontFamily(src.getFontFamily(), FontCharRange.cs);\n\n    Double fontSize = src.getFontSizeAsDouble();\n    if (null != fontSize) {\n        dest.setFontSize(fontSize);\n    }\n    if (Boolean.TRUE.equals(src.isItalic()))\n        dest.setItalic(src.isItalic());\n\n    if (Boolean.TRUE.equals(src.isStrikeThrough()))\n        dest.setStrikeThrough(src.isStrikeThrough());\n\n    if (UnderlinePatterns.NONE != src.getUnderline())\n        dest.setUnderline(src.getUnderline());\n\n    if (null != src.getUnderlineColor())\n        dest.setUnderlineColor(src.getUnderlineColor());\n\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr.isSetWidowControl",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.retriveBorderStyle",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.STBorder.Enum.toString",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.STBorder",
    "path" : [ "com.deepoove.poi.util.StyleUtils.retriveBorderStyle" ],
    "fullMethods" : [ "public static BorderStyle retriveBorderStyle(CTBorder border) {\n    BorderStyle.Builder borderBuilder = BorderStyle.builder();\n    if (border.isSetColor())\n        borderBuilder.withColor(border.xgetColor().getStringValue());\n\n    if (border.isSetSz())\n        borderBuilder.withSize(border.getSz().intValue());\n\n    if (border.getVal() != null)\n        borderBuilder.withType(XWPFBorderType.valueOf(border.getVal().toString().toUpperCase()));\n\n    return borderBuilder.build();\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.render.processor.NumberingContinue.updateNumbering",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTAbstractNum.isSetTmpl",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.render.processor.NumberingContinue.updateNumbering" ],
    "fullMethods" : [ "public void updateNumbering(XWPFParagraph source, XWPFParagraph target) {\n    XWPFDocument document = source.getDocument();\n    XWPFNumbering numbering = document.getNumbering();\n    if (null == numbering)\n        return;\n\n    BigInteger numID = source.getNumID();\n    if (numID == null)\n        return;\n\n    if ((null != continueNumID) && numID.equals(continueNumID)) {\n        return;\n    }\n    if (consistCache.get(numID) != null) {\n        target.setNumID(consistCache.get(numID));\n        return;\n    }\n    XWPFNumberingWrapper wrapper = new XWPFNumberingWrapper(numbering);\n    XWPFNum num = numbering.getNum(numID);\n    if (null == num)\n        return;\n\n    XWPFAbstractNum abstractNum = numbering.getAbstractNum(num.getCTNum().getAbstractNumId().getVal());\n    CTAbstractNum ctAbstractNum = ((CTAbstractNum) (abstractNum.getAbstractNum().copy()));\n    ctAbstractNum.setAbstractNumId(wrapper.getNextAbstractNumID());\n    // clear continues list\n    // (related to tracking numbering definitions when documents are\n    // repurposed and\n    // changed\n    if (ctAbstractNum.isSetNsid())\n        ctAbstractNum.unsetNsid();\n\n    // related to where the definition can be displayed in the user\n    // interface\n    if (ctAbstractNum.isSetTmpl())\n        ctAbstractNum.unsetTmpl();\n\n    BigInteger abstractNumID = numbering.addAbstractNum(new XWPFAbstractNum(ctAbstractNum));\n    BigInteger newNumId = numbering.addNum(abstractNumID);\n    target.setNumID(newNumId);\n    consistCache.put(numID, newNumId);\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTAbstractNum.isSetTmpl",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.merge", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableStrings", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.createMergeableString", "com.deepoove.poi.xwpf.XmlXWPFDocumentMerge.mergeNumbering" ],
    "fullMethods" : [ "@Override\npublic NiceXWPFDocument merge(NiceXWPFDocument source, Iterator<NiceXWPFDocument> mergeIterator, XWPFRun run) throws Exception {\n    CTBody body = source.getDocument().getBody();\n    List<String> addParts = createMergeableStrings(source, mergeIterator);\n    String[] startEnd = truncatedStartEndXmlFragment(body);\n    XWPFParagraph paragraph = ((XWPFParagraph) (run.getParent()));\n    CTP mergedContainer = paragraph.getCTP();\n    CTP mergedBody = CTP.Factory.parse((((startEnd[0] + \"<w:POITL>\") + String.join(\"\", addParts)) + \"</w:POITL>\") + startEnd[1]);\n    // instead insert xml-fragment?\n    mergedContainer.set(mergedBody);\n    String xmlText = truncatedOverlapWP(body);\n    body.set(CTBody.Factory.parse(xmlText));\n    return source.generate(true);\n}", "protected List<String> createMergeableStrings(NiceXWPFDocument source, Iterator<NiceXWPFDocument> iterator) throws InvalidFormatException, IOException {\n    List<String> addParts = new ArrayList<String>();\n    if (!iterator.hasNext())\n        return addParts;\n\n    NiceXWPFDocument next = iterator.next();\n    // apply style merge once\n    Map<String, String> mergeStyles = mergeStyles(source, next);\n    // apply namespaces merge once\n    mergeNamespaces(source, next);\n    do {\n        addParts.add(createMergeableString(source, next, mergeStyles));\n        try {\n            next.close();\n        } catch (Exception e) {\n            logger.warn(\"close merged doc failed!\", e);\n        }\n        if (iterator.hasNext())\n            next = iterator.next();\n        else\n            break;\n\n    } while (true );\n    return addParts;\n}", "protected String createMergeableString(NiceXWPFDocument source, NiceXWPFDocument merged, Map<String, String> styleIdsMap) throws InvalidFormatException, IOException {\n    CTBody mergedBody = merged.getDocument().getBody();\n    // TODO For the same style, reduce the number of merges\n    // Map<String, String> styleIdsMap = mergeStyles(docMerge);\n    Map<String, String> numIdsMap = mergeNumbering(source, merged);\n    Map<String, String> blipIdsMap = mergePicture(source, merged);\n    Map<String, String> externalBlipIdsMap = mergeExternalPicture(source, merged);\n    Map<String, String> hyperlinkMap = mergeHyperlink(source, merged);\n    Map<String, String> chartIdsMap = mergeChart(source, merged);\n    Map<String, String> attachmentIdsMap = mergeAttachment(source, merged);\n    Map<String, String> footnoteIdsMap = mergeFootnote(source, merged);\n    Map<String, String> endnoteIdsMap = mergeEndnote(source, merged);\n    String appendString = mergedBody.xmlText(DefaultXmlOptions.OPTIONS_OUTER);\n    String addPart = ridSectPr(appendString);\n    // style\n    for (String styleId : styleIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:pStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:pStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:tblStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:tblStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\").replaceAll((\"<w:rStyle\\\\sw:val=\\\"\" + styleId) + \"\\\"\", (\"<w:rStyle w:val=\\\"\" + styleIdsMap.get(styleId)) + \"\\\"\");\n    }\n    // picture id\n    Map<String, String> placeHolderblipIdsMap = new HashMap<String, String>();\n    for (String relaId : blipIdsMap.keySet()) {\n        placeHolderblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:embed=\\\"\" + relaId) + \"\\\"\", (\"r:embed=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n        // w:pict v:shape v:imagedata\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + placeHolderblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    Map<String, String> placeHolderExternalblipIdsMap = new HashMap<String, String>();\n    for (String relaId : externalBlipIdsMap.keySet()) {\n        placeHolderExternalblipIdsMap.put(relaId, blipIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : placeHolderExternalblipIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:link=\\\"\" + relaId) + \"\\\"\", (\"r:link=\\\"\" + placeHolderExternalblipIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // hyperlink id\n    for (String relaId : hyperlinkMap.keySet()) {\n        hyperlinkMap.put(relaId, hyperlinkMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : hyperlinkMap.keySet()) {\n        // w:hyperlink r:id\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + hyperlinkMap.get(relaId)) + \"\\\"\");\n    }\n    // chart id\n    for (String relaId : chartIdsMap.keySet()) {\n        chartIdsMap.put(relaId, chartIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : chartIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + chartIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // attachment id\n    for (String relaId : attachmentIdsMap.keySet()) {\n        attachmentIdsMap.put(relaId, attachmentIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : attachmentIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"r:id=\\\"\" + relaId) + \"\\\"\", (\"r:id=\\\"\" + attachmentIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // footnote id\n    for (String relaId : footnoteIdsMap.keySet()) {\n        footnoteIdsMap.put(relaId, footnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : footnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"footnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"footnoteReference w:id=\\\"\" + footnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // endnote id\n    for (String relaId : endnoteIdsMap.keySet()) {\n        endnoteIdsMap.put(relaId, endnoteIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String relaId : endnoteIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"endnoteReference\\\\sw:id=\\\"\" + relaId) + \"\\\"\", (\"endnoteReference w:id=\\\"\" + endnoteIdsMap.get(relaId)) + \"\\\"\");\n    }\n    // numbering numId\n    for (String relaId : numIdsMap.keySet()) {\n        numIdsMap.put(relaId, numIdsMap.get(relaId) + CROSS_REPLACE_STRING);\n    }\n    for (String numId : numIdsMap.keySet()) {\n        addPart = addPart.replaceAll((\"<w:numId\\\\sw:val=\\\"\" + numId) + \"\\\"\", (\"<w:numId w:val=\\\"\" + numIdsMap.get(numId)) + \"\\\"\");\n    }\n    return addPart.replaceAll(CROSS_REPLACE_STRING, \"\");\n}", "protected Map<String, String> mergeNumbering(NiceXWPFDocument source, NiceXWPFDocument merged) {\n    Map<String, String> numIdsMap = new HashMap<String, String>();\n    XWPFNumbering numberingMerge = merged.getNumbering();\n    if (null == numberingMerge)\n        return numIdsMap;\n\n    XWPFNumberingWrapper wrapperMerge = new XWPFNumberingWrapper(numberingMerge);\n    List<XWPFNum> nums = wrapperMerge.getNums();\n    if (null == nums)\n        return numIdsMap;\n\n    XWPFNumbering numbering = source.getNumbering();\n    if (null == numbering)\n        numbering = source.createNumbering();\n\n    XWPFNumberingWrapper wrapper = new XWPFNumberingWrapper(numbering);\n    XWPFAbstractNum xwpfAbstractNum;\n    CTAbstractNum cTAbstractNum;\n    Map<BigInteger, CTAbstractNum> cache = new HashMap<BigInteger, CTAbstractNum>();\n    Map<BigInteger, CTAbstractNum> ret = new HashMap<BigInteger, CTAbstractNum>();\n    for (XWPFNum xwpfNum : nums) {\n        BigInteger mergeNumId = xwpfNum.getCTNum().getNumId();\n        cTAbstractNum = cache.get(xwpfNum.getCTNum().getAbstractNumId().getVal());\n        if (null == cTAbstractNum) {\n            xwpfAbstractNum = numberingMerge.getAbstractNum(xwpfNum.getCTNum().getAbstractNumId().getVal());\n            if (null == xwpfAbstractNum) {\n                logger.warn(\"cannot find cTAbstractNum by XWPFNum.\");\n                continue;\n            }\n            cTAbstractNum = xwpfAbstractNum.getCTAbstractNum();\n            // cTAbstractNum.setAbstractNumId(wrapper.getNextAbstractNumID());\n            if (cTAbstractNum.isSetNsid())\n                cTAbstractNum.unsetNsid();\n\n            if (cTAbstractNum.isSetTmpl())\n                cTAbstractNum.unsetTmpl();\n\n            cache.put(xwpfNum.getCTNum().getAbstractNumId().getVal(), cTAbstractNum);\n        }\n        ret.put(mergeNumId, cTAbstractNum);\n    }\n    long nextId = wrapper.getNextAbstractNumID().longValue();\n    Set<CTAbstractNum> hashSet = new HashSet<>(ret.values());\n    for (CTAbstractNum abnum : hashSet) {\n        abnum.setAbstractNumId(BigInteger.valueOf(nextId++));\n    }\n    final XWPFNumbering finalNumbering = numbering;\n    ret.forEach((mergeNumId, abnum) -> {\n        BigInteger numID = finalNumbering.addNum(finalNumbering.addAbstractNum(new XWPFAbstractNum(abnum)));\n        numIdsMap.put(mergeNumId.toString(), numID.toString());\n    });\n    return numIdsMap;\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.stylePpr",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTPPr.addNewShd",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.stylePpr" ],
    "fullMethods" : [ "public static void stylePpr(XWPFParagraph paragraph, ParagraphStyle style) {\n    if ((null == paragraph) || (null == style))\n        return;\n\n    if (null != style.getAlign()) {\n        paragraph.setAlignment(style.getAlign());\n    }\n    if (null != style.getSpacing()) {\n        paragraph.setSpacingBetween(style.getSpacing(), null == style.getSpacingRule() ? LineSpacingRule.AUTO : style.getSpacingRule());\n    }\n    if (null != style.getSpacingBeforeLines()) {\n        paragraph.setSpacingBeforeLines(new BigInteger(String.valueOf(Math.round(style.getSpacingBeforeLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingAfterLines()) {\n        paragraph.setSpacingAfterLines(new BigInteger(String.valueOf(Math.round(style.getSpacingAfterLines() * 100.0))).intValue());\n    }\n    if (null != style.getSpacingBefore()) {\n        paragraph.setSpacingBefore(UnitUtils.point2Twips(style.getSpacingBefore()));\n    }\n    if (null != style.getSpacingAfter()) {\n        paragraph.setSpacingAfter(UnitUtils.point2Twips(style.getSpacingAfter()));\n    }\n    CTP ctp = paragraph.getCTP();\n    CTPPr pr = (ctp.isSetPPr()) ? ctp.getPPr() : ctp.addNewPPr();\n    CTInd indent = (pr.isSetInd()) ? pr.getInd() : pr.addNewInd();\n    if (null != style.getIndentLeftChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentLeftChars() * 100.0)));\n        indent.setLeftChars(bi);\n        if (indent.isSetLeft())\n            indent.unsetLeft();\n\n    }\n    if (null != style.getIndentRightChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentRightChars() * 100.0)));\n        indent.setRightChars(bi);\n        if (indent.isSetRight())\n            indent.unsetRight();\n\n    }\n    if (null != style.getIndentHangingChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentHangingChars() * 100.0)));\n        indent.setHangingChars(bi);\n        if (indent.isSetHanging())\n            indent.unsetHanging();\n\n    }\n    if (null != style.getIndentFirstLineChars()) {\n        BigInteger bi = new BigInteger(String.valueOf(Math.round(style.getIndentFirstLineChars() * 100.0)));\n        indent.setFirstLineChars(bi);\n        if (indent.isSetFirstLine())\n            indent.unsetFirstLine();\n\n    }\n    CTPBdr ct = (pr.isSetPBdr()) ? pr.getPBdr() : pr.addNewPBdr();\n    if (null != style.getLeftBorder()) {\n        styleCTBorder(ct.isSetLeft() ? ct.getLeft() : ct.addNewLeft(), style.getLeftBorder());\n    }\n    if (null != style.getTopBorder()) {\n        styleCTBorder(ct.isSetTop() ? ct.getTop() : ct.addNewTop(), style.getTopBorder());\n    }\n    if (null != style.getRightBorder()) {\n        styleCTBorder(ct.isSetRight() ? ct.getRight() : ct.addNewRight(), style.getRightBorder());\n    }\n    if (null != style.getBottomBorder()) {\n        styleCTBorder(ct.isSetBottom() ? ct.getBottom() : ct.addNewBottom(), style.getBottomBorder());\n    }\n    if (null != style.getBackgroundColor()) {\n        CTShd shd = (pr.isSetShd()) ? pr.getShd() : pr.addNewShd();\n        XWPFShadingPattern shadingPattern = style.getShadingPattern();\n        if (null == shadingPattern) {\n            shd.setVal(STShd.CLEAR);\n        } else {\n            shd.setVal(STShd.Enum.forInt(shadingPattern.getValue()));\n        }\n        shd.setColor(\"auto\");\n        shd.setFill(style.getBackgroundColor());\n    }\n    if (null != style.getStyleId()) {\n        paragraph.setStyle(style.getStyleId());\n    }\n    if (null != style.getKeepLines()) {\n        CTOnOff ctKeepLines = (pr.isSetKeepLines()) ? pr.getKeepLines() : pr.addNewKeepLines();\n        ctKeepLines.setVal(style.getKeepLines() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getKeepNext()) {\n        paragraph.setKeepNext(style.getKeepNext());\n    }\n    if (null != style.getPageBreakBefore()) {\n        paragraph.setPageBreak(style.getPageBreakBefore());\n    }\n    if (null != style.getWidowControl()) {\n        CTOnOff ctWC = (pr.isSetWidowControl()) ? pr.getWidowControl() : pr.addNewWidowControl();\n        ctWC.setVal(style.getWidowControl() ? XWPFOnOff.ON : XWPFOnOff.OFF);\n    }\n    if (null != style.getAllowWordBreak()) {\n        // paragraph.setWordWrapped(style.getWordWrap());\n        CTOnOff ctWW = (pr.isSetWordWrap()) ? pr.getWordWrap() : pr.addNewWordWrap();\n        ctWW.setVal(style.getAllowWordBreak() ? XWPFOnOff.OFF : XWPFOnOff.ON);\n    }\n    if (null != style.getNumId()) {\n        paragraph.setNumID(BigInteger.valueOf(style.getNumId()));\n    }\n    if (null != style.getLvl()) {\n        paragraph.setNumILvl(BigInteger.valueOf(style.getLvl()));\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.util.StyleUtils.styleRun",
    "thirdPartyMethod" : "org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRPr.sizeOfHighlightArray",
    "thirdPartyPackage" : "org.openxmlformats.schemas.wordprocessingml.x2006.main",
    "path" : [ "com.deepoove.poi.util.StyleUtils.styleRun" ],
    "fullMethods" : [ "/**\n * set run style by style\n *\n * @param run\n * @param style\n */\npublic static void styleRun(XWPFRun run, Style style) {\n    if ((null == run) || (null == style))\n        return;\n\n    CTRPr pr = getRunProperties(run);\n    String color = style.getColor();\n    if (StringUtils.isNotBlank(color)) {\n        // run.setColor(color);\n        // issue 326\n        CTColor ctColor = (pr.sizeOfColorArray() > 0) ? pr.getColorArray(0) : pr.addNewColor();\n        ctColor.setVal(color);\n        if (ctColor.isSetThemeColor())\n            ctColor.unsetThemeColor();\n\n    }\n    double fontSize = style.getFontSize();\n    if ((0 != fontSize) && ((-1) != fontSize)) {\n        run.setFontSize(fontSize);\n    }\n    String fontFamily = style.getFontFamily();\n    if (StringUtils.isNotBlank(fontFamily)) {\n        run.setFontFamily(fontFamily, FontCharRange.eastAsia);\n        run.setFontFamily(fontFamily, FontCharRange.ascii);\n        run.setFontFamily(fontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(fontFamily, FontCharRange.cs);\n    }\n    String westernFontFamily = style.getWesternFontFamily();\n    if (StringUtils.isNotBlank(westernFontFamily)) {\n        run.setFontFamily(westernFontFamily, FontCharRange.ascii);\n        run.setFontFamily(westernFontFamily, FontCharRange.hAnsi);\n        run.setFontFamily(westernFontFamily, FontCharRange.cs);\n    }\n    XWPFHighlightColor highlightColor = style.getHighlightColor();\n    if (null != highlightColor) {\n        CTHighlight highlight = (pr.sizeOfHighlightArray() > 0) ? pr.getHighlightArray(0) : pr.addNewHighlight();\n        highlight.setVal(STHighlightColor.Enum.forInt(highlightColor.getValue()));\n    }\n    Boolean bold = style.isBold();\n    if (null != bold)\n        run.setBold(bold);\n\n    Boolean italic = style.isItalic();\n    if (null != italic)\n        run.setItalic(italic);\n\n    Boolean strike = style.isStrike();\n    if (null != strike)\n        run.setStrikeThrough(strike);\n\n    UnderlinePatterns underlinePatern = style.getUnderlinePatterns();\n    if (null != underlinePatern) {\n        run.setUnderline(underlinePatern);\n        if (null != style.getUnderlineColor()) {\n            run.setUnderlineColor(style.getUnderlineColor());\n        }\n    }\n    int point = style.getCharacterSpacing();\n    // in twentieths of a point\n    if ((0 != point) && ((-1) != point))\n        run.setCharacterSpacing(UnitUtils.point2Twips(point));\n\n    String vertAlign = style.getVertAlign();\n    if (StringUtils.isNotBlank(vertAlign)) {\n        run.setVerticalAlignment(vertAlign);\n    }\n}" ]
  }, {
    "entryPoint" : "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShowLeaderLines",
    "thirdPartyMethod" : "org.openxmlformats.schemas.drawingml.x2006.chart.CTDLbls.getShowLeaderLines",
    "thirdPartyPackage" : "org.openxmlformats.schemas.drawingml.x2006.chart",
    "path" : [ "com.deepoove.poi.xwpf.XDDFOfPieChartData.Series.setShowLeaderLines" ],
    "fullMethods" : [ "@Override\npublic void setShowLeaderLines(boolean showLeaderLines) {\n    if (!series.isSetDLbls()) {\n        series.addNewDLbls();\n    }\n    if (series.getDLbls().isSetShowLeaderLines()) {\n        series.getDLbls().getShowLeaderLines().setVal(showLeaderLines);\n    } else {\n        series.getDLbls().addNewShowLeaderLines().setVal(showLeaderLines);\n    }\n}" ]
  } ]
}