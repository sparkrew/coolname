{
  "entryPointPaths" : [ {
    "entryPoint" : "org.apache.tika.config.TikaActivator.removedService",
    "entryPointBody" : "public void removedService(ServiceReference reference, Object service) {\n    ServiceLoader.removeService(reference);\n    bundleContext.ungetService(reference);\n}",
    "thirdPartyMethod" : "org.osgi.framework.BundleContext.ungetService",
    "thirdPartyPackage" : "org.osgi.framework",
    "path" : [ "org.apache.tika.config.TikaActivator.removedService" ]
  }, {
    "entryPoint" : "org.apache.tika.detect.XmlRootExtractor.extractRootElement",
    "entryPointBody" : "public QName extractRootElement(byte[] data) {\n    // this loop should be very rare\n    while (true) {\n        try {\n            return extractRootElement(new UnsynchronizedByteArrayInputStream(data), true);\n        } catch (MalformedCharException e) {\n            // see TIKA-3596, try to handle truncated/bad encoded XML files\n            int newLen = data.length / 2;\n            if ((newLen % 2) == 1) {\n                newLen--;\n            }\n            if (newLen > 0) {\n                data = Arrays.copyOf(data, newLen);\n            } else {\n                break;\n            }\n        }\n    } \n    return null;\n}",
    "thirdPartyMethod" : "org.apache.commons.io.input.UnsynchronizedByteArrayInputStream.<init>",
    "thirdPartyPackage" : "org.apache.commons.io.input",
    "path" : [ "org.apache.tika.detect.XmlRootExtractor.extractRootElement" ]
  }, {
    "entryPoint" : "org.apache.tika.mime.MimeTypesReader.resolveEntity",
    "entryPointBody" : "@Override\npublic InputSource resolveEntity(String publicId, String systemId) {\n    return new InputSource(new UnsynchronizedByteArrayInputStream(new byte[0]));\n}",
    "thirdPartyMethod" : "org.apache.commons.io.input.UnsynchronizedByteArrayInputStream.<init>",
    "thirdPartyPackage" : "org.apache.commons.io.input",
    "path" : [ "org.apache.tika.mime.MimeTypesReader.resolveEntity" ]
  }, {
    "entryPoint" : "org.apache.tika.io.TikaInputStream.get",
    "entryPointBody" : "/**\n * Creates a TikaInputStream from the given array of bytes. The length of\n * the array is stored as input metadata in the given metadata instance.\n * <p>\n * Note that you must always explicitly close the returned stream as in\n * some cases it may end up writing the given data to a temporary file.\n *\n * @param data\n * \t\tinput data\n * @param metadata\n * \t\tmetadata instance\n * @return a TikaInputStream instance\n */\npublic static TikaInputStream get(byte[] data, Metadata metadata) {\n    metadata.set(Metadata.CONTENT_LENGTH, Integer.toString(data.length));\n    return new TikaInputStream(new UnsynchronizedByteArrayInputStream(data), new TemporaryResources(), data.length, getExtension(metadata));\n}",
    "thirdPartyMethod" : "org.apache.commons.io.input.UnsynchronizedByteArrayInputStream.<init>",
    "thirdPartyPackage" : "org.apache.commons.io.input",
    "path" : [ "org.apache.tika.io.TikaInputStream.get" ]
  }, {
    "entryPoint" : "org.apache.tika.embedder.ExternalEmbedder.embed",
    "entryPointBody" : "/**\n * Executes the configured external command and passes the given document\n * stream as a simple XHTML document to the given SAX content handler.\n * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}\n * has been called to set arguments.\n */\n@Override\npublic void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {\n    boolean inputToStdIn = true;\n    boolean outputFromStdOut = true;\n    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());\n    boolean serializeMetadataCommandArgumentsToken = false;\n    boolean replacedMetadataCommandArgumentsToken = false;\n    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);\n    File tempOutputFile = null;\n    List<String> commandMetadataSegments = null;\n    if (hasMetadataCommandArguments) {\n        commandMetadataSegments = getCommandMetadataSegments(metadata);\n    }\n    // Build our command\n    String[] origCmd = command;\n    List<String> cmd = new ArrayList<>();\n    for (String commandSegment : origCmd) {\n        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {\n            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());\n            inputToStdIn = false;\n        }\n        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {\n            tempOutputFile = tmp.createTemporaryFile();\n            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());\n            outputFromStdOut = false;\n        }\n        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {\n            serializeMetadataCommandArgumentsToken = true;\n        }\n        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {\n            if (hasMetadataCommandArguments) {\n                cmd.addAll(commandMetadataSegments);\n            }\n            replacedMetadataCommandArgumentsToken = true;\n        } else {\n            cmd.add(commandSegment);\n        }\n    }\n    if (hasMetadataCommandArguments) {\n        if (serializeMetadataCommandArgumentsToken) {\n            // Find all metadata tokens and replace with encapsulated metadata\n            int i = 0;\n            for (String commandSegment : cmd) {\n                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {\n                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));\n                    cmd.set(i, commandSegment);\n                }\n                i++;\n            }\n        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {\n            // Tack metadata onto the end of the cmd as arguments\n            cmd.addAll(commandMetadataSegments);\n        }\n    }\n    // Execute\n    Process process;\n    if (cmd.toArray().length == 1) {\n        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);\n    } else {\n        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));\n    }\n    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();\n    try {\n        sendStdErrToOutputStream(process, stdErrOutputStream);\n        if (inputToStdIn) {\n            sendInputStreamToStdIn(inputStream, process);\n        } else {\n            // We're not writing to std in this case so close\n            process.getOutputStream().close();\n        }\n        if (outputFromStdOut) {\n            sendStdOutToOutputStream(process, outputStream);\n        } else {\n            tmp.dispose();\n            try {\n                process.waitFor();\n            } catch (InterruptedException ignore) {\n            }\n            // The command is finished, read the output file into the given output stream\n            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());\n            IOUtils.copy(tempOutputFileInputStream, outputStream);\n        }\n    } finally {\n        if (outputFromStdOut) {\n            try {\n                process.waitFor();\n            } catch (InterruptedException ignore) {\n            }\n        } else {\n            try {\n                // Clean up temp output files\n                tempOutputFile.delete();\n            } catch (Exception e) {\n                // swallow\n            }\n        }\n        if (!inputToStdIn) {\n            // Close input file (and delete if created by up\n            // TemporaryResources.createTemporaryFile)\n            IOUtils.closeQuietly(tikaInputStream);\n        }\n        IOUtils.closeQuietly(outputStream);\n        IOUtils.closeQuietly(stdErrOutputStream);\n        if (process.exitValue() != 0) {\n            throw new TikaException((((\"There was an error executing the command line\" + \"\\nExecutable Command:\\n\\n\") + cmd) + \"\\nExecutable Error:\\n\\n\") + stdErrOutputStream.toString(UTF_8.name()));\n        }\n    }\n}",
    "thirdPartyMethod" : "org.apache.commons.io.IOUtils.closeQuietly",
    "thirdPartyPackage" : "org.apache.commons.io",
    "path" : [ "org.apache.tika.embedder.ExternalEmbedder.embed" ]
  }, {
    "entryPoint" : "org.apache.tika.embedder.ExternalEmbedder.embed",
    "entryPointBody" : "/**\n * Executes the configured external command and passes the given document\n * stream as a simple XHTML document to the given SAX content handler.\n * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}\n * has been called to set arguments.\n */\n@Override\npublic void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {\n    boolean inputToStdIn = true;\n    boolean outputFromStdOut = true;\n    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());\n    boolean serializeMetadataCommandArgumentsToken = false;\n    boolean replacedMetadataCommandArgumentsToken = false;\n    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);\n    File tempOutputFile = null;\n    List<String> commandMetadataSegments = null;\n    if (hasMetadataCommandArguments) {\n        commandMetadataSegments = getCommandMetadataSegments(metadata);\n    }\n    // Build our command\n    String[] origCmd = command;\n    List<String> cmd = new ArrayList<>();\n    for (String commandSegment : origCmd) {\n        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {\n            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());\n            inputToStdIn = false;\n        }\n        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {\n            tempOutputFile = tmp.createTemporaryFile();\n            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());\n            outputFromStdOut = false;\n        }\n        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {\n            serializeMetadataCommandArgumentsToken = true;\n        }\n        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {\n            if (hasMetadataCommandArguments) {\n                cmd.addAll(commandMetadataSegments);\n            }\n            replacedMetadataCommandArgumentsToken = true;\n        } else {\n            cmd.add(commandSegment);\n        }\n    }\n    if (hasMetadataCommandArguments) {\n        if (serializeMetadataCommandArgumentsToken) {\n            // Find all metadata tokens and replace with encapsulated metadata\n            int i = 0;\n            for (String commandSegment : cmd) {\n                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {\n                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));\n                    cmd.set(i, commandSegment);\n                }\n                i++;\n            }\n        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {\n            // Tack metadata onto the end of the cmd as arguments\n            cmd.addAll(commandMetadataSegments);\n        }\n    }\n    // Execute\n    Process process;\n    if (cmd.toArray().length == 1) {\n        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);\n    } else {\n        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));\n    }\n    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();\n    try {\n        sendStdErrToOutputStream(process, stdErrOutputStream);\n        if (inputToStdIn) {\n            sendInputStreamToStdIn(inputStream, process);\n        } else {\n            // We're not writing to std in this case so close\n            process.getOutputStream().close();\n        }\n        if (outputFromStdOut) {\n            sendStdOutToOutputStream(process, outputStream);\n        } else {\n            tmp.dispose();\n            try {\n                process.waitFor();\n            } catch (InterruptedException ignore) {\n            }\n            // The command is finished, read the output file into the given output stream\n            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());\n            IOUtils.copy(tempOutputFileInputStream, outputStream);\n        }\n    } finally {\n        if (outputFromStdOut) {\n            try {\n                process.waitFor();\n            } catch (InterruptedException ignore) {\n            }\n        } else {\n            try {\n                // Clean up temp output files\n                tempOutputFile.delete();\n            } catch (Exception e) {\n                // swallow\n            }\n        }\n        if (!inputToStdIn) {\n            // Close input file (and delete if created by up\n            // TemporaryResources.createTemporaryFile)\n            IOUtils.closeQuietly(tikaInputStream);\n        }\n        IOUtils.closeQuietly(outputStream);\n        IOUtils.closeQuietly(stdErrOutputStream);\n        if (process.exitValue() != 0) {\n            throw new TikaException((((\"There was an error executing the command line\" + \"\\nExecutable Command:\\n\\n\") + cmd) + \"\\nExecutable Error:\\n\\n\") + stdErrOutputStream.toString(UTF_8.name()));\n        }\n    }\n}",
    "thirdPartyMethod" : "org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder.get",
    "thirdPartyPackage" : "org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream",
    "path" : [ "org.apache.tika.embedder.ExternalEmbedder.embed" ]
  }, {
    "entryPoint" : "org.apache.tika.config.TikaActivator.addingService",
    "entryPointBody" : "public Object addingService(ServiceReference reference) {\n    int rank = 0;\n    Object property = reference.getProperty(Constants.SERVICE_RANKING);\n    if (property instanceof Integer) {\n        rank = ((Integer) (property));\n    }\n    Object service = bundleContext.getService(reference);\n    ServiceLoader.addService(reference, service, rank);\n    return service;\n}",
    "thirdPartyMethod" : "org.osgi.framework.BundleContext.getService",
    "thirdPartyPackage" : "org.osgi.framework",
    "path" : [ "org.apache.tika.config.TikaActivator.addingService" ]
  }, {
    "entryPoint" : "org.apache.tika.embedder.ExternalEmbedder.embed",
    "entryPointBody" : "/**\n * Executes the configured external command and passes the given document\n * stream as a simple XHTML document to the given SAX content handler.\n * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}\n * has been called to set arguments.\n */\n@Override\npublic void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {\n    boolean inputToStdIn = true;\n    boolean outputFromStdOut = true;\n    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());\n    boolean serializeMetadataCommandArgumentsToken = false;\n    boolean replacedMetadataCommandArgumentsToken = false;\n    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);\n    File tempOutputFile = null;\n    List<String> commandMetadataSegments = null;\n    if (hasMetadataCommandArguments) {\n        commandMetadataSegments = getCommandMetadataSegments(metadata);\n    }\n    // Build our command\n    String[] origCmd = command;\n    List<String> cmd = new ArrayList<>();\n    for (String commandSegment : origCmd) {\n        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {\n            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());\n            inputToStdIn = false;\n        }\n        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {\n            tempOutputFile = tmp.createTemporaryFile();\n            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());\n            outputFromStdOut = false;\n        }\n        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {\n            serializeMetadataCommandArgumentsToken = true;\n        }\n        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {\n            if (hasMetadataCommandArguments) {\n                cmd.addAll(commandMetadataSegments);\n            }\n            replacedMetadataCommandArgumentsToken = true;\n        } else {\n            cmd.add(commandSegment);\n        }\n    }\n    if (hasMetadataCommandArguments) {\n        if (serializeMetadataCommandArgumentsToken) {\n            // Find all metadata tokens and replace with encapsulated metadata\n            int i = 0;\n            for (String commandSegment : cmd) {\n                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {\n                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));\n                    cmd.set(i, commandSegment);\n                }\n                i++;\n            }\n        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {\n            // Tack metadata onto the end of the cmd as arguments\n            cmd.addAll(commandMetadataSegments);\n        }\n    }\n    // Execute\n    Process process;\n    if (cmd.toArray().length == 1) {\n        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);\n    } else {\n        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));\n    }\n    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();\n    try {\n        sendStdErrToOutputStream(process, stdErrOutputStream);\n        if (inputToStdIn) {\n            sendInputStreamToStdIn(inputStream, process);\n        } else {\n            // We're not writing to std in this case so close\n            process.getOutputStream().close();\n        }\n        if (outputFromStdOut) {\n            sendStdOutToOutputStream(process, outputStream);\n        } else {\n            tmp.dispose();\n            try {\n                process.waitFor();\n            } catch (InterruptedException ignore) {\n            }\n            // The command is finished, read the output file into the given output stream\n            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());\n            IOUtils.copy(tempOutputFileInputStream, outputStream);\n        }\n    } finally {\n        if (outputFromStdOut) {\n            try {\n                process.waitFor();\n            } catch (InterruptedException ignore) {\n            }\n        } else {\n            try {\n                // Clean up temp output files\n                tempOutputFile.delete();\n            } catch (Exception e) {\n                // swallow\n            }\n        }\n        if (!inputToStdIn) {\n            // Close input file (and delete if created by up\n            // TemporaryResources.createTemporaryFile)\n            IOUtils.closeQuietly(tikaInputStream);\n        }\n        IOUtils.closeQuietly(outputStream);\n        IOUtils.closeQuietly(stdErrOutputStream);\n        if (process.exitValue() != 0) {\n            throw new TikaException((((\"There was an error executing the command line\" + \"\\nExecutable Command:\\n\\n\") + cmd) + \"\\nExecutable Error:\\n\\n\") + stdErrOutputStream.toString(UTF_8.name()));\n        }\n    }\n}",
    "thirdPartyMethod" : "org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.builder",
    "thirdPartyPackage" : "org.apache.commons.io.output",
    "path" : [ "org.apache.tika.embedder.ExternalEmbedder.embed" ]
  }, {
    "entryPoint" : "org.apache.tika.embedder.ExternalEmbedder.embed",
    "entryPointBody" : "/**\n * Executes the configured external command and passes the given document\n * stream as a simple XHTML document to the given SAX content handler.\n * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}\n * has been called to set arguments.\n */\n@Override\npublic void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {\n    boolean inputToStdIn = true;\n    boolean outputFromStdOut = true;\n    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());\n    boolean serializeMetadataCommandArgumentsToken = false;\n    boolean replacedMetadataCommandArgumentsToken = false;\n    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);\n    File tempOutputFile = null;\n    List<String> commandMetadataSegments = null;\n    if (hasMetadataCommandArguments) {\n        commandMetadataSegments = getCommandMetadataSegments(metadata);\n    }\n    // Build our command\n    String[] origCmd = command;\n    List<String> cmd = new ArrayList<>();\n    for (String commandSegment : origCmd) {\n        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {\n            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());\n            inputToStdIn = false;\n        }\n        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {\n            tempOutputFile = tmp.createTemporaryFile();\n            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());\n            outputFromStdOut = false;\n        }\n        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {\n            serializeMetadataCommandArgumentsToken = true;\n        }\n        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {\n            if (hasMetadataCommandArguments) {\n                cmd.addAll(commandMetadataSegments);\n            }\n            replacedMetadataCommandArgumentsToken = true;\n        } else {\n            cmd.add(commandSegment);\n        }\n    }\n    if (hasMetadataCommandArguments) {\n        if (serializeMetadataCommandArgumentsToken) {\n            // Find all metadata tokens and replace with encapsulated metadata\n            int i = 0;\n            for (String commandSegment : cmd) {\n                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {\n                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));\n                    cmd.set(i, commandSegment);\n                }\n                i++;\n            }\n        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {\n            // Tack metadata onto the end of the cmd as arguments\n            cmd.addAll(commandMetadataSegments);\n        }\n    }\n    // Execute\n    Process process;\n    if (cmd.toArray().length == 1) {\n        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);\n    } else {\n        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));\n    }\n    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();\n    try {\n        sendStdErrToOutputStream(process, stdErrOutputStream);\n        if (inputToStdIn) {\n            sendInputStreamToStdIn(inputStream, process);\n        } else {\n            // We're not writing to std in this case so close\n            process.getOutputStream().close();\n        }\n        if (outputFromStdOut) {\n            sendStdOutToOutputStream(process, outputStream);\n        } else {\n            tmp.dispose();\n            try {\n                process.waitFor();\n            } catch (InterruptedException ignore) {\n            }\n            // The command is finished, read the output file into the given output stream\n            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());\n            IOUtils.copy(tempOutputFileInputStream, outputStream);\n        }\n    } finally {\n        if (outputFromStdOut) {\n            try {\n                process.waitFor();\n            } catch (InterruptedException ignore) {\n            }\n        } else {\n            try {\n                // Clean up temp output files\n                tempOutputFile.delete();\n            } catch (Exception e) {\n                // swallow\n            }\n        }\n        if (!inputToStdIn) {\n            // Close input file (and delete if created by up\n            // TemporaryResources.createTemporaryFile)\n            IOUtils.closeQuietly(tikaInputStream);\n        }\n        IOUtils.closeQuietly(outputStream);\n        IOUtils.closeQuietly(stdErrOutputStream);\n        if (process.exitValue() != 0) {\n            throw new TikaException((((\"There was an error executing the command line\" + \"\\nExecutable Command:\\n\\n\") + cmd) + \"\\nExecutable Error:\\n\\n\") + stdErrOutputStream.toString(UTF_8.name()));\n        }\n    }\n}",
    "thirdPartyMethod" : "org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.toString",
    "thirdPartyPackage" : "org.apache.commons.io.output",
    "path" : [ "org.apache.tika.embedder.ExternalEmbedder.embed" ]
  }, {
    "entryPoint" : "org.apache.tika.config.TikaActivator.addingService",
    "entryPointBody" : "public Object addingService(ServiceReference reference) {\n    int rank = 0;\n    Object property = reference.getProperty(Constants.SERVICE_RANKING);\n    if (property instanceof Integer) {\n        rank = ((Integer) (property));\n    }\n    Object service = bundleContext.getService(reference);\n    ServiceLoader.addService(reference, service, rank);\n    return service;\n}",
    "thirdPartyMethod" : "org.osgi.framework.ServiceReference.getProperty",
    "thirdPartyPackage" : "org.osgi.framework",
    "path" : [ "org.apache.tika.config.TikaActivator.addingService" ]
  }, {
    "entryPoint" : "org.apache.tika.config.TikaActivator.stop",
    "entryPointBody" : "public void stop(BundleContext context) throws Exception {\n    parserTracker.close();\n    detectorTracker.close();\n}",
    "thirdPartyMethod" : "org.osgi.util.tracker.ServiceTracker.close",
    "thirdPartyPackage" : "org.osgi.util.tracker",
    "path" : [ "org.apache.tika.config.TikaActivator.stop" ]
  }, {
    "entryPoint" : "org.apache.tika.detect.XmlRootExtractor.extractRootElement",
    "entryPointBody" : "public QName extractRootElement(byte[] data) {\n    // this loop should be very rare\n    while (true) {\n        try {\n            return extractRootElement(new UnsynchronizedByteArrayInputStream(data), true);\n        } catch (MalformedCharException e) {\n            // see TIKA-3596, try to handle truncated/bad encoded XML files\n            int newLen = data.length / 2;\n            if ((newLen % 2) == 1) {\n                newLen--;\n            }\n            if (newLen > 0) {\n                data = Arrays.copyOf(data, newLen);\n            } else {\n                break;\n            }\n        }\n    } \n    return null;\n}",
    "thirdPartyMethod" : "org.apache.commons.io.input.CloseShieldInputStream.wrap",
    "thirdPartyPackage" : "org.apache.commons.io.input",
    "path" : [ "org.apache.tika.detect.XmlRootExtractor.extractRootElement", "org.apache.tika.detect.XmlRootExtractor.extractRootElement" ]
  }, {
    "entryPoint" : "org.apache.tika.detect.XmlRootExtractor.extractRootElement",
    "entryPointBody" : "/**\n *\n * @since Apache Tika 0.9\n */\npublic QName extractRootElement(InputStream stream) {\n    return extractRootElement(stream, false);\n}",
    "thirdPartyMethod" : "org.apache.commons.io.input.CloseShieldInputStream.wrap",
    "thirdPartyPackage" : "org.apache.commons.io.input",
    "path" : [ "org.apache.tika.detect.XmlRootExtractor.extractRootElement", "org.apache.tika.detect.XmlRootExtractor.extractRootElement" ]
  }, {
    "entryPoint" : "org.apache.tika.parser.RecursiveParserWrapper.EmbeddedParserDecorator.parse",
    "entryPointBody" : "@Override\npublic void parse(InputStream stream, ContentHandler ignore, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n    // Test to see if we should avoid parsing\n    if (parserState.recursiveParserWrapperHandler.hasHitMaximumEmbeddedResources()) {\n        return;\n    }\n    // Work out what this thing is\n    String objectName = getResourceName(metadata, parserState.unknownCount);\n    String objectLocation = this.location + objectName;\n    metadata.add(TikaCoreProperties.EMBEDDED_RESOURCE_PATH, objectLocation);\n    String idPath = (this.embeddedIdPath.equals(\"/\")) ? this.embeddedIdPath + (++parserState.embeddedCount) : (this.embeddedIdPath + \"/\") + (++parserState.embeddedCount);\n    metadata.add(TikaCoreProperties.EMBEDDED_ID_PATH, idPath);\n    metadata.set(TikaCoreProperties.EMBEDDED_ID, parserState.embeddedCount);\n    // get a fresh handler\n    ContentHandler localHandler = parserState.recursiveParserWrapperHandler.getNewContentHandler();\n    parserState.recursiveParserWrapperHandler.startEmbeddedDocument(localHandler, metadata);\n    Parser preContextParser = context.get(Parser.class);\n    context.set(Parser.class, new EmbeddedParserDecorator(getWrappedParser(), objectLocation, idPath, parserState));\n    long started = System.currentTimeMillis();\n    // store the handler that was used before this parse\n    // so that you can return it back to its state at the end of this parse\n    RecursivelySecureContentHandler preParseHandler = context.get(RecursiveParserWrapper.RecursivelySecureContentHandler.class);\n    ParentContentHandler preParseParentHandler = context.get(ParentContentHandler.class);\n    context.set(ParentContentHandler.class, new ParentContentHandler(preParseHandler));\n    TemporaryResources tmp = null;\n    TikaInputStream tis = TikaInputStream.cast(stream);\n    if (tis == null) {\n        tmp = new TemporaryResources();\n        tis = TikaInputStream.get(CloseShieldInputStream.wrap(stream), tmp, metadata);\n    }\n    ContentHandler secureContentHandler = new RecursivelySecureContentHandler(localHandler, tis, preParseHandler.handlerCounter, preParseHandler.throwOnWriteLimitReached, context);\n    try {\n        tis.setCloseShield();\n        super.parse(tis, secureContentHandler, metadata, context);\n    } catch (SAXException e) {\n        if (WriteLimitReachedException.isWriteLimitReached(e)) {\n            metadata.add(TikaCoreProperties.WRITE_LIMIT_REACHED, \"true\");\n            throw e;\n        } else if (catchEmbeddedExceptions) {\n            ParserUtils.recordParserFailure(this, e, metadata);\n        } else {\n            throw e;\n        }\n    } catch (CorruptedFileException e) {\n        throw e;\n    } catch (TikaException e) {\n        if (e instanceof EncryptedDocumentException) {\n            metadata.set(TikaCoreProperties.IS_ENCRYPTED, true);\n        }\n        if ((context.get(ZeroByteFileException.IgnoreZeroByteFileException.class) != null) && (e instanceof ZeroByteFileException)) {\n            // do nothing\n        } else if (catchEmbeddedExceptions) {\n            ParserUtils.recordParserFailure(this, e, metadata);\n        } else {\n            throw e;\n        }\n    } finally {\n        tis.removeCloseShield();\n        context.set(Parser.class, preContextParser);\n        context.set(RecursiveParserWrapper.RecursivelySecureContentHandler.class, preParseHandler);\n        context.set(ParentContentHandler.class, preParseParentHandler);\n        long elapsedMillis = System.currentTimeMillis() - started;\n        metadata.set(TikaCoreProperties.PARSE_TIME_MILLIS, Long.toString(elapsedMillis));\n        parserState.recursiveParserWrapperHandler.endEmbeddedDocument(localHandler, metadata);\n        if (tmp != null) {\n            tis.close();\n        }\n    }\n}",
    "thirdPartyMethod" : "org.apache.commons.io.input.CloseShieldInputStream.wrap",
    "thirdPartyPackage" : "org.apache.commons.io.input",
    "path" : [ "org.apache.tika.parser.RecursiveParserWrapper.EmbeddedParserDecorator.parse" ]
  }, {
    "entryPoint" : "org.apache.tika.embedder.ExternalEmbedder.embed",
    "entryPointBody" : "/**\n * Executes the configured external command and passes the given document\n * stream as a simple XHTML document to the given SAX content handler.\n * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}\n * has been called to set arguments.\n */\n@Override\npublic void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {\n    boolean inputToStdIn = true;\n    boolean outputFromStdOut = true;\n    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());\n    boolean serializeMetadataCommandArgumentsToken = false;\n    boolean replacedMetadataCommandArgumentsToken = false;\n    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);\n    File tempOutputFile = null;\n    List<String> commandMetadataSegments = null;\n    if (hasMetadataCommandArguments) {\n        commandMetadataSegments = getCommandMetadataSegments(metadata);\n    }\n    // Build our command\n    String[] origCmd = command;\n    List<String> cmd = new ArrayList<>();\n    for (String commandSegment : origCmd) {\n        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {\n            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());\n            inputToStdIn = false;\n        }\n        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {\n            tempOutputFile = tmp.createTemporaryFile();\n            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());\n            outputFromStdOut = false;\n        }\n        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {\n            serializeMetadataCommandArgumentsToken = true;\n        }\n        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {\n            if (hasMetadataCommandArguments) {\n                cmd.addAll(commandMetadataSegments);\n            }\n            replacedMetadataCommandArgumentsToken = true;\n        } else {\n            cmd.add(commandSegment);\n        }\n    }\n    if (hasMetadataCommandArguments) {\n        if (serializeMetadataCommandArgumentsToken) {\n            // Find all metadata tokens and replace with encapsulated metadata\n            int i = 0;\n            for (String commandSegment : cmd) {\n                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {\n                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));\n                    cmd.set(i, commandSegment);\n                }\n                i++;\n            }\n        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {\n            // Tack metadata onto the end of the cmd as arguments\n            cmd.addAll(commandMetadataSegments);\n        }\n    }\n    // Execute\n    Process process;\n    if (cmd.toArray().length == 1) {\n        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);\n    } else {\n        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));\n    }\n    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();\n    try {\n        sendStdErrToOutputStream(process, stdErrOutputStream);\n        if (inputToStdIn) {\n            sendInputStreamToStdIn(inputStream, process);\n        } else {\n            // We're not writing to std in this case so close\n            process.getOutputStream().close();\n        }\n        if (outputFromStdOut) {\n            sendStdOutToOutputStream(process, outputStream);\n        } else {\n            tmp.dispose();\n            try {\n                process.waitFor();\n            } catch (InterruptedException ignore) {\n            }\n            // The command is finished, read the output file into the given output stream\n            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());\n            IOUtils.copy(tempOutputFileInputStream, outputStream);\n        }\n    } finally {\n        if (outputFromStdOut) {\n            try {\n                process.waitFor();\n            } catch (InterruptedException ignore) {\n            }\n        } else {\n            try {\n                // Clean up temp output files\n                tempOutputFile.delete();\n            } catch (Exception e) {\n                // swallow\n            }\n        }\n        if (!inputToStdIn) {\n            // Close input file (and delete if created by up\n            // TemporaryResources.createTemporaryFile)\n            IOUtils.closeQuietly(tikaInputStream);\n        }\n        IOUtils.closeQuietly(outputStream);\n        IOUtils.closeQuietly(stdErrOutputStream);\n        if (process.exitValue() != 0) {\n            throw new TikaException((((\"There was an error executing the command line\" + \"\\nExecutable Command:\\n\\n\") + cmd) + \"\\nExecutable Error:\\n\\n\") + stdErrOutputStream.toString(UTF_8.name()));\n        }\n    }\n}",
    "thirdPartyMethod" : "org.apache.commons.io.IOUtils.closeQuietly",
    "thirdPartyPackage" : "org.apache.commons.io",
    "path" : [ "org.apache.tika.embedder.ExternalEmbedder.embed" ]
  }, {
    "entryPoint" : "org.apache.tika.io.TikaInputStream.get",
    "entryPointBody" : "/**\n * Casts or wraps the given stream to a TikaInputStream instance.\n * This method can be used to access the functionality of this class\n * even when given just a normal input stream instance.\n * <p>\n * The given temporary file provider is used for any temporary files,\n * and should be disposed when the returned stream is no longer used.\n * <p>\n * Use this method instead of the {@link #get(InputStream)} alternative\n * when you <em>don't</em> explicitly close the returned stream. The\n * recommended access pattern is:\n * <pre>\n * try (TemporaryResources tmp = new TemporaryResources()) {\n *     TikaInputStream stream = TikaInputStream.get(..., tmp);\n *     // process stream but don't close it\n * }\n * </pre>\n * <p>\n * The given stream instance will <em>not</em> be closed when the\n * {@link TemporaryResources#close()} method is called by the\n * try-with-resources statement. The caller is expected to explicitly\n * close the original stream when it's no longer used.\n *\n * @param stream\n * \t\tnormal input stream\n * @return a TikaInputStream instance\n * @since Apache Tika 0.10\n */\npublic static TikaInputStream get(InputStream stream, TemporaryResources tmp, Metadata metadata) {\n    if (stream == null) {\n        throw new NullPointerException(\"The Stream must not be null\");\n    }\n    if (stream instanceof TikaInputStream) {\n        return ((TikaInputStream) (stream));\n    } else {\n        // Make sure that the stream is buffered and that it\n        // (properly) supports the mark feature\n        if (!stream.markSupported()) {\n            stream = new BufferedInputStream(stream);\n        }\n        return new TikaInputStream(stream, tmp, -1, getExtension(metadata));\n    }\n}",
    "thirdPartyMethod" : "org.apache.commons.io.input.TaggedInputStream.<init>",
    "thirdPartyPackage" : "org.apache.commons.io.input",
    "path" : [ "org.apache.tika.io.TikaInputStream.get", "org.apache.tika.io.TikaInputStream.<init>" ]
  }, {
    "entryPoint" : "org.apache.tika.io.TikaInputStream.get",
    "entryPointBody" : "/**\n * Creates a TikaInputStream from the resource at the given URL. The\n * available input metadata is stored in the given metadata instance.\n * <p>\n * Note that you must always explicitly close the returned stream as in\n * some cases it may end up writing the resource to a temporary file.\n *\n * @param url\n * \t\tresource URL\n * @param metadata\n * \t\tmetadata instance\n * @return a TikaInputStream instance\n * @throws IOException\n * \t\tif the resource can not be accessed\n */\npublic static TikaInputStream get(URL url, Metadata metadata) throws IOException {\n    // Special handling for file:// URLs\n    if (\"file\".equalsIgnoreCase(url.getProtocol())) {\n        try {\n            Path path = Paths.get(url.toURI());\n            if (Files.isRegularFile(path)) {\n                return get(path, metadata);\n            }\n        } catch (URISyntaxException e) {\n            // fall through\n        }\n    }\n    URLConnection connection = url.openConnection();\n    String path = url.getPath();\n    int slash = path.lastIndexOf('/');\n    if ((slash + 1) < path.length()) {\n        // works even with -1!\n        metadata.set(TikaCoreProperties.RESOURCE_NAME_KEY, path.substring(slash + 1));\n    }\n    String type = connection.getContentType();\n    if (type != null) {\n        metadata.set(Metadata.CONTENT_TYPE, type);\n    }\n    String encoding = connection.getContentEncoding();\n    if (encoding != null) {\n        metadata.set(Metadata.CONTENT_ENCODING, encoding);\n    }\n    int length = connection.getContentLength();\n    if (length >= 0) {\n        metadata.set(Metadata.CONTENT_LENGTH, Integer.toString(length));\n    }\n    return new TikaInputStream(new BufferedInputStream(connection.getInputStream()), new TemporaryResources(), length, getExtension(metadata));\n}",
    "thirdPartyMethod" : "org.apache.commons.io.input.TaggedInputStream.<init>",
    "thirdPartyPackage" : "org.apache.commons.io.input",
    "path" : [ "org.apache.tika.io.TikaInputStream.get", "org.apache.tika.io.TikaInputStream.<init>" ]
  }, {
    "entryPoint" : "org.apache.tika.io.TikaInputStream.get",
    "entryPointBody" : "public static TikaInputStream get(Path path, Metadata metadata, TemporaryResources tmp) throws IOException {\n    long length = Files.size(path);\n    if (StringUtils.isBlank(metadata.get(TikaCoreProperties.RESOURCE_NAME_KEY))) {\n        metadata.set(TikaCoreProperties.RESOURCE_NAME_KEY, path.getFileName().toString());\n    }\n    metadata.set(Metadata.CONTENT_LENGTH, Long.toString(length));\n    return new TikaInputStream(path, tmp, length);\n}",
    "thirdPartyMethod" : "org.apache.commons.io.input.TaggedInputStream.<init>",
    "thirdPartyPackage" : "org.apache.commons.io.input",
    "path" : [ "org.apache.tika.io.TikaInputStream.get", "org.apache.tika.io.TikaInputStream.<init>" ]
  }, {
    "entryPoint" : "org.apache.tika.io.TikaInputStream.get",
    "entryPointBody" : "/**\n * Creates a TikaInputStream from the given database BLOB. The BLOB\n * length (if available) is stored as input metadata in the given\n * metadata instance.\n * <p>\n * Note that the result set containing the BLOB may need to be kept open\n * until the returned TikaInputStream has been processed and closed.\n * You must also always explicitly close the returned stream as in\n * some cases it may end up writing the blob data to a temporary file.\n *\n * @param blob\n * \t\tdatabase BLOB\n * @param metadata\n * \t\tmetadata instance\n * @return a TikaInputStream instance\n * @throws SQLException\n * \t\tif BLOB data can not be accessed\n */\npublic static TikaInputStream get(Blob blob, Metadata metadata) throws SQLException {\n    long length = -1;\n    try {\n        length = blob.length();\n        metadata.set(Metadata.CONTENT_LENGTH, Long.toString(length));\n    } catch (SQLException ignore) {\n    }\n    // Prefer an in-memory buffer for reasonably sized blobs to reduce\n    // the likelihood of problems caused by long-lived database accesses\n    if ((0 <= length) && (length <= BLOB_SIZE_THRESHOLD)) {\n        // the offset in Blob.getBytes() starts at 1\n        return get(blob.getBytes(1, ((int) (length))), metadata);\n    } else {\n        return new TikaInputStream(new BufferedInputStream(blob.getBinaryStream()), new TemporaryResources(), length, getExtension(metadata));\n    }\n}",
    "thirdPartyMethod" : "org.apache.commons.io.input.TaggedInputStream.<init>",
    "thirdPartyPackage" : "org.apache.commons.io.input",
    "path" : [ "org.apache.tika.io.TikaInputStream.get", "org.apache.tika.io.TikaInputStream.<init>" ]
  }, {
    "entryPoint" : "org.apache.tika.io.TikaInputStream.get",
    "entryPointBody" : "/**\n * Creates a TikaInputStream from the file at the given path. The file name\n * and length are stored as input metadata in the given metadata instance.\n * <p>\n * If there's an {@link TikaCoreProperties#RESOURCE_NAME_KEY} in the\n * metadata object, this will not overwrite that value with the path's name.\n * <p>\n * Note that you must always explicitly close the returned stream to\n * prevent leaking open file handles.\n *\n * @param path\n * \t\tinput file\n * @param metadata\n * \t\tmetadata instance\n * @return a TikaInputStream instance\n * @throws IOException\n * \t\tif an I/O error occurs\n */\npublic static TikaInputStream get(Path path, Metadata metadata) throws IOException {\n    if (StringUtils.isBlank(metadata.get(TikaCoreProperties.RESOURCE_NAME_KEY))) {\n        metadata.set(TikaCoreProperties.RESOURCE_NAME_KEY, path.getFileName().toString());\n    }\n    metadata.set(Metadata.CONTENT_LENGTH, Long.toString(Files.size(path)));\n    return new TikaInputStream(path);\n}",
    "thirdPartyMethod" : "org.apache.commons.io.input.TaggedInputStream.<init>",
    "thirdPartyPackage" : "org.apache.commons.io.input",
    "path" : [ "org.apache.tika.io.TikaInputStream.get", "org.apache.tika.io.TikaInputStream.<init>" ]
  }, {
    "entryPoint" : "org.apache.tika.io.TikaInputStream.get",
    "entryPointBody" : "/**\n * Creates a TikaInputStream from the given file. The file name and\n * length are stored as input metadata in the given metadata instance.\n * <p>\n * Note that you must always explicitly close the returned stream to\n * prevent leaking open file handles.\n *\n * @param file\n * \t\tinput file\n * @param metadata\n * \t\tmetadata instance\n * @return a TikaInputStream instance\n * @throws FileNotFoundException\n * \t\tif the file does not exist\n * \t\tor cannot be opened for reading\n * @deprecated use {@link #get(Path, Metadata)}. In Tika 2.0,\nthis will be removed or modified to throw an IOException.\n */\n@Deprecated\npublic static TikaInputStream get(File file, Metadata metadata) throws FileNotFoundException {\n    if (StringUtils.isBlank(metadata.get(TikaCoreProperties.RESOURCE_NAME_KEY))) {\n        metadata.set(TikaCoreProperties.RESOURCE_NAME_KEY, file.getName());\n    }\n    metadata.set(Metadata.CONTENT_LENGTH, Long.toString(file.length()));\n    return new TikaInputStream(file);\n}",
    "thirdPartyMethod" : "org.apache.commons.io.input.TaggedInputStream.<init>",
    "thirdPartyPackage" : "org.apache.commons.io.input",
    "path" : [ "org.apache.tika.io.TikaInputStream.get", "org.apache.tika.io.TikaInputStream.<init>" ]
  }, {
    "entryPoint" : "org.apache.tika.io.TikaInputStream.get",
    "entryPointBody" : "/**\n * Creates a TikaInputStream from the given array of bytes. The length of\n * the array is stored as input metadata in the given metadata instance.\n * <p>\n * Note that you must always explicitly close the returned stream as in\n * some cases it may end up writing the given data to a temporary file.\n *\n * @param data\n * \t\tinput data\n * @param metadata\n * \t\tmetadata instance\n * @return a TikaInputStream instance\n */\npublic static TikaInputStream get(byte[] data, Metadata metadata) {\n    metadata.set(Metadata.CONTENT_LENGTH, Integer.toString(data.length));\n    return new TikaInputStream(new UnsynchronizedByteArrayInputStream(data), new TemporaryResources(), data.length, getExtension(metadata));\n}",
    "thirdPartyMethod" : "org.apache.commons.io.input.TaggedInputStream.<init>",
    "thirdPartyPackage" : "org.apache.commons.io.input",
    "path" : [ "org.apache.tika.io.TikaInputStream.get", "org.apache.tika.io.TikaInputStream.<init>" ]
  }, {
    "entryPoint" : "org.apache.tika.config.TikaActivator.start",
    "entryPointBody" : "// -----------------------------------------------------< BundleActivator >\npublic void start(final BundleContext context) throws Exception {\n    bundleContext = context;\n    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);\n    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);\n    detectorTracker.open();\n    parserTracker.open();\n}",
    "thirdPartyMethod" : "org.osgi.util.tracker.ServiceTracker.<init>",
    "thirdPartyPackage" : "org.osgi.util.tracker",
    "path" : [ "org.apache.tika.config.TikaActivator.start" ]
  }, {
    "entryPoint" : "org.apache.tika.fork.ForkClient.<init>",
    "entryPointBody" : "public ForkClient(Path tikaDir, ParserFactoryFactory parserFactoryFactory, List<String> java, TimeoutLimits timeoutLimits) throws IOException, TikaException {\n    this(tikaDir, parserFactoryFactory, null, java, timeoutLimits);\n}",
    "thirdPartyMethod" : "org.apache.commons.io.IOUtils.copy",
    "thirdPartyPackage" : "org.apache.commons.io",
    "path" : [ "org.apache.tika.fork.ForkClient.<init>", "org.apache.tika.fork.ForkClient.createBootstrapJar", "org.apache.tika.fork.ForkClient.fillBootstrapJar" ]
  }, {
    "entryPoint" : "org.apache.tika.io.BoundedInputStream.transferTo",
    "entryPointBody" : "@Override\npublic long transferTo(OutputStream out) throws IOException {\n    return IOUtils.copy(this, out);\n}",
    "thirdPartyMethod" : "org.apache.commons.io.IOUtils.copy",
    "thirdPartyPackage" : "org.apache.commons.io",
    "path" : [ "org.apache.tika.io.BoundedInputStream.transferTo" ]
  }, {
    "entryPoint" : "org.apache.tika.parser.NetworkParser.ParsingTask.run",
    "entryPointBody" : "// ----------------------------------------------------------<Runnable>\npublic void run() {\n    try {\n        try {\n            IOUtils.copy(input, output);\n        } finally {\n            output.close();\n        }\n    } catch (Exception e) {\n        exception = e;\n    }\n}",
    "thirdPartyMethod" : "org.apache.commons.io.IOUtils.copy",
    "thirdPartyPackage" : "org.apache.commons.io",
    "path" : [ "org.apache.tika.parser.NetworkParser.ParsingTask.run" ]
  }, {
    "entryPoint" : "org.apache.tika.embedder.ExternalEmbedder.embed",
    "entryPointBody" : "/**\n * Executes the configured external command and passes the given document\n * stream as a simple XHTML document to the given SAX content handler.\n * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}\n * has been called to set arguments.\n */\n@Override\npublic void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {\n    boolean inputToStdIn = true;\n    boolean outputFromStdOut = true;\n    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());\n    boolean serializeMetadataCommandArgumentsToken = false;\n    boolean replacedMetadataCommandArgumentsToken = false;\n    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);\n    File tempOutputFile = null;\n    List<String> commandMetadataSegments = null;\n    if (hasMetadataCommandArguments) {\n        commandMetadataSegments = getCommandMetadataSegments(metadata);\n    }\n    // Build our command\n    String[] origCmd = command;\n    List<String> cmd = new ArrayList<>();\n    for (String commandSegment : origCmd) {\n        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {\n            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());\n            inputToStdIn = false;\n        }\n        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {\n            tempOutputFile = tmp.createTemporaryFile();\n            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());\n            outputFromStdOut = false;\n        }\n        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {\n            serializeMetadataCommandArgumentsToken = true;\n        }\n        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {\n            if (hasMetadataCommandArguments) {\n                cmd.addAll(commandMetadataSegments);\n            }\n            replacedMetadataCommandArgumentsToken = true;\n        } else {\n            cmd.add(commandSegment);\n        }\n    }\n    if (hasMetadataCommandArguments) {\n        if (serializeMetadataCommandArgumentsToken) {\n            // Find all metadata tokens and replace with encapsulated metadata\n            int i = 0;\n            for (String commandSegment : cmd) {\n                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {\n                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));\n                    cmd.set(i, commandSegment);\n                }\n                i++;\n            }\n        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {\n            // Tack metadata onto the end of the cmd as arguments\n            cmd.addAll(commandMetadataSegments);\n        }\n    }\n    // Execute\n    Process process;\n    if (cmd.toArray().length == 1) {\n        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);\n    } else {\n        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));\n    }\n    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();\n    try {\n        sendStdErrToOutputStream(process, stdErrOutputStream);\n        if (inputToStdIn) {\n            sendInputStreamToStdIn(inputStream, process);\n        } else {\n            // We're not writing to std in this case so close\n            process.getOutputStream().close();\n        }\n        if (outputFromStdOut) {\n            sendStdOutToOutputStream(process, outputStream);\n        } else {\n            tmp.dispose();\n            try {\n                process.waitFor();\n            } catch (InterruptedException ignore) {\n            }\n            // The command is finished, read the output file into the given output stream\n            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());\n            IOUtils.copy(tempOutputFileInputStream, outputStream);\n        }\n    } finally {\n        if (outputFromStdOut) {\n            try {\n                process.waitFor();\n            } catch (InterruptedException ignore) {\n            }\n        } else {\n            try {\n                // Clean up temp output files\n                tempOutputFile.delete();\n            } catch (Exception e) {\n                // swallow\n            }\n        }\n        if (!inputToStdIn) {\n            // Close input file (and delete if created by up\n            // TemporaryResources.createTemporaryFile)\n            IOUtils.closeQuietly(tikaInputStream);\n        }\n        IOUtils.closeQuietly(outputStream);\n        IOUtils.closeQuietly(stdErrOutputStream);\n        if (process.exitValue() != 0) {\n            throw new TikaException((((\"There was an error executing the command line\" + \"\\nExecutable Command:\\n\\n\") + cmd) + \"\\nExecutable Error:\\n\\n\") + stdErrOutputStream.toString(UTF_8.name()));\n        }\n    }\n}",
    "thirdPartyMethod" : "org.apache.commons.io.IOUtils.copy",
    "thirdPartyPackage" : "org.apache.commons.io",
    "path" : [ "org.apache.tika.embedder.ExternalEmbedder.embed" ]
  }, {
    "entryPoint" : "org.apache.tika.config.TikaActivator.start",
    "entryPointBody" : "// -----------------------------------------------------< BundleActivator >\npublic void start(final BundleContext context) throws Exception {\n    bundleContext = context;\n    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);\n    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);\n    detectorTracker.open();\n    parserTracker.open();\n}",
    "thirdPartyMethod" : "org.osgi.util.tracker.ServiceTracker.open",
    "thirdPartyPackage" : "org.osgi.util.tracker",
    "path" : [ "org.apache.tika.config.TikaActivator.start" ]
  } ]
}